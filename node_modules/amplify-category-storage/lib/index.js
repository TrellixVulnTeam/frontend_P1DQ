"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.initEnv = exports.handleAmplifyEvent = exports.executeAmplifyCommand = exports.getPermissionPolicies = exports.migrate = exports.console = exports.add = exports.category = void 0;
const amplify_cli_core_1 = require("amplify-cli-core");
const amplify_prompts_1 = require("amplify-prompts");
const path = __importStar(require("path"));
const promise_sequential_1 = __importDefault(require("promise-sequential"));
const awscloudformation_1 = require("./provider-utils/awscloudformation");
const constants_1 = require("./constants");
var constants_2 = require("./constants");
Object.defineProperty(exports, "category", { enumerable: true, get: function () { return constants_2.categoryName; } });
async function add(context, providerName, service) {
    const options = {
        service,
        providerPlugin: providerName,
    };
    const providerController = await Promise.resolve().then(() => __importStar(require(`./provider-utils/${providerName}`)));
    if (!providerController) {
        amplify_prompts_1.printer.error('Provider not configured for this category');
        return;
    }
    return providerController.addResource(context, constants_1.categoryName, service, options);
}
exports.add = add;
async function console(context) {
    amplify_prompts_1.printer.info(`to be implemented: ${constants_1.categoryName} console`);
}
exports.console = console;
async function migrate(context) {
    const { projectPath, amplifyMeta } = context.migrationInfo;
    const migrateResourcePromises = [];
    const categoryResources = (amplifyMeta === null || amplifyMeta === void 0 ? void 0 : amplifyMeta[constants_1.categoryName]) || {};
    for (const resourceName of Object.keys(categoryResources)) {
        try {
            const providerController = await Promise.resolve().then(() => __importStar(require(`./provider-utils/${amplifyMeta[constants_1.categoryName][resourceName].providerPlugin}`)));
            if (providerController) {
                migrateResourcePromises.push(await providerController.migrateResource(context, projectPath, amplifyMeta[constants_1.categoryName][resourceName].service, resourceName));
            }
            else {
                amplify_prompts_1.printer.error(`Provider not configured for ${constants_1.categoryName}: ${resourceName}`);
            }
        }
        catch (e) {
            amplify_prompts_1.printer.warn(`Could not run migration for ${constants_1.categoryName}: ${resourceName}`);
            throw e;
        }
    }
    await Promise.all(migrateResourcePromises);
}
exports.migrate = migrate;
async function getPermissionPolicies(context, resourceOpsMapping) {
    const amplifyMeta = amplify_cli_core_1.stateManager.getMeta();
    const permissionPolicies = [];
    const resourceAttributes = [];
    for (const resourceName of Object.keys(resourceOpsMapping)) {
        try {
            const providerPlugin = 'providerPlugin' in resourceOpsMapping[resourceName]
                ? resourceOpsMapping[resourceName].providerPlugin
                : amplifyMeta[constants_1.categoryName][resourceName].providerPlugin;
            const service = 'service' in resourceOpsMapping[resourceName]
                ? resourceOpsMapping[resourceName].service
                : amplifyMeta[constants_1.categoryName][resourceName].service;
            if (providerPlugin) {
                const providerController = await Promise.resolve().then(() => __importStar(require(`./provider-utils/${providerPlugin}`)));
                const { policy, attributes } = await providerController.getPermissionPolicies(service, resourceName, resourceOpsMapping[resourceName]);
                if (Array.isArray(policy)) {
                    permissionPolicies.push(...policy);
                }
                else {
                    permissionPolicies.push(policy);
                }
                resourceAttributes.push({ resourceName, attributes, category: constants_1.categoryName });
            }
            else {
                amplify_prompts_1.printer.error(`Provider not configured for ${constants_1.categoryName}: ${resourceName}`);
            }
        }
        catch (e) {
            amplify_prompts_1.printer.warn(`Could not get policies for ${constants_1.categoryName}: ${resourceName}`);
            throw e;
        }
    }
    return { permissionPolicies, resourceAttributes };
}
exports.getPermissionPolicies = getPermissionPolicies;
async function executeAmplifyCommand(context) {
    let commandPath = path.normalize(path.join(__dirname, 'commands'));
    if (context.input.command === 'help') {
        commandPath = path.join(commandPath, constants_1.categoryName);
    }
    else {
        commandPath = path.join(commandPath, constants_1.categoryName, context.input.command);
    }
    const commandModule = await Promise.resolve().then(() => __importStar(require(commandPath)));
    await commandModule.run(context);
}
exports.executeAmplifyCommand = executeAmplifyCommand;
async function handleAmplifyEvent(context, args) {
    amplify_prompts_1.printer.info(`${constants_1.categoryName} handleAmplifyEvent to be implemented`);
    amplify_prompts_1.printer.info(`Received event args ${args}`);
}
exports.handleAmplifyEvent = handleAmplifyEvent;
async function initEnv(context) {
    const { resourcesToBeSynced, allResources } = await context.amplify.getResourceStatus(constants_1.categoryName);
    const isPulling = context.input.command === 'pull' || (context.input.command === 'env' && context.input.subCommands[0] === 'pull');
    let toBeSynced = [];
    if (resourcesToBeSynced && resourcesToBeSynced.length > 0) {
        toBeSynced = resourcesToBeSynced.filter((b) => b.category === constants_1.categoryName);
    }
    toBeSynced
        .filter(storageResource => storageResource.sync === 'unlink')
        .forEach(storageResource => {
        context.amplify.removeResourceParameters(context, constants_1.categoryName, storageResource.resourceName);
    });
    let tasks = [];
    if (!isPulling) {
        tasks = tasks.concat(toBeSynced);
    }
    if (isPulling && allResources.length > 0) {
        tasks.push(...allResources);
    }
    const storageTasks = tasks.map(storageResource => {
        const { resourceName, service } = storageResource;
        return async () => {
            const config = await awscloudformation_1.updateConfigOnEnvInit(context, constants_1.categoryName, resourceName, service);
            context.amplify.saveEnvResourceParameters(context, constants_1.categoryName, resourceName, config);
        };
    });
    await promise_sequential_1.default(storageTasks);
}
exports.initEnv = initEnv;
//# sourceMappingURL=index.js.map