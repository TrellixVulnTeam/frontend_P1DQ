"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.getIAMPolicies = exports.migrate = exports.checkIfAuthExists = exports.resourceAlreadyExists = exports.updateWalkthrough = exports.addWalkthrough = void 0;
const amplify_cli_core_1 = require("amplify-cli-core");
const amplify_prompts_1 = require("amplify-prompts");
const fs = __importStar(require("fs-extra"));
const inquirer_1 = __importDefault(require("inquirer"));
const lodash_1 = __importDefault(require("lodash"));
const os_1 = __importDefault(require("os"));
const path = __importStar(require("path"));
const uuid_1 = __importDefault(require("uuid"));
const constants_1 = require("../../../constants");
const storage_state_management_1 = require("../storage-state-management");
const permissionMap = {
    'create/update': ['s3:PutObject'],
    read: ['s3:GetObject', 's3:ListBucket'],
    delete: ['s3:DeleteObject'],
};
const addWalkthrough = async (context, defaultValuesFilename, serviceMetadata, options) => {
    while (!exports.checkIfAuthExists()) {
        if (await amplify_prompts_1.prompter.confirmContinue('You need to add auth (Amazon Cognito) to your project in order to add storage for user files. Do you want to add auth now?')) {
            await context.amplify.invokePluginMethod(context, 'auth', undefined, 'add', [context]);
            break;
        }
        else {
            await context.usageData.emitSuccess();
            amplify_cli_core_1.exitOnNextTick(0);
        }
    }
    const resourceName = exports.resourceAlreadyExists();
    if (resourceName) {
        const errMessage = 'Amazon S3 storage was already added to your project.';
        amplify_prompts_1.printer.warn(errMessage);
        await context.usageData.emitError(new amplify_cli_core_1.ResourceAlreadyExistsError(errMessage));
        amplify_cli_core_1.exitOnNextTick(0);
    }
    else {
        return await configure(context, defaultValuesFilename, serviceMetadata, undefined, options);
    }
};
exports.addWalkthrough = addWalkthrough;
const updateWalkthrough = async (context, defaultValuesFilename, serviceMetada) => {
    const amplifyMeta = amplify_cli_core_1.stateManager.getMeta();
    const storageResources = {};
    Object.keys(amplifyMeta[constants_1.categoryName]).forEach(resourceName => {
        if (amplifyMeta[constants_1.categoryName][resourceName].service === constants_1.ServiceName.S3 &&
            amplifyMeta[constants_1.categoryName][resourceName].mobileHubMigrated !== true) {
            storageResources[resourceName] = amplifyMeta[constants_1.categoryName][resourceName];
        }
    });
    if (Object.keys(storageResources).length === 0) {
        const errMessage = 'No resources to update. You need to add a resource.';
        amplify_prompts_1.printer.error(errMessage);
        await context.usageData.emitError(new amplify_cli_core_1.ResourceDoesNotExistError(errMessage));
        amplify_cli_core_1.exitOnNextTick(0);
        return;
    }
    const [resourceName] = Object.keys(storageResources);
    if (amplifyMeta[constants_1.categoryName][resourceName].serviceType === 'imported') {
        amplify_prompts_1.printer.error('Updating of an imported storage resource is not supported.');
        return;
    }
    return configure(context, defaultValuesFilename, serviceMetada, resourceName);
};
exports.updateWalkthrough = updateWalkthrough;
async function configure(context, defaultValuesFilename, serviceMetadata, resourceName, options) {
    const { amplify } = context;
    let { inputs } = serviceMetadata;
    const defaultValuesSrc = path.join(__dirname, '..', 'default-values', defaultValuesFilename);
    const { getAllDefaults } = await Promise.resolve().then(() => __importStar(require(defaultValuesSrc)));
    const defaultValues = getAllDefaults(amplify.getProjectDetails());
    const projectRoot = amplify_cli_core_1.pathManager.findProjectRoot();
    let parameters = {};
    let storageParams = {};
    if (resourceName) {
        inputs = inputs.filter((input) => input.key !== 'resourceName');
        try {
            parameters = amplify_cli_core_1.stateManager.getResourceParametersJson(undefined, constants_1.categoryName, resourceName);
        }
        catch (e) {
            parameters = {};
        }
        parameters.resourceName = resourceName;
        Object.assign(defaultValues, parameters);
        storageParams = storage_state_management_1.readStorageParamsFileSafe(resourceName);
    }
    let answers = {};
    if (!parameters.resourceName) {
        const questions = [];
        for (const input of inputs) {
            let question = {
                name: input.key,
                message: input.question,
                validate: amplify.inputValidation(input),
                default: () => {
                    const defaultValue = defaultValues[input.key];
                    return defaultValue;
                },
            };
            if (input.type && input.type === 'list') {
                question = Object.assign({
                    type: 'list',
                    choices: input.options,
                }, question);
            }
            else if (input.type && input.type === 'multiselect') {
                question = Object.assign({
                    type: 'checkbox',
                    choices: input.options,
                }, question);
            }
            else {
                question = Object.assign({
                    type: 'input',
                }, question);
            }
            questions.push(question);
        }
        answers = await inquirer_1.default.prompt(questions);
    }
    if (parameters.resourceName) {
        if (parameters.selectedGuestPermissions && parameters.selectedGuestPermissions.length !== 0) {
            Object.assign(defaultValues, { storageAccess: 'authAndGuest' });
        }
        if (parameters.selectedGuestPermissions || parameters.selectedAuthenticatedPermissions) {
            convertToCRUD(parameters, answers);
        }
    }
    const userPoolGroupList = context.amplify.getUserPoolGroupList();
    let permissionSelected = 'Auth/Guest Users';
    let allowUnauthenticatedIdentities;
    if (userPoolGroupList.length > 0) {
        do {
            if (permissionSelected === 'Learn more') {
                amplify_prompts_1.printer.info('');
                amplify_prompts_1.printer.info('You can restrict access using CRUD policies for Authenticated Users, Guest Users, or on individual Groups that users belong to in a User Pool. If a user logs into your application and is not a member of any group they will use policy set for “Authenticated Users”, however if they belong to a group they will only get the policy associated with that specific group.');
                amplify_prompts_1.printer.info('');
            }
            const permissionSelection = await inquirer_1.default.prompt({
                name: 'selection',
                type: 'list',
                message: 'Restrict access by?',
                choices: ['Auth/Guest Users', 'Individual Groups', 'Both', 'Learn more'],
                default: 'Auth/Guest Users',
            });
            permissionSelected = permissionSelection.selection;
        } while (permissionSelected === 'Learn more');
    }
    if (permissionSelected === 'Both' || permissionSelected === 'Auth/Guest Users') {
        const accessQuestion = await inquirer_1.default.prompt({
            type: 'list',
            name: 'storageAccess',
            message: 'Who should have access:',
            choices: [
                {
                    name: 'Auth users only',
                    value: 'auth',
                },
                {
                    name: 'Auth and guest users',
                    value: 'authAndGuest',
                },
            ],
            default: defaultValues.storageAccess,
        });
        answers = { ...answers, storageAccess: accessQuestion.storageAccess };
        answers.selectedAuthenticatedPermissions = await askReadWrite('Authenticated', context, answers, parameters);
        if (answers.storageAccess === 'authAndGuest') {
            answers.selectedGuestPermissions = await askReadWrite('Guest', context, answers, parameters);
            allowUnauthenticatedIdentities = true;
        }
    }
    if (permissionSelected === 'Both' || permissionSelected === 'Individual Groups') {
        if (permissionSelected === 'Individual Groups') {
            removeAuthUnauthAccess(answers);
        }
        let defaultSelectedGroups = [];
        if (storageParams && storageParams.groupPermissionMap) {
            defaultSelectedGroups = Object.keys(storageParams.groupPermissionMap);
        }
        const userPoolGroupSelection = await inquirer_1.default.prompt([
            {
                name: 'userpoolGroups',
                type: 'checkbox',
                message: 'Select groups:',
                choices: userPoolGroupList,
                default: defaultSelectedGroups,
                validate: selectedAnswers => {
                    if (selectedAnswers.length === 0) {
                        return 'Select at least one option';
                    }
                    return true;
                },
            },
        ]);
        const selectedUserPoolGroupList = userPoolGroupSelection.userpoolGroups;
        const groupCrudFlow = async (group, defaults = []) => {
            const possibleOperations = Object.keys(permissionMap).map(el => ({ name: el, value: el }));
            const crudAnswers = await inquirer_1.default.prompt({
                name: 'permissions',
                type: 'checkbox',
                message: `What kind of access do you want for ${group} users?`,
                choices: possibleOperations,
                default: defaults,
                validate: selectedAnswers => {
                    if (selectedAnswers.length === 0) {
                        return 'Select at least one option';
                    }
                    return true;
                },
            });
            return {
                permissions: crudAnswers.permissions,
                policies: lodash_1.default.uniq(lodash_1.default.flatten(crudAnswers.permissions.map((e) => permissionMap[e]))),
            };
        };
        const groupPermissionMap = {};
        const groupPolicyMap = {};
        for (const selectedUserPoolGroup of selectedUserPoolGroupList) {
            let defaults = [];
            if (storageParams && storageParams.groupPermissionMap) {
                defaults = storageParams.groupPermissionMap[selectedUserPoolGroup];
            }
            const crudAnswers = await groupCrudFlow(selectedUserPoolGroup, defaults);
            groupPermissionMap[selectedUserPoolGroup] = crudAnswers.permissions;
            groupPolicyMap[selectedUserPoolGroup] = crudAnswers.policies;
        }
        let authResources = (await context.amplify.getResourceStatus('auth')).allResources;
        authResources = authResources.filter((resource) => resource.service === 'Cognito');
        if (authResources.length === 0) {
            throw new Error('No auth resource found. Please add it using amplify add auth');
        }
        const authResourceName = authResources[0].resourceName;
        storageParams.groupPermissionMap = groupPermissionMap;
        if (!resourceName) {
            if (!options.dependsOn) {
                options.dependsOn = [];
            }
            options.dependsOn.push({
                category: 'auth',
                resourceName: authResourceName,
                attributes: ['UserPoolId'],
            });
            selectedUserPoolGroupList.forEach((group) => {
                options.dependsOn.push({
                    category: 'auth',
                    resourceName: 'userPoolGroups',
                    attributes: [`${group}GroupRole`],
                });
            });
            defaultValues.authResourceName = authResourceName;
            defaultValues.groupList = selectedUserPoolGroupList;
            defaultValues.groupPolicyMap = groupPolicyMap;
        }
        else {
            await updateCfnTemplateWithGroups(context, defaultSelectedGroups, selectedUserPoolGroupList, groupPolicyMap, resourceName, authResourceName);
        }
    }
    if (!parameters || !parameters.triggerFunction || parameters.triggerFunction === 'NONE') {
        if (await amplify.confirmPrompt('Do you want to add a Lambda Trigger for your S3 Bucket?', false)) {
            try {
                answers.triggerFunction = await addTrigger(context, parameters.resourceName, undefined, parameters.adminTriggerFunction, options);
            }
            catch (e) {
                amplify_prompts_1.printer.error(e.message);
            }
        }
        else {
            answers.triggerFunction = 'NONE';
        }
    }
    else {
        const triggerOperationQuestion = {
            type: 'list',
            name: 'triggerOperation',
            message: 'Select from the following options',
            choices: ['Update the Trigger', 'Remove the trigger', 'Skip Question'],
        };
        let continueWithTriggerOperationQuestion = true;
        while (continueWithTriggerOperationQuestion) {
            const triggerOperationAnswer = await inquirer_1.default.prompt([triggerOperationQuestion]);
            switch (triggerOperationAnswer.triggerOperation) {
                case 'Update the Trigger': {
                    try {
                        answers.triggerFunction = await addTrigger(context, parameters.resourceName, parameters.triggerFunction, parameters.adminTriggerFunction, options);
                        continueWithTriggerOperationQuestion = false;
                    }
                    catch (e) {
                        amplify_prompts_1.printer.error(e.message);
                        continueWithTriggerOperationQuestion = true;
                    }
                    break;
                }
                case 'Remove the trigger': {
                    answers.triggerFunction = 'NONE';
                    await removeTrigger(context, parameters.resourceName, parameters.triggerFunction);
                    continueWithTriggerOperationQuestion = false;
                    break;
                }
                case 'Skip Question': {
                    if (!parameters.triggerFunction) {
                        answers.triggerFunction = 'NONE';
                    }
                    continueWithTriggerOperationQuestion = false;
                    break;
                }
                default:
                    amplify_prompts_1.printer.error(`${triggerOperationAnswer.triggerOperation} not supported`);
            }
        }
    }
    const storageRequirements = { authSelections: 'identityPoolAndUserPool', allowUnauthenticatedIdentities };
    const checkResult = await context.amplify.invokePluginMethod(context, 'auth', undefined, 'checkRequirements', [
        storageRequirements,
        context,
        'storage',
        answers.resourceName,
    ]);
    if (checkResult.authImported === true && checkResult.errors && checkResult.errors.length > 0) {
        throw new Error(checkResult.errors.join(os_1.default.EOL));
    }
    if (checkResult.errors && checkResult.errors.length > 0) {
        amplify_prompts_1.printer.warn(checkResult.errors.join(os_1.default.EOL));
    }
    if (!checkResult.authEnabled || !checkResult.requirementsMet) {
        try {
            if (storageRequirements.allowUnauthenticatedIdentities === undefined) {
                storageRequirements.allowUnauthenticatedIdentities = false;
            }
            await context.amplify.invokePluginMethod(context, 'auth', undefined, 'externalAuthEnable', [
                context,
                constants_1.categoryName,
                answers.resourceName,
                storageRequirements,
            ]);
        }
        catch (error) {
            amplify_prompts_1.printer.error(error);
            throw error;
        }
    }
    Object.assign(defaultValues, answers);
    const resource = defaultValues.resourceName;
    const resourceDirPath = amplify_cli_core_1.pathManager.getResourceDirectoryPath(projectRoot, constants_1.categoryName, resource);
    fs.ensureDirSync(resourceDirPath);
    let props = { ...defaultValues };
    if (!parameters.resourceName) {
        if (options) {
            props = { ...defaultValues, ...options };
        }
        await copyCfnTemplate(context, constants_1.categoryName, resource, props);
    }
    delete defaultValues.resourceName;
    delete defaultValues.storageAccess;
    delete defaultValues.groupPolicyMap;
    delete defaultValues.groupList;
    delete defaultValues.authResourceName;
    amplify_cli_core_1.stateManager.setResourceParametersJson(undefined, constants_1.categoryName, resourceName || resource, defaultValues);
    storage_state_management_1.writeToStorageParamsFile(resourceName || resource, storageParams);
    return resource;
}
async function copyCfnTemplate(context, categoryName, resourceName, options) {
    const targetDir = amplify_cli_core_1.pathManager.getBackendDirPath();
    const pluginDir = __dirname;
    const copyJobs = [
        {
            dir: pluginDir,
            template: path.join('..', '..', '..', '..', 'resources', 'cloudformation-templates', constants_1.templateFilenameMap[constants_1.ServiceName.S3]),
            target: path.join(targetDir, categoryName, resourceName, 's3-cloudformation-template.json'),
        },
    ];
    return await context.amplify.copyBatch(context, copyJobs, options);
}
async function updateCfnTemplateWithGroups(context, oldGroupList, newGroupList, newGroupPolicyMap, s3ResourceName, authResourceName) {
    const groupsToBeDeleted = lodash_1.default.difference(oldGroupList, newGroupList);
    const projectRoot = amplify_cli_core_1.pathManager.findProjectRoot();
    const resourceDirPath = amplify_cli_core_1.pathManager.getResourceDirectoryPath(projectRoot, constants_1.categoryName, s3ResourceName);
    const storageCFNFilePath = path.join(resourceDirPath, 's3-cloudformation-template.json');
    const { cfnTemplate: storageCFNFile } = await amplify_cli_core_1.readCFNTemplate(storageCFNFilePath);
    const amplifyMetaFile = amplify_cli_core_1.stateManager.getMeta(projectRoot);
    let s3DependsOnResources = amplifyMetaFile.storage[s3ResourceName].dependsOn || [];
    s3DependsOnResources = s3DependsOnResources.filter((resource) => resource.category !== 'auth');
    if (newGroupList.length > 0) {
        s3DependsOnResources.push({
            category: 'auth',
            resourceName: authResourceName,
            attributes: ['UserPoolId'],
        });
    }
    storageCFNFile.Parameters[`auth${authResourceName}UserPoolId`] = {
        Type: 'String',
        Default: `auth${authResourceName}UserPoolId`,
    };
    groupsToBeDeleted.forEach(group => {
        delete storageCFNFile.Parameters[`authuserPoolGroups${group}GroupRole`];
        delete storageCFNFile.Resources[`${group}GroupPolicy`];
    });
    newGroupList.forEach(group => {
        s3DependsOnResources.push({
            category: 'auth',
            resourceName: 'userPoolGroups',
            attributes: [`${group}GroupRole`],
        });
        storageCFNFile.Parameters[`authuserPoolGroups${group}GroupRole`] = {
            Type: 'String',
            Default: `authuserPoolGroups${group}GroupRole`,
        };
        storageCFNFile.Resources[`${group}GroupPolicy`] = {
            Type: 'AWS::IAM::Policy',
            Properties: {
                PolicyName: `${group}-group-s3-policy`,
                Roles: [
                    {
                        'Fn::Join': [
                            '',
                            [
                                {
                                    Ref: `auth${authResourceName}UserPoolId`,
                                },
                                `-${group}GroupRole`,
                            ],
                        ],
                    },
                ],
                PolicyDocument: {
                    Version: '2012-10-17',
                    Statement: [
                        {
                            Effect: 'Allow',
                            Action: newGroupPolicyMap[group],
                            Resource: [
                                {
                                    'Fn::Join': [
                                        '',
                                        [
                                            'arn:aws:s3:::',
                                            {
                                                Ref: 'S3Bucket',
                                            },
                                            '/*',
                                        ],
                                    ],
                                },
                            ],
                        },
                    ],
                },
            },
        };
    });
    newGroupList.forEach(group => {
        if (newGroupPolicyMap[group].includes('s3:ListBucket') === true) {
            storageCFNFile.Resources[`${group}GroupPolicy`].Properties.PolicyDocument.Statement.push({
                Effect: 'Allow',
                Action: 's3:ListBucket',
                Resource: [
                    {
                        'Fn::Join': [
                            '',
                            [
                                'arn:aws:s3:::',
                                {
                                    Ref: 'S3Bucket',
                                },
                            ],
                        ],
                    },
                ],
            });
        }
    });
    context.amplify.updateamplifyMetaAfterResourceUpdate(constants_1.categoryName, s3ResourceName, 'dependsOn', s3DependsOnResources);
    await amplify_cli_core_1.writeCFNTemplate(storageCFNFile, storageCFNFilePath);
}
async function removeTrigger(context, resourceName, triggerFunction) {
    const projectRoot = amplify_cli_core_1.pathManager.findProjectRoot();
    const resourceDirPath = amplify_cli_core_1.pathManager.getResourceDirectoryPath(projectRoot, constants_1.categoryName, resourceName);
    const storageCFNFilePath = path.join(resourceDirPath, 's3-cloudformation-template.json');
    const { cfnTemplate: storageCFNFile } = await amplify_cli_core_1.readCFNTemplate(storageCFNFilePath);
    const bucketParameters = amplify_cli_core_1.stateManager.getResourceParametersJson(projectRoot, constants_1.categoryName, resourceName);
    const adminTrigger = bucketParameters.adminTriggerFunction;
    delete storageCFNFile.Parameters[`function${triggerFunction}Arn`];
    delete storageCFNFile.Parameters[`function${triggerFunction}Name`];
    delete storageCFNFile.Parameters[`function${triggerFunction}LambdaExecutionRole`];
    delete storageCFNFile.Resources.TriggerPermissions;
    if (!adminTrigger) {
        delete storageCFNFile.Resources.S3Bucket.Properties.NotificationConfiguration;
        delete storageCFNFile.Resources.S3TriggerBucketPolicy;
        delete storageCFNFile.Resources.S3Bucket.DependsOn;
    }
    else {
        const lambdaConfigurations = [];
        storageCFNFile.Resources.S3Bucket.Properties.NotificationConfiguration.LambdaConfigurations.forEach((triggers) => {
            if (triggers.Filter &&
                typeof triggers.Filter.S3Key.Rules[0].Value === 'string' &&
                triggers.Filter.S3Key.Rules[0].Value.includes('index-faces')) {
                lambdaConfigurations.push(triggers);
            }
        });
        storageCFNFile.Resources.S3Bucket.Properties.NotificationConfiguration.LambdaConfigurations = lambdaConfigurations;
        const index = storageCFNFile.Resources.S3Bucket.DependsOn.indexOf('TriggerPermissions');
        if (index > -1) {
            storageCFNFile.Resources.S3Bucket.DependsOn.splice(index, 1);
        }
        const roles = [];
        storageCFNFile.Resources.S3TriggerBucketPolicy.Properties.Roles.forEach((role) => {
            if (!role.Ref.includes(triggerFunction)) {
                roles.push(role);
            }
        });
        storageCFNFile.Resources.S3TriggerBucketPolicy.Properties.Roles = roles;
    }
    await amplify_cli_core_1.writeCFNTemplate(storageCFNFile, storageCFNFilePath);
    const amplifyMeta = amplify_cli_core_1.stateManager.getMeta();
    const s3DependsOnResources = amplifyMeta.storage[resourceName].dependsOn;
    const s3Resources = [];
    s3DependsOnResources.forEach((resource) => {
        if (resource.resourceName !== triggerFunction) {
            s3Resources.push(resource);
        }
    });
    context.amplify.updateamplifyMetaAfterResourceUpdate(constants_1.categoryName, resourceName, 'dependsOn', s3Resources);
}
async function addTrigger(context, resourceName, triggerFunction, adminTriggerFunction, options) {
    let functionName;
    const triggerTypeQuestion = {
        type: 'list',
        name: 'triggerType',
        message: 'Select from the following options',
        choices: ['Choose an existing function from the project', 'Create a new function'],
    };
    const triggerTypeAnswer = await inquirer_1.default.prompt([triggerTypeQuestion]);
    if (triggerTypeAnswer.triggerType === 'Choose an existing function from the project') {
        let lambdaResources = await getLambdaFunctions(context);
        if (triggerFunction) {
            lambdaResources = lambdaResources.filter((lambdaResource) => lambdaResource !== triggerFunction);
        }
        if (lambdaResources.length === 0) {
            throw new Error("No functions were found in the project. Use 'amplify add function' to add a new function.");
        }
        const triggerOptionQuestion = {
            type: 'list',
            name: 'triggerOption',
            message: 'Select from the following options',
            choices: lambdaResources,
        };
        const triggerOptionAnswer = await inquirer_1.default.prompt([triggerOptionQuestion]);
        functionName = triggerOptionAnswer.triggerOption;
        const projectBackendDirPath = amplify_cli_core_1.pathManager.getBackendDirPath();
        const functionCFNFilePath = path.join(projectBackendDirPath, 'function', functionName, `${functionName}-cloudformation-template.json`);
        if (fs.existsSync(functionCFNFilePath)) {
            const { cfnTemplate: functionCFNFile } = await amplify_cli_core_1.readCFNTemplate(functionCFNFilePath);
            functionCFNFile.Outputs.LambdaExecutionRole = {
                Value: {
                    Ref: 'LambdaExecutionRole',
                },
            };
            await amplify_cli_core_1.writeCFNTemplate(functionCFNFile, functionCFNFilePath);
            amplify_prompts_1.printer.success(`Successfully updated resource ${functionName} locally`);
        }
    }
    else {
        const targetDir = amplify_cli_core_1.pathManager.getBackendDirPath();
        const [shortId] = uuid_1.default().split('-');
        functionName = `S3Trigger${shortId}`;
        const pluginDir = __dirname;
        const defaults = {
            functionName: `${functionName}`,
            roleName: `${functionName}LambdaRole${shortId}`,
        };
        const copyJobs = [
            {
                dir: pluginDir,
                template: path.join('..', '..', '..', '..', 'resources', 'triggers', 's3', 'lambda-cloudformation-template.json.ejs'),
                target: path.join(targetDir, 'function', functionName, `${functionName}-cloudformation-template.json`),
            },
            {
                dir: pluginDir,
                template: path.join('..', '..', '..', '..', 'resources', 'triggers', 's3', 'event.json'),
                target: path.join(targetDir, 'function', functionName, 'src', 'event.json'),
            },
            {
                dir: pluginDir,
                template: path.join('..', '..', '..', '..', 'resources', 'triggers', 's3', 'index.js'),
                target: path.join(targetDir, 'function', functionName, 'src', 'index.js'),
            },
            {
                dir: pluginDir,
                template: path.join('..', '..', '..', '..', 'resources', 'triggers', 's3', 'package.json.ejs'),
                target: path.join(targetDir, 'function', functionName, 'src', 'package.json'),
            },
        ];
        await context.amplify.copyBatch(context, copyJobs, defaults);
        const backendConfigs = {
            service: constants_1.FunctionServiceNameLambdaFunction,
            providerPlugin: 'awscloudformation',
            build: true,
        };
        await context.amplify.updateamplifyMetaAfterResourceAdd('function', functionName, backendConfigs);
        amplify_prompts_1.printer.success(`Successfully added resource ${functionName} locally`);
        if (await context.amplify.confirmPrompt(`Do you want to edit the local ${functionName} lambda function now?`)) {
            await context.amplify.openEditor(context, `${targetDir}/function/${functionName}/src/index.js`);
        }
    }
    if (resourceName) {
        const projectBackendDirPath = amplify_cli_core_1.pathManager.getBackendDirPath();
        const storageCFNFilePath = path.join(projectBackendDirPath, constants_1.categoryName, resourceName, 's3-cloudformation-template.json');
        const { cfnTemplate: storageCFNFile } = await amplify_cli_core_1.readCFNTemplate(storageCFNFilePath);
        const amplifyMetaFile = amplify_cli_core_1.stateManager.getMeta();
        if (triggerFunction) {
            delete storageCFNFile.Parameters[`function${triggerFunction}Arn`];
            delete storageCFNFile.Parameters[`function${triggerFunction}Name`];
            delete storageCFNFile.Parameters[`function${triggerFunction}LambdaExecutionRole`];
        }
        storageCFNFile.Parameters[`function${functionName}Arn`] = {
            Type: 'String',
            Default: `function${functionName}Arn`,
        };
        storageCFNFile.Parameters[`function${functionName}Name`] = {
            Type: 'String',
            Default: `function${functionName}Name`,
        };
        storageCFNFile.Parameters[`function${functionName}LambdaExecutionRole`] = {
            Type: 'String',
            Default: `function${functionName}LambdaExecutionRole`,
        };
        storageCFNFile.Parameters.triggerFunction = {
            Type: 'String',
        };
        if (adminTriggerFunction && !triggerFunction) {
            storageCFNFile.Resources.S3Bucket.DependsOn.push('TriggerPermissions');
            storageCFNFile.Resources.S3TriggerBucketPolicy.Properties.Roles.push({
                Ref: `function${functionName}LambdaExecutionRole`,
            });
            let lambdaConf = storageCFNFile.Resources.S3Bucket.Properties.NotificationConfiguration.LambdaConfigurations;
            lambdaConf = lambdaConf.concat(getTriggersForLambdaConfiguration('private', functionName), getTriggersForLambdaConfiguration('protected', functionName), getTriggersForLambdaConfiguration('public', functionName));
            storageCFNFile.Resources.S3Bucket.Properties.NotificationConfiguration.LambdaConfigurations = lambdaConf;
            const dependsOnResources = amplifyMetaFile.storage[resourceName].dependsOn;
            dependsOnResources.push({
                category: 'function',
                resourceName: functionName,
                attributes: ['Name', 'Arn', 'LambdaExecutionRole'],
            });
            context.amplify.updateamplifyMetaAfterResourceUpdate(constants_1.categoryName, resourceName, 'dependsOn', dependsOnResources);
        }
        else if (adminTriggerFunction && triggerFunction !== 'NONE') {
            storageCFNFile.Resources.S3TriggerBucketPolicy.Properties.Roles.forEach((role) => {
                if (role.Ref.includes(triggerFunction)) {
                    role.Ref = `function${functionName}LambdaExecutionRole`;
                }
            });
            storageCFNFile.Resources.TriggerPermissions.Properties.FunctionName.Ref = `function${functionName}Name`;
            storageCFNFile.Resources.S3Bucket.Properties.NotificationConfiguration.LambdaConfigurations.forEach((lambdaConf) => {
                if (!(typeof lambdaConf.Filter.S3Key.Rules[0].Value === 'string' && lambdaConf.Filter.S3Key.Rules[0].Value.includes('index-faces'))) {
                    lambdaConf.Function.Ref = `function${functionName}Arn`;
                }
            });
            const dependsOnResources = amplifyMetaFile.storage[resourceName].dependsOn;
            dependsOnResources.forEach((resource) => {
                if (resource.resourceName === triggerFunction) {
                    resource.resourceName = functionName;
                }
            });
            context.amplify.updateamplifyMetaAfterResourceUpdate(constants_1.categoryName, resourceName, 'dependsOn', dependsOnResources);
        }
        else {
            storageCFNFile.Resources.S3Bucket.Properties.NotificationConfiguration = {
                LambdaConfigurations: [
                    {
                        Event: 's3:ObjectCreated:*',
                        Function: {
                            Ref: `function${functionName}Arn`,
                        },
                    },
                    {
                        Event: 's3:ObjectRemoved:*',
                        Function: {
                            Ref: `function${functionName}Arn`,
                        },
                    },
                ],
            };
            storageCFNFile.Resources.S3Bucket.DependsOn = ['TriggerPermissions'];
            storageCFNFile.Resources.S3TriggerBucketPolicy = {
                Type: 'AWS::IAM::Policy',
                DependsOn: ['S3Bucket'],
                Properties: {
                    PolicyName: 's3-trigger-lambda-execution-policy',
                    Roles: [
                        {
                            Ref: `function${functionName}LambdaExecutionRole`,
                        },
                    ],
                    PolicyDocument: {
                        Version: '2012-10-17',
                        Statement: [
                            {
                                Effect: 'Allow',
                                Action: ['s3:PutObject', 's3:GetObject', 's3:DeleteObject'],
                                Resource: [
                                    {
                                        'Fn::Join': [
                                            '',
                                            [
                                                'arn:aws:s3:::',
                                                {
                                                    Ref: 'S3Bucket',
                                                },
                                                '/*',
                                            ],
                                        ],
                                    },
                                ],
                            },
                            {
                                Effect: 'Allow',
                                Action: 's3:ListBucket',
                                Resource: [
                                    {
                                        'Fn::Join': [
                                            '',
                                            [
                                                'arn:aws:s3:::',
                                                {
                                                    Ref: 'S3Bucket',
                                                },
                                            ],
                                        ],
                                    },
                                ],
                            },
                        ],
                    },
                },
            };
            const dependsOnResources = amplifyMetaFile.storage[resourceName].dependsOn || [];
            dependsOnResources.filter((resource) => {
                return resource.resourceName !== triggerFunction;
            });
            dependsOnResources.push({
                category: 'function',
                resourceName: functionName,
                attributes: ['Name', 'Arn', 'LambdaExecutionRole'],
            });
            context.amplify.updateamplifyMetaAfterResourceUpdate(constants_1.categoryName, resourceName, 'dependsOn', dependsOnResources);
        }
        storageCFNFile.Resources.TriggerPermissions = {
            Type: 'AWS::Lambda::Permission',
            Properties: {
                Action: 'lambda:InvokeFunction',
                FunctionName: {
                    Ref: `function${functionName}Name`,
                },
                Principal: 's3.amazonaws.com',
                SourceAccount: {
                    Ref: 'AWS::AccountId',
                },
                SourceArn: {
                    'Fn::Join': [
                        '',
                        [
                            'arn:aws:s3:::',
                            {
                                'Fn::If': [
                                    'ShouldNotCreateEnvResources',
                                    {
                                        Ref: 'bucketName',
                                    },
                                    {
                                        'Fn::Join': [
                                            '',
                                            [
                                                {
                                                    Ref: 'bucketName',
                                                },
                                                {
                                                    'Fn::Select': [
                                                        3,
                                                        {
                                                            'Fn::Split': [
                                                                '-',
                                                                {
                                                                    Ref: 'AWS::StackName',
                                                                },
                                                            ],
                                                        },
                                                    ],
                                                },
                                                '-',
                                                {
                                                    Ref: 'env',
                                                },
                                            ],
                                        ],
                                    },
                                ],
                            },
                        ],
                    ],
                },
            },
        };
        await amplify_cli_core_1.writeCFNTemplate(storageCFNFile, storageCFNFilePath);
    }
    else {
        if (!options.dependsOn) {
            options.dependsOn = [];
        }
        options.dependsOn.push({
            category: 'function',
            resourceName: functionName,
            attributes: ['Name', 'Arn', 'LambdaExecutionRole'],
        });
    }
    return functionName;
}
async function getLambdaFunctions(context) {
    const { allResources } = await context.amplify.getResourceStatus();
    const lambdaResources = allResources
        .filter((resource) => resource.service === constants_1.FunctionServiceNameLambdaFunction)
        .map((resource) => resource.resourceName);
    return lambdaResources;
}
async function askReadWrite(userType, context, answers, parameters) {
    const defaults = [];
    if (parameters[`selected${userType}Permissions`]) {
        Object.values(permissionMap).forEach((el, index) => {
            if (el.every(i => parameters[`selected${userType}Permissions`].includes(i))) {
                defaults.push(Object.keys(permissionMap)[index]);
            }
        });
    }
    const selectedPermissions = await context.amplify.crudFlow(userType, permissionMap, defaults);
    createPermissionKeys(userType, answers, selectedPermissions);
    return selectedPermissions;
}
function createPermissionKeys(userType, answers, selectedPermissions) {
    const [policyId] = uuid_1.default().split('-');
    const maxPermissions = ['s3:GetObject', 's3:PutObject', 's3:DeleteObject'];
    const maxPublic = maxPermissions;
    const maxUploads = ['s3:PutObject'];
    const maxPrivate = userType === 'Authenticated' ? maxPermissions : [];
    const maxProtected = userType === 'Authenticated' ? maxPermissions : ['s3:GetObject'];
    function addPermissionKeys(key, possiblePermissions) {
        const permissions = lodash_1.default.intersection(selectedPermissions, possiblePermissions).join();
        answers[`s3Permissions${userType}${key}`] = !permissions ? 'DISALLOW' : permissions;
        answers[`s3${key}Policy`] = `${key}_policy_${policyId}`;
    }
    addPermissionKeys('Public', maxPublic);
    addPermissionKeys('Uploads', maxUploads);
    if (userType !== 'Guest') {
        addPermissionKeys('Protected', maxProtected);
        addPermissionKeys('Private', maxPrivate);
    }
    answers[`${userType}AllowList`] = selectedPermissions.includes('s3:GetObject') ? 'ALLOW' : 'DISALLOW';
    answers.s3ReadPolicy = `read_policy_${policyId}`;
    if (answers.storageAccess !== 'authAndGuest') {
        answers.s3PermissionsGuestPublic = 'DISALLOW';
        answers.s3PermissionsGuestUploads = 'DISALLOW';
        answers.GuestAllowList = 'DISALLOW';
    }
}
function removeAuthUnauthAccess(answers) {
    answers.s3PermissionsGuestPublic = 'DISALLOW';
    answers.s3PermissionsGuestUploads = 'DISALLOW';
    answers.GuestAllowList = 'DISALLOW';
    answers.s3PermissionsAuthenticatedPublic = 'DISALLOW';
    answers.s3PermissionsAuthenticatedProtected = 'DISALLOW';
    answers.s3PermissionsAuthenticatedPrivate = 'DISALLOW';
    answers.s3PermissionsAuthenticatedUploads = 'DISALLOW';
    answers.AuthenticatedAllowList = 'DISALLOW';
}
const resourceAlreadyExists = () => {
    const amplifyMeta = amplify_cli_core_1.stateManager.getMeta();
    let resourceName;
    if (amplifyMeta[constants_1.categoryName]) {
        const categoryResources = amplifyMeta[constants_1.categoryName];
        Object.keys(categoryResources).forEach(resource => {
            if (categoryResources[resource].service === constants_1.ServiceName.S3) {
                resourceName = resource;
            }
        });
    }
    return resourceName;
};
exports.resourceAlreadyExists = resourceAlreadyExists;
const checkIfAuthExists = () => {
    const amplifyMeta = amplify_cli_core_1.stateManager.getMeta();
    let authExists = false;
    const authServiceName = 'Cognito';
    const authCategory = 'auth';
    if (amplifyMeta[authCategory] && Object.keys(amplifyMeta[authCategory]).length > 0) {
        const categoryResources = amplifyMeta[authCategory];
        Object.keys(categoryResources).forEach(resource => {
            if (categoryResources[resource].service === authServiceName) {
                authExists = true;
            }
        });
    }
    return authExists;
};
exports.checkIfAuthExists = checkIfAuthExists;
const migrate = async (context, projectPath, resourceName) => {
    const resourceDirPath = amplify_cli_core_1.pathManager.getResourceDirectoryPath(projectPath, constants_1.categoryName, resourceName);
    const cfnFilePath = path.join(resourceDirPath, 's3-cloudformation-template.json');
    const { cfnTemplate } = await amplify_cli_core_1.readCFNTemplate(cfnFilePath);
    if (!cfnTemplate.Parameters) {
        cfnTemplate.Parameters = {};
    }
    cfnTemplate.Parameters.env = {
        Type: 'String',
    };
    if (!cfnTemplate.Conditions) {
        cfnTemplate.Conditions = {};
    }
    cfnTemplate.Conditions.ShouldNotCreateEnvResources = {
        'Fn::Equals': [
            {
                Ref: 'env',
            },
            'NONE',
        ],
    };
    cfnTemplate.Resources.S3Bucket.Properties.BucketName = {
        'Fn::If': [
            'ShouldNotCreateEnvResources',
            {
                Ref: 'bucketName',
            },
            {
                'Fn::Join': [
                    '',
                    [
                        {
                            Ref: 'bucketName',
                        },
                        {
                            'Fn::Select': [
                                3,
                                {
                                    'Fn::Split': [
                                        '-',
                                        {
                                            Ref: 'AWS::StackName',
                                        },
                                    ],
                                },
                            ],
                        },
                        '-',
                        {
                            Ref: 'env',
                        },
                    ],
                ],
            },
        ],
    };
    await amplify_cli_core_1.writeCFNTemplate(cfnTemplate, cfnFilePath);
    const parameters = amplify_cli_core_1.stateManager.getResourceParametersJson(undefined, constants_1.categoryName, resourceName);
    parameters.authRoleName = {
        Ref: 'AuthRoleName',
    };
    parameters.unauthRoleName = {
        Ref: 'UnauthRoleName',
    };
    amplify_cli_core_1.stateManager.setResourceParametersJson(undefined, constants_1.categoryName, resourceName, parameters);
};
exports.migrate = migrate;
function convertToCRUD(parameters, answers) {
    if (parameters.unauthPermissions === 'r') {
        answers.selectedGuestPermissions = ['s3:GetObject', 's3:ListBucket'];
        createPermissionKeys('Guest', answers, answers.selectedGuestPermissions);
    }
    if (parameters.unauthPermissions === 'rw') {
        answers.selectedGuestPermissions = ['s3:GetObject', 's3:ListBucket', 's3:PutObject', 's3:DeleteObject'];
        createPermissionKeys('Guest', answers, answers.selectedGuestPermissions);
    }
    if (parameters.authPermissions === 'r') {
        answers.selectedAuthenticatedPermissions = ['s3:GetObject', 's3:ListBucket'];
        createPermissionKeys('Authenticated', answers, answers.selectedAuthenticatedPermissions);
    }
    if (parameters.authPermissions === 'rw') {
        answers.selectedAuthenticatedPermissions = ['s3:GetObject', 's3:ListBucket', 's3:PutObject', 's3:DeleteObject'];
        createPermissionKeys('Authenticated', answers, answers.selectedAuthenticatedPermissions);
    }
}
const getIAMPolicies = (resourceName, crudOptions) => {
    let policy = [];
    const actionsSet = new Set();
    crudOptions.forEach(crudOption => {
        switch (crudOption) {
            case 'create':
                actionsSet.add('s3:PutObject');
                break;
            case 'update':
                actionsSet.add('s3:PutObject');
                break;
            case 'read':
                actionsSet.add('s3:GetObject');
                actionsSet.add('s3:ListBucket');
                break;
            case 'delete':
                actionsSet.add('s3:DeleteObject');
                break;
            default:
                amplify_prompts_1.printer.info(`${crudOption} not supported`);
        }
    });
    let actions = Array.from(actionsSet);
    if (actions.includes('s3:ListBucket')) {
        let listBucketPolicy = {};
        listBucketPolicy = {
            Effect: 'Allow',
            Action: 's3:ListBucket',
            Resource: [
                {
                    'Fn::Join': [
                        '',
                        [
                            'arn:aws:s3:::',
                            {
                                Ref: `${constants_1.categoryName}${resourceName}BucketName`,
                            },
                        ],
                    ],
                },
            ],
        };
        actions = actions.filter(action => action != 's3:ListBucket');
        policy.push(listBucketPolicy);
    }
    const s3ObjectPolicy = {
        Effect: 'Allow',
        Action: actions,
        Resource: [
            {
                'Fn::Join': [
                    '',
                    [
                        'arn:aws:s3:::',
                        {
                            Ref: `${constants_1.categoryName}${resourceName}BucketName`,
                        },
                        '/*',
                    ],
                ],
            },
        ],
    };
    policy.push(s3ObjectPolicy);
    const attributes = ['BucketName'];
    return { policy, attributes };
};
exports.getIAMPolicies = getIAMPolicies;
function getTriggersForLambdaConfiguration(protectionLevel, functionName) {
    const triggers = [
        {
            Event: 's3:ObjectCreated:*',
            Filter: {
                S3Key: {
                    Rules: [
                        {
                            Name: 'prefix',
                            Value: {
                                'Fn::Join': [
                                    '',
                                    [
                                        `${protectionLevel}/`,
                                        {
                                            Ref: 'AWS::Region',
                                        },
                                    ],
                                ],
                            },
                        },
                    ],
                },
            },
            Function: {
                Ref: `function${functionName}Arn`,
            },
        },
        {
            Event: 's3:ObjectRemoved:*',
            Filter: {
                S3Key: {
                    Rules: [
                        {
                            Name: 'prefix',
                            Value: {
                                'Fn::Join': [
                                    '',
                                    [
                                        `${protectionLevel}/`,
                                        {
                                            Ref: 'AWS::Region',
                                        },
                                    ],
                                ],
                            },
                        },
                    ],
                },
            },
            Function: {
                Ref: `function${functionName}Arn`,
            },
        },
    ];
    return triggers;
}
//# sourceMappingURL=s3-walkthrough.js.map