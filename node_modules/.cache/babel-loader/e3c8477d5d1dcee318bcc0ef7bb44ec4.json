{"ast":null,"code":"'use strict';\n\nvar EventEmitter = require('events').EventEmitter;\n\nvar fs = require('fs');\n\nvar sysPath = require('path');\n\nvar asyncEach = require('async-each');\n\nvar anymatch = require('anymatch');\n\nvar globParent = require('glob-parent');\n\nvar isGlob = require('is-glob');\n\nvar isAbsolute = require('path-is-absolute');\n\nvar inherits = require('inherits');\n\nvar braces = require('braces');\n\nvar normalizePath = require('normalize-path');\n\nvar upath = require('upath');\n\nvar NodeFsHandler = require('./lib/nodefs-handler');\n\nvar FsEventsHandler = require('./lib/fsevents-handler');\n\nvar arrify = function (value) {\n  if (value == null) return [];\n  return Array.isArray(value) ? value : [value];\n};\n\nvar flatten = function (list, result) {\n  if (result == null) result = [];\n  list.forEach(function (item) {\n    if (Array.isArray(item)) {\n      flatten(item, result);\n    } else {\n      result.push(item);\n    }\n  });\n  return result;\n}; // Little isString util for use in Array#every.\n\n\nvar isString = function (thing) {\n  return typeof thing === 'string';\n}; // Public: Main class.\n// Watches files & directories for changes.\n//\n// * _opts - object, chokidar options hash\n//\n// Emitted events:\n// `add`, `addDir`, `change`, `unlink`, `unlinkDir`, `all`, `error`\n//\n// Examples\n//\n//  var watcher = new FSWatcher()\n//    .add(directories)\n//    .on('add', path => console.log('File', path, 'was added'))\n//    .on('change', path => console.log('File', path, 'was changed'))\n//    .on('unlink', path => console.log('File', path, 'was removed'))\n//    .on('all', (event, path) => console.log(path, ' emitted ', event))\n//\n\n\nfunction FSWatcher(_opts) {\n  EventEmitter.call(this);\n  var opts = {}; // in case _opts that is passed in is a frozen object\n\n  if (_opts) for (var opt in _opts) opts[opt] = _opts[opt];\n  this._watched = Object.create(null);\n  this._closers = Object.create(null);\n  this._ignoredPaths = Object.create(null);\n  Object.defineProperty(this, '_globIgnored', {\n    get: function () {\n      return Object.keys(this._ignoredPaths);\n    }\n  });\n  this.closed = false;\n  this._throttled = Object.create(null);\n  this._symlinkPaths = Object.create(null);\n\n  function undef(key) {\n    return opts[key] === undefined;\n  } // Set up default options.\n\n\n  if (undef('persistent')) opts.persistent = true;\n  if (undef('ignoreInitial')) opts.ignoreInitial = false;\n  if (undef('ignorePermissionErrors')) opts.ignorePermissionErrors = false;\n  if (undef('interval')) opts.interval = 100;\n  if (undef('binaryInterval')) opts.binaryInterval = 300;\n  if (undef('disableGlobbing')) opts.disableGlobbing = false;\n  this.enableBinaryInterval = opts.binaryInterval !== opts.interval; // Enable fsevents on OS X when polling isn't explicitly enabled.\n\n  if (undef('useFsEvents')) opts.useFsEvents = !opts.usePolling; // If we can't use fsevents, ensure the options reflect it's disabled.\n\n  if (!FsEventsHandler.canUse()) opts.useFsEvents = false; // Use polling on Mac if not using fsevents.\n  // Other platforms use non-polling fs.watch.\n\n  if (undef('usePolling') && !opts.useFsEvents) {\n    opts.usePolling = process.platform === 'darwin';\n  } // Global override (useful for end-developers that need to force polling for all\n  // instances of chokidar, regardless of usage/dependency depth)\n\n\n  var envPoll = process.env.CHOKIDAR_USEPOLLING;\n\n  if (envPoll !== undefined) {\n    var envLower = envPoll.toLowerCase();\n\n    if (envLower === 'false' || envLower === '0') {\n      opts.usePolling = false;\n    } else if (envLower === 'true' || envLower === '1') {\n      opts.usePolling = true;\n    } else {\n      opts.usePolling = !!envLower;\n    }\n  }\n\n  var envInterval = process.env.CHOKIDAR_INTERVAL;\n\n  if (envInterval) {\n    opts.interval = parseInt(envInterval);\n  } // Editor atomic write normalization enabled by default with fs.watch\n\n\n  if (undef('atomic')) opts.atomic = !opts.usePolling && !opts.useFsEvents;\n  if (opts.atomic) this._pendingUnlinks = Object.create(null);\n  if (undef('followSymlinks')) opts.followSymlinks = true;\n  if (undef('awaitWriteFinish')) opts.awaitWriteFinish = false;\n  if (opts.awaitWriteFinish === true) opts.awaitWriteFinish = {};\n  var awf = opts.awaitWriteFinish;\n\n  if (awf) {\n    if (!awf.stabilityThreshold) awf.stabilityThreshold = 2000;\n    if (!awf.pollInterval) awf.pollInterval = 100;\n    this._pendingWrites = Object.create(null);\n  }\n\n  if (opts.ignored) opts.ignored = arrify(opts.ignored);\n\n  this._isntIgnored = function (path, stat) {\n    return !this._isIgnored(path, stat);\n  }.bind(this);\n\n  var readyCalls = 0;\n\n  this._emitReady = function () {\n    if (++readyCalls >= this._readyCount) {\n      this._emitReady = Function.prototype;\n      this._readyEmitted = true; // use process.nextTick to allow time for listener to be bound\n\n      process.nextTick(this.emit.bind(this, 'ready'));\n    }\n  }.bind(this);\n\n  this.options = opts; // You’re frozen when your heart’s not open.\n\n  Object.freeze(opts);\n}\n\ninherits(FSWatcher, EventEmitter); // Common helpers\n// --------------\n// Private method: Normalize and emit events\n//\n// * event     - string, type of event\n// * path      - string, file or directory path\n// * val[1..3] - arguments to be passed with event\n//\n// Returns the error if defined, otherwise the value of the\n// FSWatcher instance's `closed` flag\n\nFSWatcher.prototype._emit = function (event, path, val1, val2, val3) {\n  if (this.options.cwd) path = sysPath.relative(this.options.cwd, path);\n  var args = [event, path];\n  if (val3 !== undefined) args.push(val1, val2, val3);else if (val2 !== undefined) args.push(val1, val2);else if (val1 !== undefined) args.push(val1);\n  var awf = this.options.awaitWriteFinish;\n\n  if (awf && this._pendingWrites[path]) {\n    this._pendingWrites[path].lastChange = new Date();\n    return this;\n  }\n\n  if (this.options.atomic) {\n    if (event === 'unlink') {\n      this._pendingUnlinks[path] = args;\n      setTimeout(function () {\n        Object.keys(this._pendingUnlinks).forEach(function (path) {\n          this.emit.apply(this, this._pendingUnlinks[path]);\n          this.emit.apply(this, ['all'].concat(this._pendingUnlinks[path]));\n          delete this._pendingUnlinks[path];\n        }.bind(this));\n      }.bind(this), typeof this.options.atomic === \"number\" ? this.options.atomic : 100);\n      return this;\n    } else if (event === 'add' && this._pendingUnlinks[path]) {\n      event = args[0] = 'change';\n      delete this._pendingUnlinks[path];\n    }\n  }\n\n  var emitEvent = function () {\n    this.emit.apply(this, args);\n    if (event !== 'error') this.emit.apply(this, ['all'].concat(args));\n  }.bind(this);\n\n  if (awf && (event === 'add' || event === 'change') && this._readyEmitted) {\n    var awfEmit = function (err, stats) {\n      if (err) {\n        event = args[0] = 'error';\n        args[1] = err;\n        emitEvent();\n      } else if (stats) {\n        // if stats doesn't exist the file must have been deleted\n        if (args.length > 2) {\n          args[2] = stats;\n        } else {\n          args.push(stats);\n        }\n\n        emitEvent();\n      }\n    };\n\n    this._awaitWriteFinish(path, awf.stabilityThreshold, event, awfEmit);\n\n    return this;\n  }\n\n  if (event === 'change') {\n    if (!this._throttle('change', path, 50)) return this;\n  }\n\n  if (this.options.alwaysStat && val1 === undefined && (event === 'add' || event === 'addDir' || event === 'change')) {\n    var fullPath = this.options.cwd ? sysPath.join(this.options.cwd, path) : path;\n    fs.stat(fullPath, function (error, stats) {\n      // Suppress event when fs.stat fails, to avoid sending undefined 'stat'\n      if (error || !stats) return;\n      args.push(stats);\n      emitEvent();\n    });\n  } else {\n    emitEvent();\n  }\n\n  return this;\n}; // Private method: Common handler for errors\n//\n// * error  - object, Error instance\n//\n// Returns the error if defined, otherwise the value of the\n// FSWatcher instance's `closed` flag\n\n\nFSWatcher.prototype._handleError = function (error) {\n  var code = error && error.code;\n  var ipe = this.options.ignorePermissionErrors;\n  if (error && code !== 'ENOENT' && code !== 'ENOTDIR' && (!ipe || code !== 'EPERM' && code !== 'EACCES')) this.emit('error', error);\n  return error || this.closed;\n}; // Private method: Helper utility for throttling\n//\n// * action  - string, type of action being throttled\n// * path    - string, path being acted upon\n// * timeout - int, duration of time to suppress duplicate actions\n//\n// Returns throttle tracking object or false if action should be suppressed\n\n\nFSWatcher.prototype._throttle = function (action, path, timeout) {\n  if (!(action in this._throttled)) {\n    this._throttled[action] = Object.create(null);\n  }\n\n  var throttled = this._throttled[action];\n\n  if (path in throttled) {\n    throttled[path].count++;\n    return false;\n  }\n\n  function clear() {\n    var count = throttled[path] ? throttled[path].count : 0;\n    delete throttled[path];\n    clearTimeout(timeoutObject);\n    return count;\n  }\n\n  var timeoutObject = setTimeout(clear, timeout);\n  throttled[path] = {\n    timeoutObject: timeoutObject,\n    clear: clear,\n    count: 0\n  };\n  return throttled[path];\n}; // Private method: Awaits write operation to finish\n//\n// * path    - string, path being acted upon\n// * threshold - int, time in milliseconds a file size must be fixed before\n//                    acknowledging write operation is finished\n// * awfEmit - function, to be called when ready for event to be emitted\n// Polls a newly created file for size variations. When files size does not\n// change for 'threshold' milliseconds calls callback.\n\n\nFSWatcher.prototype._awaitWriteFinish = function (path, threshold, event, awfEmit) {\n  var timeoutHandler;\n  var fullPath = path;\n\n  if (this.options.cwd && !isAbsolute(path)) {\n    fullPath = sysPath.join(this.options.cwd, path);\n  }\n\n  var now = new Date();\n\n  var awaitWriteFinish = function (prevStat) {\n    fs.stat(fullPath, function (err, curStat) {\n      if (err || !(path in this._pendingWrites)) {\n        if (err && err.code !== 'ENOENT') awfEmit(err);\n        return;\n      }\n\n      var now = new Date();\n\n      if (prevStat && curStat.size != prevStat.size) {\n        this._pendingWrites[path].lastChange = now;\n      }\n\n      if (now - this._pendingWrites[path].lastChange >= threshold) {\n        delete this._pendingWrites[path];\n        awfEmit(null, curStat);\n      } else {\n        timeoutHandler = setTimeout(awaitWriteFinish.bind(this, curStat), this.options.awaitWriteFinish.pollInterval);\n      }\n    }.bind(this));\n  }.bind(this);\n\n  if (!(path in this._pendingWrites)) {\n    this._pendingWrites[path] = {\n      lastChange: now,\n      cancelWait: function () {\n        delete this._pendingWrites[path];\n        clearTimeout(timeoutHandler);\n        return event;\n      }.bind(this)\n    };\n    timeoutHandler = setTimeout(awaitWriteFinish.bind(this), this.options.awaitWriteFinish.pollInterval);\n  }\n}; // Private method: Determines whether user has asked to ignore this path\n//\n// * path  - string, path to file or directory\n// * stats - object, result of fs.stat\n//\n// Returns boolean\n\n\nvar dotRe = /\\..*\\.(sw[px])$|\\~$|\\.subl.*\\.tmp/;\n\nFSWatcher.prototype._isIgnored = function (path, stats) {\n  if (this.options.atomic && dotRe.test(path)) return true;\n\n  if (!this._userIgnored) {\n    var cwd = this.options.cwd;\n    var ignored = this.options.ignored;\n\n    if (cwd && ignored) {\n      ignored = ignored.map(function (path) {\n        if (typeof path !== 'string') return path;\n        return upath.normalize(isAbsolute(path) ? path : sysPath.join(cwd, path));\n      });\n    }\n\n    var paths = arrify(ignored).filter(function (path) {\n      return typeof path === 'string' && !isGlob(path);\n    }).map(function (path) {\n      return path + '/**';\n    });\n    this._userIgnored = anymatch(this._globIgnored.concat(ignored).concat(paths));\n  }\n\n  return this._userIgnored([path, stats]);\n}; // Private method: Provides a set of common helpers and properties relating to\n// symlink and glob handling\n//\n// * path - string, file, directory, or glob pattern being watched\n// * depth - int, at any depth > 0, this isn't a glob\n//\n// Returns object containing helpers for this path\n\n\nvar replacerRe = /^\\.[\\/\\\\]/;\n\nFSWatcher.prototype._getWatchHelpers = function (path, depth) {\n  path = path.replace(replacerRe, '');\n  var watchPath = depth || this.options.disableGlobbing || !isGlob(path) ? path : globParent(path);\n  var fullWatchPath = sysPath.resolve(watchPath);\n  var hasGlob = watchPath !== path;\n  var globFilter = hasGlob ? anymatch(path) : false;\n  var follow = this.options.followSymlinks;\n  var globSymlink = hasGlob && follow ? null : false;\n\n  var checkGlobSymlink = function (entry) {\n    // only need to resolve once\n    // first entry should always have entry.parentDir === ''\n    if (globSymlink == null) {\n      globSymlink = entry.fullParentDir === fullWatchPath ? false : {\n        realPath: entry.fullParentDir,\n        linkPath: fullWatchPath\n      };\n    }\n\n    if (globSymlink) {\n      return entry.fullPath.replace(globSymlink.realPath, globSymlink.linkPath);\n    }\n\n    return entry.fullPath;\n  };\n\n  var entryPath = function (entry) {\n    return sysPath.join(watchPath, sysPath.relative(watchPath, checkGlobSymlink(entry)));\n  };\n\n  var filterPath = function (entry) {\n    if (entry.stat && entry.stat.isSymbolicLink()) return filterDir(entry);\n    var resolvedPath = entryPath(entry);\n    return (!hasGlob || globFilter(resolvedPath)) && this._isntIgnored(resolvedPath, entry.stat) && (this.options.ignorePermissionErrors || this._hasReadPermissions(entry.stat));\n  }.bind(this);\n\n  var getDirParts = function (path) {\n    if (!hasGlob) return false;\n    var parts = [];\n    var expandedPath = braces.expand(path);\n    expandedPath.forEach(function (path) {\n      parts.push(sysPath.relative(watchPath, path).split(/[\\/\\\\]/));\n    });\n    return parts;\n  };\n\n  var dirParts = getDirParts(path);\n\n  if (dirParts) {\n    dirParts.forEach(function (parts) {\n      if (parts.length > 1) parts.pop();\n    });\n  }\n\n  var unmatchedGlob;\n\n  var filterDir = function (entry) {\n    if (hasGlob) {\n      var entryParts = getDirParts(checkGlobSymlink(entry));\n      var globstar = false;\n      unmatchedGlob = !dirParts.some(function (parts) {\n        return parts.every(function (part, i) {\n          if (part === '**') globstar = true;\n          return globstar || !entryParts[0][i] || anymatch(part, entryParts[0][i]);\n        });\n      });\n    }\n\n    return !unmatchedGlob && this._isntIgnored(entryPath(entry), entry.stat);\n  }.bind(this);\n\n  return {\n    followSymlinks: follow,\n    statMethod: follow ? 'stat' : 'lstat',\n    path: path,\n    watchPath: watchPath,\n    entryPath: entryPath,\n    hasGlob: hasGlob,\n    globFilter: globFilter,\n    filterPath: filterPath,\n    filterDir: filterDir\n  };\n}; // Directory helpers\n// -----------------\n// Private method: Provides directory tracking objects\n//\n// * directory - string, path of the directory\n//\n// Returns the directory's tracking object\n\n\nFSWatcher.prototype._getWatchedDir = function (directory) {\n  var dir = sysPath.resolve(directory);\n\n  var watcherRemove = this._remove.bind(this);\n\n  if (!(dir in this._watched)) this._watched[dir] = {\n    _items: Object.create(null),\n    add: function (item) {\n      if (item !== '.' && item !== '..') this._items[item] = true;\n    },\n    remove: function (item) {\n      delete this._items[item];\n\n      if (!this.children().length) {\n        fs.readdir(dir, function (err) {\n          if (err) watcherRemove(sysPath.dirname(dir), sysPath.basename(dir));\n        });\n      }\n    },\n    has: function (item) {\n      return item in this._items;\n    },\n    children: function () {\n      return Object.keys(this._items);\n    }\n  };\n  return this._watched[dir];\n}; // File helpers\n// ------------\n// Private method: Check for read permissions\n// Based on this answer on SO: http://stackoverflow.com/a/11781404/1358405\n//\n// * stats - object, result of fs.stat\n//\n// Returns boolean\n\n\nFSWatcher.prototype._hasReadPermissions = function (stats) {\n  return Boolean(4 & parseInt(((stats && stats.mode) & 0x1ff).toString(8)[0], 10));\n}; // Private method: Handles emitting unlink events for\n// files and directories, and via recursion, for\n// files and directories within directories that are unlinked\n//\n// * directory - string, directory within which the following item is located\n// * item      - string, base path of item/directory\n//\n// Returns nothing\n\n\nFSWatcher.prototype._remove = function (directory, item) {\n  // if what is being deleted is a directory, get that directory's paths\n  // for recursive deleting and cleaning of watched object\n  // if it is not a directory, nestedDirectoryChildren will be empty array\n  var path = sysPath.join(directory, item);\n  var fullPath = sysPath.resolve(path);\n  var isDirectory = this._watched[path] || this._watched[fullPath]; // prevent duplicate handling in case of arriving here nearly simultaneously\n  // via multiple paths (such as _handleFile and _handleDir)\n\n  if (!this._throttle('remove', path, 100)) return; // if the only watched file is removed, watch for its return\n\n  var watchedDirs = Object.keys(this._watched);\n\n  if (!isDirectory && !this.options.useFsEvents && watchedDirs.length === 1) {\n    this.add(directory, item, true);\n  } // This will create a new entry in the watched object in either case\n  // so we got to do the directory check beforehand\n\n\n  var nestedDirectoryChildren = this._getWatchedDir(path).children(); // Recursively remove children directories / files.\n\n\n  nestedDirectoryChildren.forEach(function (nestedItem) {\n    this._remove(path, nestedItem);\n  }, this); // Check if item was on the watched list and remove it\n\n  var parent = this._getWatchedDir(directory);\n\n  var wasTracked = parent.has(item);\n  parent.remove(item); // If we wait for this file to be fully written, cancel the wait.\n\n  var relPath = path;\n  if (this.options.cwd) relPath = sysPath.relative(this.options.cwd, path);\n\n  if (this.options.awaitWriteFinish && this._pendingWrites[relPath]) {\n    var event = this._pendingWrites[relPath].cancelWait();\n\n    if (event === 'add') return;\n  } // The Entry will either be a directory that just got removed\n  // or a bogus entry to a file, in either case we have to remove it\n\n\n  delete this._watched[path];\n  delete this._watched[fullPath];\n  var eventName = isDirectory ? 'unlinkDir' : 'unlink';\n  if (wasTracked && !this._isIgnored(path)) this._emit(eventName, path); // Avoid conflicts if we later create another file with the same name\n\n  if (!this.options.useFsEvents) {\n    this._closePath(path);\n  }\n};\n\nFSWatcher.prototype._closePath = function (path) {\n  if (!this._closers[path]) return;\n\n  this._closers[path].forEach(function (closer) {\n    closer();\n  });\n\n  delete this._closers[path];\n\n  this._getWatchedDir(sysPath.dirname(path)).remove(sysPath.basename(path));\n}; // Public method: Adds paths to be watched on an existing FSWatcher instance\n// * paths     - string or array of strings, file/directory paths and/or globs\n// * _origAdd  - private boolean, for handling non-existent paths to be watched\n// * _internal - private boolean, indicates a non-user add\n// Returns an instance of FSWatcher for chaining.\n\n\nFSWatcher.prototype.add = function (paths, _origAdd, _internal) {\n  var disableGlobbing = this.options.disableGlobbing;\n  var cwd = this.options.cwd;\n  this.closed = false;\n  paths = flatten(arrify(paths));\n\n  if (!paths.every(isString)) {\n    throw new TypeError('Non-string provided as watch path: ' + paths);\n  }\n\n  if (cwd) paths = paths.map(function (path) {\n    var absPath;\n\n    if (isAbsolute(path)) {\n      absPath = path;\n    } else if (path[0] === '!') {\n      absPath = '!' + sysPath.join(cwd, path.substring(1));\n    } else {\n      absPath = sysPath.join(cwd, path);\n    } // Check `path` instead of `absPath` because the cwd portion can't be a glob\n\n\n    if (disableGlobbing || !isGlob(path)) {\n      return absPath;\n    } else {\n      return normalizePath(absPath);\n    }\n  }); // set aside negated glob strings\n\n  paths = paths.filter(function (path) {\n    if (path[0] === '!') {\n      this._ignoredPaths[path.substring(1)] = true;\n    } else {\n      // if a path is being added that was previously ignored, stop ignoring it\n      delete this._ignoredPaths[path];\n      delete this._ignoredPaths[path + '/**']; // reset the cached userIgnored anymatch fn\n      // to make ignoredPaths changes effective\n\n      this._userIgnored = null;\n      return true;\n    }\n  }, this);\n\n  if (this.options.useFsEvents && FsEventsHandler.canUse()) {\n    if (!this._readyCount) this._readyCount = paths.length;\n    if (this.options.persistent) this._readyCount *= 2;\n    paths.forEach(this._addToFsEvents, this);\n  } else {\n    if (!this._readyCount) this._readyCount = 0;\n    this._readyCount += paths.length;\n    asyncEach(paths, function (path, next) {\n      this._addToNodeFs(path, !_internal, 0, 0, _origAdd, function (err, res) {\n        if (res) this._emitReady();\n        next(err, res);\n      }.bind(this));\n    }.bind(this), function (error, results) {\n      results.forEach(function (item) {\n        if (!item || this.closed) return;\n        this.add(sysPath.dirname(item), sysPath.basename(_origAdd || item));\n      }, this);\n    }.bind(this));\n  }\n\n  return this;\n}; // Public method: Close watchers or start ignoring events from specified paths.\n// * paths     - string or array of strings, file/directory paths and/or globs\n// Returns instance of FSWatcher for chaining.\n\n\nFSWatcher.prototype.unwatch = function (paths) {\n  if (this.closed) return this;\n  paths = flatten(arrify(paths));\n  paths.forEach(function (path) {\n    // convert to absolute path unless relative path already matches\n    if (!isAbsolute(path) && !this._closers[path]) {\n      if (this.options.cwd) path = sysPath.join(this.options.cwd, path);\n      path = sysPath.resolve(path);\n    }\n\n    this._closePath(path);\n\n    this._ignoredPaths[path] = true;\n\n    if (path in this._watched) {\n      this._ignoredPaths[path + '/**'] = true;\n    } // reset the cached userIgnored anymatch fn\n    // to make ignoredPaths changes effective\n\n\n    this._userIgnored = null;\n  }, this);\n  return this;\n}; // Public method: Close watchers and remove all listeners from watched paths.\n// Returns instance of FSWatcher for chaining.\n\n\nFSWatcher.prototype.close = function () {\n  if (this.closed) return this;\n  this.closed = true;\n  Object.keys(this._closers).forEach(function (watchPath) {\n    this._closers[watchPath].forEach(function (closer) {\n      closer();\n    });\n\n    delete this._closers[watchPath];\n  }, this);\n  this._watched = Object.create(null);\n  this.removeAllListeners();\n  return this;\n}; // Public method: Expose list of watched paths\n// Returns object w/ dir paths as keys and arrays of contained paths as values.\n\n\nFSWatcher.prototype.getWatched = function () {\n  var watchList = {};\n  Object.keys(this._watched).forEach(function (dir) {\n    var key = this.options.cwd ? sysPath.relative(this.options.cwd, dir) : dir;\n    watchList[key || '.'] = Object.keys(this._watched[dir]._items).sort();\n  }.bind(this));\n  return watchList;\n}; // Attach watch handler prototype methods\n\n\nfunction importHandler(handler) {\n  Object.keys(handler.prototype).forEach(function (method) {\n    FSWatcher.prototype[method] = handler.prototype[method];\n  });\n}\n\nimportHandler(NodeFsHandler);\nif (FsEventsHandler.canUse()) importHandler(FsEventsHandler); // Export FSWatcher class\n\nexports.FSWatcher = FSWatcher; // Public function: Instantiates watcher with paths to be tracked.\n// * paths     - string or array of strings, file/directory paths and/or globs\n// * options   - object, chokidar options\n// Returns an instance of FSWatcher for chaining.\n\nexports.watch = function (paths, options) {\n  return new FSWatcher(options).add(paths);\n};","map":{"version":3,"sources":["C:/frontend/node_modules/chokidar/index.js"],"names":["EventEmitter","require","fs","sysPath","asyncEach","anymatch","globParent","isGlob","isAbsolute","inherits","braces","normalizePath","upath","NodeFsHandler","FsEventsHandler","arrify","value","Array","isArray","flatten","list","result","forEach","item","push","isString","thing","FSWatcher","_opts","call","opts","opt","_watched","Object","create","_closers","_ignoredPaths","defineProperty","get","keys","closed","_throttled","_symlinkPaths","undef","key","undefined","persistent","ignoreInitial","ignorePermissionErrors","interval","binaryInterval","disableGlobbing","enableBinaryInterval","useFsEvents","usePolling","canUse","process","platform","envPoll","env","CHOKIDAR_USEPOLLING","envLower","toLowerCase","envInterval","CHOKIDAR_INTERVAL","parseInt","atomic","_pendingUnlinks","followSymlinks","awaitWriteFinish","awf","stabilityThreshold","pollInterval","_pendingWrites","ignored","_isntIgnored","path","stat","_isIgnored","bind","readyCalls","_emitReady","_readyCount","Function","prototype","_readyEmitted","nextTick","emit","options","freeze","_emit","event","val1","val2","val3","cwd","relative","args","lastChange","Date","setTimeout","apply","concat","emitEvent","awfEmit","err","stats","length","_awaitWriteFinish","_throttle","alwaysStat","fullPath","join","error","_handleError","code","ipe","action","timeout","throttled","count","clear","clearTimeout","timeoutObject","threshold","timeoutHandler","now","prevStat","curStat","size","cancelWait","dotRe","test","_userIgnored","map","normalize","paths","filter","_globIgnored","replacerRe","_getWatchHelpers","depth","replace","watchPath","fullWatchPath","resolve","hasGlob","globFilter","follow","globSymlink","checkGlobSymlink","entry","fullParentDir","realPath","linkPath","entryPath","filterPath","isSymbolicLink","filterDir","resolvedPath","_hasReadPermissions","getDirParts","parts","expandedPath","expand","split","dirParts","pop","unmatchedGlob","entryParts","globstar","some","every","part","i","statMethod","_getWatchedDir","directory","dir","watcherRemove","_remove","_items","add","remove","children","readdir","dirname","basename","has","Boolean","mode","toString","isDirectory","watchedDirs","nestedDirectoryChildren","nestedItem","parent","wasTracked","relPath","eventName","_closePath","closer","_origAdd","_internal","TypeError","absPath","substring","_addToFsEvents","next","_addToNodeFs","res","results","unwatch","close","removeAllListeners","getWatched","watchList","sort","importHandler","handler","method","exports","watch"],"mappings":"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","sourcesContent":["'use strict';\r\nvar EventEmitter = require('events').EventEmitter;\r\nvar fs = require('fs');\r\nvar sysPath = require('path');\r\nvar asyncEach = require('async-each');\r\nvar anymatch = require('anymatch');\r\nvar globParent = require('glob-parent');\r\nvar isGlob = require('is-glob');\r\nvar isAbsolute = require('path-is-absolute');\r\nvar inherits = require('inherits');\r\nvar braces = require('braces');\r\nvar normalizePath = require('normalize-path');\r\nvar upath = require('upath');\r\n\r\nvar NodeFsHandler = require('./lib/nodefs-handler');\r\nvar FsEventsHandler = require('./lib/fsevents-handler');\r\n\r\nvar arrify = function(value) {\r\n  if (value == null) return [];\r\n  return Array.isArray(value) ? value : [value];\r\n};\r\n\r\nvar flatten = function(list, result) {\r\n  if (result == null) result = [];\r\n  list.forEach(function(item) {\r\n    if (Array.isArray(item)) {\r\n      flatten(item, result);\r\n    } else {\r\n      result.push(item);\r\n    }\r\n  });\r\n  return result;\r\n};\r\n\r\n// Little isString util for use in Array#every.\r\nvar isString = function(thing) {\r\n  return typeof thing === 'string';\r\n};\r\n\r\n// Public: Main class.\r\n// Watches files & directories for changes.\r\n//\r\n// * _opts - object, chokidar options hash\r\n//\r\n// Emitted events:\r\n// `add`, `addDir`, `change`, `unlink`, `unlinkDir`, `all`, `error`\r\n//\r\n// Examples\r\n//\r\n//  var watcher = new FSWatcher()\r\n//    .add(directories)\r\n//    .on('add', path => console.log('File', path, 'was added'))\r\n//    .on('change', path => console.log('File', path, 'was changed'))\r\n//    .on('unlink', path => console.log('File', path, 'was removed'))\r\n//    .on('all', (event, path) => console.log(path, ' emitted ', event))\r\n//\r\nfunction FSWatcher(_opts) {\r\n  EventEmitter.call(this);\r\n  var opts = {};\r\n  // in case _opts that is passed in is a frozen object\r\n  if (_opts) for (var opt in _opts) opts[opt] = _opts[opt];\r\n  this._watched = Object.create(null);\r\n  this._closers = Object.create(null);\r\n  this._ignoredPaths = Object.create(null);\r\n  Object.defineProperty(this, '_globIgnored', {\r\n    get: function() { return Object.keys(this._ignoredPaths); }\r\n  });\r\n  this.closed = false;\r\n  this._throttled = Object.create(null);\r\n  this._symlinkPaths = Object.create(null);\r\n\r\n  function undef(key) {\r\n    return opts[key] === undefined;\r\n  }\r\n\r\n  // Set up default options.\r\n  if (undef('persistent')) opts.persistent = true;\r\n  if (undef('ignoreInitial')) opts.ignoreInitial = false;\r\n  if (undef('ignorePermissionErrors')) opts.ignorePermissionErrors = false;\r\n  if (undef('interval')) opts.interval = 100;\r\n  if (undef('binaryInterval')) opts.binaryInterval = 300;\r\n  if (undef('disableGlobbing')) opts.disableGlobbing = false;\r\n  this.enableBinaryInterval = opts.binaryInterval !== opts.interval;\r\n\r\n  // Enable fsevents on OS X when polling isn't explicitly enabled.\r\n  if (undef('useFsEvents')) opts.useFsEvents = !opts.usePolling;\r\n\r\n  // If we can't use fsevents, ensure the options reflect it's disabled.\r\n  if (!FsEventsHandler.canUse()) opts.useFsEvents = false;\r\n\r\n  // Use polling on Mac if not using fsevents.\r\n  // Other platforms use non-polling fs.watch.\r\n  if (undef('usePolling') && !opts.useFsEvents) {\r\n    opts.usePolling = process.platform === 'darwin';\r\n  }\r\n\r\n  // Global override (useful for end-developers that need to force polling for all\r\n  // instances of chokidar, regardless of usage/dependency depth)\r\n  var envPoll = process.env.CHOKIDAR_USEPOLLING;\r\n  if (envPoll !== undefined) {\r\n    var envLower = envPoll.toLowerCase();\r\n\r\n    if (envLower === 'false' || envLower === '0') {\r\n      opts.usePolling = false;\r\n    } else if (envLower === 'true' || envLower === '1') {\r\n      opts.usePolling = true;\r\n    } else {\r\n      opts.usePolling = !!envLower\r\n    }\r\n  }\r\n  var envInterval = process.env.CHOKIDAR_INTERVAL;\r\n  if (envInterval) {\r\n    opts.interval = parseInt(envInterval);\r\n  }\r\n\r\n  // Editor atomic write normalization enabled by default with fs.watch\r\n  if (undef('atomic')) opts.atomic = !opts.usePolling && !opts.useFsEvents;\r\n  if (opts.atomic) this._pendingUnlinks = Object.create(null);\r\n\r\n  if (undef('followSymlinks')) opts.followSymlinks = true;\r\n\r\n  if (undef('awaitWriteFinish')) opts.awaitWriteFinish = false;\r\n  if (opts.awaitWriteFinish === true) opts.awaitWriteFinish = {};\r\n  var awf = opts.awaitWriteFinish;\r\n  if (awf) {\r\n    if (!awf.stabilityThreshold) awf.stabilityThreshold = 2000;\r\n    if (!awf.pollInterval) awf.pollInterval = 100;\r\n\r\n    this._pendingWrites = Object.create(null);\r\n  }\r\n  if (opts.ignored) opts.ignored = arrify(opts.ignored);\r\n\r\n  this._isntIgnored = function(path, stat) {\r\n    return !this._isIgnored(path, stat);\r\n  }.bind(this);\r\n\r\n  var readyCalls = 0;\r\n  this._emitReady = function() {\r\n    if (++readyCalls >= this._readyCount) {\r\n      this._emitReady = Function.prototype;\r\n      this._readyEmitted = true;\r\n      // use process.nextTick to allow time for listener to be bound\r\n      process.nextTick(this.emit.bind(this, 'ready'));\r\n    }\r\n  }.bind(this);\r\n\r\n  this.options = opts;\r\n\r\n  // You’re frozen when your heart’s not open.\r\n  Object.freeze(opts);\r\n}\r\n\r\ninherits(FSWatcher, EventEmitter);\r\n\r\n// Common helpers\r\n// --------------\r\n\r\n// Private method: Normalize and emit events\r\n//\r\n// * event     - string, type of event\r\n// * path      - string, file or directory path\r\n// * val[1..3] - arguments to be passed with event\r\n//\r\n// Returns the error if defined, otherwise the value of the\r\n// FSWatcher instance's `closed` flag\r\nFSWatcher.prototype._emit = function(event, path, val1, val2, val3) {\r\n  if (this.options.cwd) path = sysPath.relative(this.options.cwd, path);\r\n  var args = [event, path];\r\n  if (val3 !== undefined) args.push(val1, val2, val3);\r\n  else if (val2 !== undefined) args.push(val1, val2);\r\n  else if (val1 !== undefined) args.push(val1);\r\n\r\n  var awf = this.options.awaitWriteFinish;\r\n  if (awf && this._pendingWrites[path]) {\r\n    this._pendingWrites[path].lastChange = new Date();\r\n    return this;\r\n  }\r\n\r\n  if (this.options.atomic) {\r\n    if (event === 'unlink') {\r\n      this._pendingUnlinks[path] = args;\r\n      setTimeout(function() {\r\n        Object.keys(this._pendingUnlinks).forEach(function(path) {\r\n          this.emit.apply(this, this._pendingUnlinks[path]);\r\n          this.emit.apply(this, ['all'].concat(this._pendingUnlinks[path]));\r\n          delete this._pendingUnlinks[path];\r\n        }.bind(this));\r\n      }.bind(this), typeof this.options.atomic === \"number\"\r\n        ? this.options.atomic\r\n        : 100);\r\n      return this;\r\n    } else if (event === 'add' && this._pendingUnlinks[path]) {\r\n      event = args[0] = 'change';\r\n      delete this._pendingUnlinks[path];\r\n    }\r\n  }\r\n\r\n  var emitEvent = function() {\r\n    this.emit.apply(this, args);\r\n    if (event !== 'error') this.emit.apply(this, ['all'].concat(args));\r\n  }.bind(this);\r\n\r\n  if (awf && (event === 'add' || event === 'change') && this._readyEmitted) {\r\n    var awfEmit = function(err, stats) {\r\n      if (err) {\r\n        event = args[0] = 'error';\r\n        args[1] = err;\r\n        emitEvent();\r\n      } else if (stats) {\r\n        // if stats doesn't exist the file must have been deleted\r\n        if (args.length > 2) {\r\n          args[2] = stats;\r\n        } else {\r\n          args.push(stats);\r\n        }\r\n        emitEvent();\r\n      }\r\n    };\r\n\r\n    this._awaitWriteFinish(path, awf.stabilityThreshold, event, awfEmit);\r\n    return this;\r\n  }\r\n\r\n  if (event === 'change') {\r\n    if (!this._throttle('change', path, 50)) return this;\r\n  }\r\n\r\n  if (\r\n    this.options.alwaysStat && val1 === undefined &&\r\n    (event === 'add' || event === 'addDir' || event === 'change')\r\n  ) {\r\n    var fullPath = this.options.cwd ? sysPath.join(this.options.cwd, path) : path;\r\n    fs.stat(fullPath, function(error, stats) {\r\n      // Suppress event when fs.stat fails, to avoid sending undefined 'stat'\r\n      if (error || !stats) return;\r\n\r\n      args.push(stats);\r\n      emitEvent();\r\n    });\r\n  } else {\r\n    emitEvent();\r\n  }\r\n\r\n  return this;\r\n};\r\n\r\n// Private method: Common handler for errors\r\n//\r\n// * error  - object, Error instance\r\n//\r\n// Returns the error if defined, otherwise the value of the\r\n// FSWatcher instance's `closed` flag\r\nFSWatcher.prototype._handleError = function(error) {\r\n  var code = error && error.code;\r\n  var ipe = this.options.ignorePermissionErrors;\r\n  if (error &&\r\n    code !== 'ENOENT' &&\r\n    code !== 'ENOTDIR' &&\r\n    (!ipe || (code !== 'EPERM' && code !== 'EACCES'))\r\n  ) this.emit('error', error);\r\n  return error || this.closed;\r\n};\r\n\r\n// Private method: Helper utility for throttling\r\n//\r\n// * action  - string, type of action being throttled\r\n// * path    - string, path being acted upon\r\n// * timeout - int, duration of time to suppress duplicate actions\r\n//\r\n// Returns throttle tracking object or false if action should be suppressed\r\nFSWatcher.prototype._throttle = function(action, path, timeout) {\r\n  if (!(action in this._throttled)) {\r\n    this._throttled[action] = Object.create(null);\r\n  }\r\n  var throttled = this._throttled[action];\r\n  if (path in throttled) {\r\n    throttled[path].count++;\r\n    return false;\r\n  }\r\n  function clear() {\r\n    var count = throttled[path] ? throttled[path].count : 0;\r\n    delete throttled[path];\r\n    clearTimeout(timeoutObject);\r\n    return count;\r\n  }\r\n  var timeoutObject = setTimeout(clear, timeout);\r\n  throttled[path] = {timeoutObject: timeoutObject, clear: clear, count: 0};\r\n  return throttled[path];\r\n};\r\n\r\n// Private method: Awaits write operation to finish\r\n//\r\n// * path    - string, path being acted upon\r\n// * threshold - int, time in milliseconds a file size must be fixed before\r\n//                    acknowledging write operation is finished\r\n// * awfEmit - function, to be called when ready for event to be emitted\r\n// Polls a newly created file for size variations. When files size does not\r\n// change for 'threshold' milliseconds calls callback.\r\nFSWatcher.prototype._awaitWriteFinish = function(path, threshold, event, awfEmit) {\r\n  var timeoutHandler;\r\n\r\n  var fullPath = path;\r\n  if (this.options.cwd && !isAbsolute(path)) {\r\n    fullPath = sysPath.join(this.options.cwd, path);\r\n  }\r\n\r\n  var now = new Date();\r\n\r\n  var awaitWriteFinish = (function (prevStat) {\r\n    fs.stat(fullPath, function(err, curStat) {\r\n      if (err || !(path in this._pendingWrites)) {\r\n        if (err && err.code !== 'ENOENT') awfEmit(err);\r\n        return;\r\n      }\r\n\r\n      var now = new Date();\r\n\r\n      if (prevStat && curStat.size != prevStat.size) {\r\n        this._pendingWrites[path].lastChange = now;\r\n      }\r\n\r\n      if (now - this._pendingWrites[path].lastChange >= threshold) {\r\n        delete this._pendingWrites[path];\r\n        awfEmit(null, curStat);\r\n      } else {\r\n        timeoutHandler = setTimeout(\r\n          awaitWriteFinish.bind(this, curStat),\r\n          this.options.awaitWriteFinish.pollInterval\r\n        );\r\n      }\r\n    }.bind(this));\r\n  }.bind(this));\r\n\r\n  if (!(path in this._pendingWrites)) {\r\n    this._pendingWrites[path] = {\r\n      lastChange: now,\r\n      cancelWait: function() {\r\n        delete this._pendingWrites[path];\r\n        clearTimeout(timeoutHandler);\r\n        return event;\r\n      }.bind(this)\r\n    };\r\n    timeoutHandler = setTimeout(\r\n      awaitWriteFinish.bind(this),\r\n      this.options.awaitWriteFinish.pollInterval\r\n    );\r\n  }\r\n};\r\n\r\n// Private method: Determines whether user has asked to ignore this path\r\n//\r\n// * path  - string, path to file or directory\r\n// * stats - object, result of fs.stat\r\n//\r\n// Returns boolean\r\nvar dotRe = /\\..*\\.(sw[px])$|\\~$|\\.subl.*\\.tmp/;\r\nFSWatcher.prototype._isIgnored = function(path, stats) {\r\n  if (this.options.atomic && dotRe.test(path)) return true;\r\n\r\n  if (!this._userIgnored) {\r\n    var cwd = this.options.cwd;\r\n    var ignored = this.options.ignored;\r\n    if (cwd && ignored) {\r\n      ignored = ignored.map(function (path) {\r\n        if (typeof path !== 'string') return path;\r\n        return upath.normalize(isAbsolute(path) ? path : sysPath.join(cwd, path));\r\n      });\r\n    }\r\n    var paths = arrify(ignored)\r\n      .filter(function(path) {\r\n        return typeof path === 'string' && !isGlob(path);\r\n      }).map(function(path) {\r\n        return path + '/**';\r\n      });\r\n    this._userIgnored = anymatch(\r\n      this._globIgnored.concat(ignored).concat(paths)\r\n    );\r\n  }\r\n\r\n  return this._userIgnored([path, stats]);\r\n};\r\n\r\n// Private method: Provides a set of common helpers and properties relating to\r\n// symlink and glob handling\r\n//\r\n// * path - string, file, directory, or glob pattern being watched\r\n// * depth - int, at any depth > 0, this isn't a glob\r\n//\r\n// Returns object containing helpers for this path\r\nvar replacerRe = /^\\.[\\/\\\\]/;\r\nFSWatcher.prototype._getWatchHelpers = function(path, depth) {\r\n  path = path.replace(replacerRe, '');\r\n  var watchPath = depth || this.options.disableGlobbing || !isGlob(path) ? path : globParent(path);\r\n  var fullWatchPath = sysPath.resolve(watchPath);\r\n  var hasGlob = watchPath !== path;\r\n  var globFilter = hasGlob ? anymatch(path) : false;\r\n  var follow = this.options.followSymlinks;\r\n  var globSymlink = hasGlob && follow ? null : false;\r\n\r\n  var checkGlobSymlink = function(entry) {\r\n    // only need to resolve once\r\n    // first entry should always have entry.parentDir === ''\r\n    if (globSymlink == null) {\r\n      globSymlink = entry.fullParentDir === fullWatchPath ? false : {\r\n        realPath: entry.fullParentDir,\r\n        linkPath: fullWatchPath\r\n      };\r\n    }\r\n\r\n    if (globSymlink) {\r\n      return entry.fullPath.replace(globSymlink.realPath, globSymlink.linkPath);\r\n    }\r\n\r\n    return entry.fullPath;\r\n  };\r\n\r\n  var entryPath = function(entry) {\r\n    return sysPath.join(watchPath,\r\n      sysPath.relative(watchPath, checkGlobSymlink(entry))\r\n    );\r\n  };\r\n\r\n  var filterPath = function(entry) {\r\n    if (entry.stat && entry.stat.isSymbolicLink()) return filterDir(entry);\r\n    var resolvedPath = entryPath(entry);\r\n    return (!hasGlob || globFilter(resolvedPath)) &&\r\n      this._isntIgnored(resolvedPath, entry.stat) &&\r\n      (this.options.ignorePermissionErrors ||\r\n        this._hasReadPermissions(entry.stat));\r\n  }.bind(this);\r\n\r\n  var getDirParts = function(path) {\r\n    if (!hasGlob) return false;\r\n    var parts = [];\r\n    var expandedPath = braces.expand(path);\r\n    expandedPath.forEach(function(path) {\r\n      parts.push(sysPath.relative(watchPath, path).split(/[\\/\\\\]/));\r\n    });\r\n    return parts;\r\n  };\r\n\r\n  var dirParts = getDirParts(path);\r\n  if (dirParts) {\r\n    dirParts.forEach(function(parts) {\r\n      if (parts.length > 1) parts.pop();\r\n    });\r\n  }\r\n  var unmatchedGlob;\r\n\r\n  var filterDir = function(entry) {\r\n    if (hasGlob) {\r\n      var entryParts = getDirParts(checkGlobSymlink(entry));\r\n      var globstar = false;\r\n      unmatchedGlob = !dirParts.some(function(parts) {\r\n        return parts.every(function(part, i) {\r\n          if (part === '**') globstar = true;\r\n          return globstar || !entryParts[0][i] || anymatch(part, entryParts[0][i]);\r\n        });\r\n      });\r\n    }\r\n    return !unmatchedGlob && this._isntIgnored(entryPath(entry), entry.stat);\r\n  }.bind(this);\r\n\r\n  return {\r\n    followSymlinks: follow,\r\n    statMethod: follow ? 'stat' : 'lstat',\r\n    path: path,\r\n    watchPath: watchPath,\r\n    entryPath: entryPath,\r\n    hasGlob: hasGlob,\r\n    globFilter: globFilter,\r\n    filterPath: filterPath,\r\n    filterDir: filterDir\r\n  };\r\n};\r\n\r\n// Directory helpers\r\n// -----------------\r\n\r\n// Private method: Provides directory tracking objects\r\n//\r\n// * directory - string, path of the directory\r\n//\r\n// Returns the directory's tracking object\r\nFSWatcher.prototype._getWatchedDir = function(directory) {\r\n  var dir = sysPath.resolve(directory);\r\n  var watcherRemove = this._remove.bind(this);\r\n  if (!(dir in this._watched)) this._watched[dir] = {\r\n    _items: Object.create(null),\r\n    add: function(item) {\r\n      if (item !== '.' && item !== '..') this._items[item] = true;\r\n    },\r\n    remove: function(item) {\r\n      delete this._items[item];\r\n      if (!this.children().length) {\r\n        fs.readdir(dir, function(err) {\r\n          if (err) watcherRemove(sysPath.dirname(dir), sysPath.basename(dir));\r\n        });\r\n      }\r\n    },\r\n    has: function(item) {return item in this._items;},\r\n    children: function() {return Object.keys(this._items);}\r\n  };\r\n  return this._watched[dir];\r\n};\r\n\r\n// File helpers\r\n// ------------\r\n\r\n// Private method: Check for read permissions\r\n// Based on this answer on SO: http://stackoverflow.com/a/11781404/1358405\r\n//\r\n// * stats - object, result of fs.stat\r\n//\r\n// Returns boolean\r\nFSWatcher.prototype._hasReadPermissions = function(stats) {\r\n  return Boolean(4 & parseInt(((stats && stats.mode) & 0x1ff).toString(8)[0], 10));\r\n};\r\n\r\n// Private method: Handles emitting unlink events for\r\n// files and directories, and via recursion, for\r\n// files and directories within directories that are unlinked\r\n//\r\n// * directory - string, directory within which the following item is located\r\n// * item      - string, base path of item/directory\r\n//\r\n// Returns nothing\r\nFSWatcher.prototype._remove = function(directory, item) {\r\n  // if what is being deleted is a directory, get that directory's paths\r\n  // for recursive deleting and cleaning of watched object\r\n  // if it is not a directory, nestedDirectoryChildren will be empty array\r\n  var path = sysPath.join(directory, item);\r\n  var fullPath = sysPath.resolve(path);\r\n  var isDirectory = this._watched[path] || this._watched[fullPath];\r\n\r\n  // prevent duplicate handling in case of arriving here nearly simultaneously\r\n  // via multiple paths (such as _handleFile and _handleDir)\r\n  if (!this._throttle('remove', path, 100)) return;\r\n\r\n  // if the only watched file is removed, watch for its return\r\n  var watchedDirs = Object.keys(this._watched);\r\n  if (!isDirectory && !this.options.useFsEvents && watchedDirs.length === 1) {\r\n    this.add(directory, item, true);\r\n  }\r\n\r\n  // This will create a new entry in the watched object in either case\r\n  // so we got to do the directory check beforehand\r\n  var nestedDirectoryChildren = this._getWatchedDir(path).children();\r\n\r\n  // Recursively remove children directories / files.\r\n  nestedDirectoryChildren.forEach(function(nestedItem) {\r\n    this._remove(path, nestedItem);\r\n  }, this);\r\n\r\n  // Check if item was on the watched list and remove it\r\n  var parent = this._getWatchedDir(directory);\r\n  var wasTracked = parent.has(item);\r\n  parent.remove(item);\r\n\r\n  // If we wait for this file to be fully written, cancel the wait.\r\n  var relPath = path;\r\n  if (this.options.cwd) relPath = sysPath.relative(this.options.cwd, path);\r\n  if (this.options.awaitWriteFinish && this._pendingWrites[relPath]) {\r\n    var event = this._pendingWrites[relPath].cancelWait();\r\n    if (event === 'add') return;\r\n  }\r\n\r\n  // The Entry will either be a directory that just got removed\r\n  // or a bogus entry to a file, in either case we have to remove it\r\n  delete this._watched[path];\r\n  delete this._watched[fullPath];\r\n  var eventName = isDirectory ? 'unlinkDir' : 'unlink';\r\n  if (wasTracked && !this._isIgnored(path)) this._emit(eventName, path);\r\n\r\n  // Avoid conflicts if we later create another file with the same name\r\n  if (!this.options.useFsEvents) {\r\n    this._closePath(path);\r\n  }\r\n};\r\n\r\nFSWatcher.prototype._closePath = function(path) {\r\n  if (!this._closers[path]) return;\r\n  this._closers[path].forEach(function(closer) {\r\n    closer();\r\n  });\r\n  delete this._closers[path];\r\n  this._getWatchedDir(sysPath.dirname(path)).remove(sysPath.basename(path));\r\n}\r\n\r\n// Public method: Adds paths to be watched on an existing FSWatcher instance\r\n\r\n// * paths     - string or array of strings, file/directory paths and/or globs\r\n// * _origAdd  - private boolean, for handling non-existent paths to be watched\r\n// * _internal - private boolean, indicates a non-user add\r\n\r\n// Returns an instance of FSWatcher for chaining.\r\nFSWatcher.prototype.add = function(paths, _origAdd, _internal) {\r\n  var disableGlobbing = this.options.disableGlobbing;\r\n  var cwd = this.options.cwd;\r\n  this.closed = false;\r\n  paths = flatten(arrify(paths));\r\n\r\n  if (!paths.every(isString)) {\r\n    throw new TypeError('Non-string provided as watch path: ' + paths);\r\n  }\r\n\r\n  if (cwd) paths = paths.map(function(path) {\r\n    var absPath;\r\n    if (isAbsolute(path)) {\r\n      absPath = path;\r\n    } else if (path[0] === '!') {\r\n      absPath = '!' + sysPath.join(cwd, path.substring(1));\r\n    } else {\r\n      absPath = sysPath.join(cwd, path);\r\n    }\r\n\r\n    // Check `path` instead of `absPath` because the cwd portion can't be a glob\r\n    if (disableGlobbing || !isGlob(path)) {\r\n      return absPath;\r\n    } else {\r\n      return normalizePath(absPath);\r\n    }\r\n  });\r\n\r\n  // set aside negated glob strings\r\n  paths = paths.filter(function(path) {\r\n    if (path[0] === '!') {\r\n      this._ignoredPaths[path.substring(1)] = true;\r\n    } else {\r\n      // if a path is being added that was previously ignored, stop ignoring it\r\n      delete this._ignoredPaths[path];\r\n      delete this._ignoredPaths[path + '/**'];\r\n\r\n      // reset the cached userIgnored anymatch fn\r\n      // to make ignoredPaths changes effective\r\n      this._userIgnored = null;\r\n\r\n      return true;\r\n    }\r\n  }, this);\r\n\r\n  if (this.options.useFsEvents && FsEventsHandler.canUse()) {\r\n    if (!this._readyCount) this._readyCount = paths.length;\r\n    if (this.options.persistent) this._readyCount *= 2;\r\n    paths.forEach(this._addToFsEvents, this);\r\n  } else {\r\n    if (!this._readyCount) this._readyCount = 0;\r\n    this._readyCount += paths.length;\r\n    asyncEach(paths, function(path, next) {\r\n      this._addToNodeFs(path, !_internal, 0, 0, _origAdd, function(err, res) {\r\n        if (res) this._emitReady();\r\n        next(err, res);\r\n      }.bind(this));\r\n    }.bind(this), function(error, results) {\r\n      results.forEach(function(item) {\r\n        if (!item || this.closed) return;\r\n        this.add(sysPath.dirname(item), sysPath.basename(_origAdd || item));\r\n      }, this);\r\n    }.bind(this));\r\n  }\r\n\r\n  return this;\r\n};\r\n\r\n// Public method: Close watchers or start ignoring events from specified paths.\r\n\r\n// * paths     - string or array of strings, file/directory paths and/or globs\r\n\r\n// Returns instance of FSWatcher for chaining.\r\nFSWatcher.prototype.unwatch = function(paths) {\r\n  if (this.closed) return this;\r\n  paths = flatten(arrify(paths));\r\n\r\n  paths.forEach(function(path) {\r\n    // convert to absolute path unless relative path already matches\r\n    if (!isAbsolute(path) && !this._closers[path]) {\r\n      if (this.options.cwd) path = sysPath.join(this.options.cwd, path);\r\n      path = sysPath.resolve(path);\r\n    }\r\n\r\n    this._closePath(path);\r\n\r\n    this._ignoredPaths[path] = true;\r\n    if (path in this._watched) {\r\n      this._ignoredPaths[path + '/**'] = true;\r\n    }\r\n\r\n    // reset the cached userIgnored anymatch fn\r\n    // to make ignoredPaths changes effective\r\n    this._userIgnored = null;\r\n  }, this);\r\n\r\n  return this;\r\n};\r\n\r\n// Public method: Close watchers and remove all listeners from watched paths.\r\n\r\n// Returns instance of FSWatcher for chaining.\r\nFSWatcher.prototype.close = function() {\r\n  if (this.closed) return this;\r\n\r\n  this.closed = true;\r\n  Object.keys(this._closers).forEach(function(watchPath) {\r\n    this._closers[watchPath].forEach(function(closer) {\r\n      closer();\r\n    });\r\n    delete this._closers[watchPath];\r\n  }, this);\r\n  this._watched = Object.create(null);\r\n\r\n  this.removeAllListeners();\r\n  return this;\r\n};\r\n\r\n// Public method: Expose list of watched paths\r\n\r\n// Returns object w/ dir paths as keys and arrays of contained paths as values.\r\nFSWatcher.prototype.getWatched = function() {\r\n  var watchList = {};\r\n  Object.keys(this._watched).forEach(function(dir) {\r\n    var key = this.options.cwd ? sysPath.relative(this.options.cwd, dir) : dir;\r\n    watchList[key || '.'] = Object.keys(this._watched[dir]._items).sort();\r\n  }.bind(this));\r\n  return watchList;\r\n};\r\n\r\n// Attach watch handler prototype methods\r\nfunction importHandler(handler) {\r\n  Object.keys(handler.prototype).forEach(function(method) {\r\n    FSWatcher.prototype[method] = handler.prototype[method];\r\n  });\r\n}\r\nimportHandler(NodeFsHandler);\r\nif (FsEventsHandler.canUse()) importHandler(FsEventsHandler);\r\n\r\n// Export FSWatcher class\r\nexports.FSWatcher = FSWatcher;\r\n\r\n// Public function: Instantiates watcher with paths to be tracked.\r\n\r\n// * paths     - string or array of strings, file/directory paths and/or globs\r\n// * options   - object, chokidar options\r\n\r\n// Returns an instance of FSWatcher for chaining.\r\nexports.watch = function(paths, options) {\r\n  return new FSWatcher(options).add(paths);\r\n};\r\n"]},"metadata":{},"sourceType":"script"}