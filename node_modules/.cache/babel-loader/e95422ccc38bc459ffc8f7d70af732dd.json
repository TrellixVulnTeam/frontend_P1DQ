{"ast":null,"code":"(function () {\n  'use strict';\n  /**\r\n   * Extend an Object with another Object's properties.\r\n   *\r\n   * The source objects are specified as additional arguments.\r\n   *\r\n   * @param dst Object the object to extend.\r\n   *\r\n   * @return Object the final object.\r\n   */\n\n  var _extend = function (dst) {\n    var sources = Array.prototype.slice.call(arguments, 1);\n\n    for (var i = 0; i < sources.length; ++i) {\n      var src = sources[i];\n\n      for (var p in src) {\n        if (src.hasOwnProperty(p)) dst[p] = src[p];\n      }\n    }\n\n    return dst;\n  };\n  /**\r\n   * Defer execution of given function.\r\n   * @param  {Function} func\r\n   */\n\n\n  var _defer = function (func) {\n    if (typeof setImmediate === 'function') {\n      return setImmediate(func);\n    } else {\n      return setTimeout(func, 0);\n    }\n  };\n  /**\r\n   * Based on the algorithm at http://en.wikipedia.org/wiki/Levenshtein_distance.\r\n   */\n\n\n  var Levenshtein = {\n    /**\r\n     * Calculate levenshtein distance of the two strings.\r\n     *\r\n     * @param str1 String the first string.\r\n     * @param str2 String the second string.\r\n     * @return Integer the levenshtein distance (0 and above).\r\n     */\n    get: function (str1, str2) {\n      // base cases\n      if (str1 === str2) return 0;\n      if (str1.length === 0) return str2.length;\n      if (str2.length === 0) return str1.length; // two rows\n\n      var prevRow = new Array(str2.length + 1),\n          curCol,\n          nextCol,\n          i,\n          j,\n          tmp; // initialise previous row\n\n      for (i = 0; i < prevRow.length; ++i) {\n        prevRow[i] = i;\n      } // calculate current row distance from previous row\n\n\n      for (i = 0; i < str1.length; ++i) {\n        nextCol = i + 1;\n\n        for (j = 0; j < str2.length; ++j) {\n          curCol = nextCol; // substution\n\n          nextCol = prevRow[j] + (str1.charAt(i) === str2.charAt(j) ? 0 : 1); // insertion\n\n          tmp = curCol + 1;\n\n          if (nextCol > tmp) {\n            nextCol = tmp;\n          } // deletion\n\n\n          tmp = prevRow[j + 1] + 1;\n\n          if (nextCol > tmp) {\n            nextCol = tmp;\n          } // copy current col value into previous (in preparation for next iteration)\n\n\n          prevRow[j] = curCol;\n        } // copy last col value into previous (in preparation for next iteration)\n\n\n        prevRow[j] = nextCol;\n      }\n\n      return nextCol;\n    },\n\n    /**\r\n     * Asynchronously calculate levenshtein distance of the two strings.\r\n     *\r\n     * @param str1 String the first string.\r\n     * @param str2 String the second string.\r\n     * @param cb Function callback function with signature: function(Error err, int distance)\r\n     * @param [options] Object additional options.\r\n     * @param [options.progress] Function progress callback with signature: function(percentComplete)\r\n     */\n    getAsync: function (str1, str2, cb, options) {\n      options = _extend({}, {\n        progress: null\n      }, options); // base cases\n\n      if (str1 === str2) return cb(null, 0);\n      if (str1.length === 0) return cb(null, str2.length);\n      if (str2.length === 0) return cb(null, str1.length); // two rows\n\n      var prevRow = new Array(str2.length + 1),\n          curCol,\n          nextCol,\n          i,\n          j,\n          tmp,\n          startTime,\n          currentTime; // initialise previous row\n\n      for (i = 0; i < prevRow.length; ++i) {\n        prevRow[i] = i;\n      }\n\n      nextCol = 1;\n      i = 0;\n      j = -1;\n\n      var __calculate = function () {\n        // reset timer\n        startTime = new Date().valueOf();\n        currentTime = startTime; // keep going until one second has elapsed\n\n        while (currentTime - startTime < 1000) {\n          // reached end of current row?\n          if (str2.length <= ++j) {\n            // copy current into previous (in preparation for next iteration)\n            prevRow[j] = nextCol; // if already done all chars\n\n            if (str1.length <= ++i) {\n              return cb(null, nextCol);\n            } // else if we have more left to do\n            else {\n              nextCol = i + 1;\n              j = 0;\n            }\n          } // calculation\n\n\n          curCol = nextCol; // substution\n\n          nextCol = prevRow[j] + (str1.charAt(i) === str2.charAt(j) ? 0 : 1); // insertion\n\n          tmp = curCol + 1;\n\n          if (nextCol > tmp) {\n            nextCol = tmp;\n          } // deletion\n\n\n          tmp = prevRow[j + 1] + 1;\n\n          if (nextCol > tmp) {\n            nextCol = tmp;\n          } // copy current into previous (in preparation for next iteration)\n\n\n          prevRow[j] = curCol; // get current time\n\n          currentTime = new Date().valueOf();\n        } // send a progress update?\n\n\n        if (null !== options.progress) {\n          try {\n            options.progress.call(null, i * 100.0 / str1.length);\n          } catch (err) {\n            return cb('Progress callback: ' + err.toString());\n          }\n        } // next iteration\n\n\n        _defer(__calculate);\n      };\n\n      __calculate();\n    }\n  }; // amd\n\n  if (typeof define !== \"undefined\" && define !== null && define.amd) {\n    define(function () {\n      return Levenshtein;\n    });\n  } // commonjs\n  else if (typeof module !== \"undefined\" && module !== null && typeof exports !== \"undefined\" && module.exports === exports) {\n    module.exports = Levenshtein;\n  } // web worker\n  else if (typeof self !== \"undefined\" && typeof self.postMessage === 'function' && typeof self.importScripts === 'function') {\n    self.Levenshtein = Levenshtein;\n  } // browser main thread\n  else if (typeof window !== \"undefined\" && window !== null) {\n    window.Levenshtein = Levenshtein;\n  }\n})();","map":{"version":3,"sources":["C:/frontend/node_modules/fast-levenshtein/levenshtein.js"],"names":["_extend","dst","sources","Array","prototype","slice","call","arguments","i","length","src","p","hasOwnProperty","_defer","func","setImmediate","setTimeout","Levenshtein","get","str1","str2","prevRow","curCol","nextCol","j","tmp","charAt","getAsync","cb","options","progress","startTime","currentTime","__calculate","Date","valueOf","err","toString","define","amd","module","exports","self","postMessage","importScripts","window"],"mappings":"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","sourcesContent":["(function() {\r\n  'use strict';\r\n\r\n  /**\r\n   * Extend an Object with another Object's properties.\r\n   *\r\n   * The source objects are specified as additional arguments.\r\n   *\r\n   * @param dst Object the object to extend.\r\n   *\r\n   * @return Object the final object.\r\n   */\r\n  var _extend = function(dst) {\r\n    var sources = Array.prototype.slice.call(arguments, 1);\r\n    for (var i=0; i<sources.length; ++i) {\r\n      var src = sources[i];\r\n      for (var p in src) {\r\n        if (src.hasOwnProperty(p)) dst[p] = src[p];\r\n      }\r\n    }\r\n    return dst;\r\n  };\r\n\r\n\r\n  /**\r\n   * Defer execution of given function.\r\n   * @param  {Function} func\r\n   */\r\n  var _defer = function(func) {\r\n    if (typeof setImmediate === 'function') {\r\n      return setImmediate(func);\r\n    } else {\r\n      return setTimeout(func, 0);\r\n    }\r\n  };\r\n\r\n  /**\r\n   * Based on the algorithm at http://en.wikipedia.org/wiki/Levenshtein_distance.\r\n   */\r\n  var Levenshtein = {\r\n    /**\r\n     * Calculate levenshtein distance of the two strings.\r\n     *\r\n     * @param str1 String the first string.\r\n     * @param str2 String the second string.\r\n     * @return Integer the levenshtein distance (0 and above).\r\n     */\r\n    get: function(str1, str2) {\r\n      // base cases\r\n      if (str1 === str2) return 0;\r\n      if (str1.length === 0) return str2.length;\r\n      if (str2.length === 0) return str1.length;\r\n\r\n      // two rows\r\n      var prevRow  = new Array(str2.length + 1),\r\n          curCol, nextCol, i, j, tmp;\r\n\r\n      // initialise previous row\r\n      for (i=0; i<prevRow.length; ++i) {\r\n        prevRow[i] = i;\r\n      }\r\n\r\n      // calculate current row distance from previous row\r\n      for (i=0; i<str1.length; ++i) {\r\n        nextCol = i + 1;\r\n\r\n        for (j=0; j<str2.length; ++j) {\r\n          curCol = nextCol;\r\n\r\n          // substution\r\n          nextCol = prevRow[j] + ( (str1.charAt(i) === str2.charAt(j)) ? 0 : 1 );\r\n          // insertion\r\n          tmp = curCol + 1;\r\n          if (nextCol > tmp) {\r\n            nextCol = tmp;\r\n          }\r\n          // deletion\r\n          tmp = prevRow[j + 1] + 1;\r\n          if (nextCol > tmp) {\r\n            nextCol = tmp;\r\n          }\r\n\r\n          // copy current col value into previous (in preparation for next iteration)\r\n          prevRow[j] = curCol;\r\n        }\r\n\r\n        // copy last col value into previous (in preparation for next iteration)\r\n        prevRow[j] = nextCol;\r\n      }\r\n\r\n      return nextCol;\r\n    },\r\n\r\n    /**\r\n     * Asynchronously calculate levenshtein distance of the two strings.\r\n     *\r\n     * @param str1 String the first string.\r\n     * @param str2 String the second string.\r\n     * @param cb Function callback function with signature: function(Error err, int distance)\r\n     * @param [options] Object additional options.\r\n     * @param [options.progress] Function progress callback with signature: function(percentComplete)\r\n     */\r\n    getAsync: function(str1, str2, cb, options) {\r\n      options = _extend({}, {\r\n        progress: null\r\n      }, options);\r\n\r\n      // base cases\r\n      if (str1 === str2) return cb(null, 0);\r\n      if (str1.length === 0) return cb(null, str2.length);\r\n      if (str2.length === 0) return cb(null, str1.length);\r\n\r\n      // two rows\r\n      var prevRow  = new Array(str2.length + 1),\r\n          curCol, nextCol,\r\n          i, j, tmp,\r\n          startTime, currentTime;\r\n\r\n      // initialise previous row\r\n      for (i=0; i<prevRow.length; ++i) {\r\n        prevRow[i] = i;\r\n      }\r\n\r\n      nextCol = 1;\r\n      i = 0;\r\n      j = -1;\r\n\r\n      var __calculate = function() {\r\n        // reset timer\r\n        startTime = new Date().valueOf();\r\n        currentTime = startTime;\r\n\r\n        // keep going until one second has elapsed\r\n        while (currentTime - startTime < 1000) {\r\n          // reached end of current row?\r\n          if (str2.length <= (++j)) {\r\n            // copy current into previous (in preparation for next iteration)\r\n            prevRow[j] = nextCol;\r\n\r\n            // if already done all chars\r\n            if (str1.length <= (++i)) {\r\n              return cb(null, nextCol);\r\n            }\r\n            // else if we have more left to do\r\n            else {\r\n              nextCol = i + 1;\r\n              j = 0;\r\n            }\r\n          }\r\n\r\n          // calculation\r\n          curCol = nextCol;\r\n\r\n          // substution\r\n          nextCol = prevRow[j] + ( (str1.charAt(i) === str2.charAt(j)) ? 0 : 1 );\r\n          // insertion\r\n          tmp = curCol + 1;\r\n          if (nextCol > tmp) {\r\n            nextCol = tmp;\r\n          }\r\n          // deletion\r\n          tmp = prevRow[j + 1] + 1;\r\n          if (nextCol > tmp) {\r\n            nextCol = tmp;\r\n          }\r\n\r\n          // copy current into previous (in preparation for next iteration)\r\n          prevRow[j] = curCol;\r\n\r\n          // get current time\r\n          currentTime = new Date().valueOf();\r\n        }\r\n\r\n        // send a progress update?\r\n        if (null !== options.progress) {\r\n          try {\r\n            options.progress.call(null, (i * 100.0/ str1.length));\r\n          } catch (err) {\r\n            return cb('Progress callback: ' + err.toString());\r\n          }\r\n        }\r\n\r\n        // next iteration\r\n        _defer(__calculate);\r\n      };\r\n\r\n      __calculate();\r\n    }\r\n\r\n  };\r\n\r\n  // amd\r\n  if (typeof define !== \"undefined\" && define !== null && define.amd) {\r\n    define(function() {\r\n      return Levenshtein;\r\n    });\r\n  }\r\n  // commonjs\r\n  else if (typeof module !== \"undefined\" && module !== null && typeof exports !== \"undefined\" && module.exports === exports) {\r\n    module.exports = Levenshtein;\r\n  }\r\n  // web worker\r\n  else if (typeof self !== \"undefined\" && typeof self.postMessage === 'function' && typeof self.importScripts === 'function') {\r\n    self.Levenshtein = Levenshtein;\r\n  }\r\n  // browser main thread\r\n  else if (typeof window !== \"undefined\" && window !== null) {\r\n    window.Levenshtein = Levenshtein;\r\n  }\r\n}());\r\n\r\n"]},"metadata":{},"sourceType":"script"}