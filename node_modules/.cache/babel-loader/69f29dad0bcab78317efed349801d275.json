{"ast":null,"code":"'use strict';\n\nvar inherits = require('util').inherits;\n\nvar glob = require('glob');\n\nvar extend = require('extend');\n\nvar Readable = require('readable-stream').Readable;\n\nvar globParent = require('glob-parent');\n\nvar toAbsoluteGlob = require('to-absolute-glob');\n\nvar removeTrailingSeparator = require('remove-trailing-separator');\n\nvar globErrMessage1 = 'File not found with singular glob: ';\nvar globErrMessage2 = ' (if this was purposeful, use `allowEmpty` option)';\n\nfunction getBasePath(ourGlob, opt) {\n  return globParent(toAbsoluteGlob(ourGlob, opt));\n}\n\nfunction globIsSingular(glob) {\n  var globSet = glob.minimatch.set;\n\n  if (globSet.length !== 1) {\n    return false;\n  }\n\n  return globSet[0].every(function isString(value) {\n    return typeof value === 'string';\n  });\n}\n\nfunction GlobStream(ourGlob, negatives, opt) {\n  if (!(this instanceof GlobStream)) {\n    return new GlobStream(ourGlob, negatives, opt);\n  }\n\n  var ourOpt = extend({}, opt);\n  Readable.call(this, {\n    objectMode: true,\n    highWaterMark: ourOpt.highWaterMark || 16\n  }); // Delete `highWaterMark` after inheriting from Readable\n\n  delete ourOpt.highWaterMark;\n  var self = this;\n\n  function resolveNegatives(negative) {\n    return toAbsoluteGlob(negative, ourOpt);\n  }\n\n  var ourNegatives = negatives.map(resolveNegatives);\n  ourOpt.ignore = ourNegatives;\n  var cwd = ourOpt.cwd;\n  var allowEmpty = ourOpt.allowEmpty || false; // Extract base path from glob\n\n  var basePath = ourOpt.base || getBasePath(ourGlob, ourOpt); // Remove path relativity to make globs make sense\n\n  ourGlob = toAbsoluteGlob(ourGlob, ourOpt); // Delete `root` after all resolving done\n\n  delete ourOpt.root;\n  var globber = new glob.Glob(ourGlob, ourOpt);\n  this._globber = globber;\n  var found = false;\n  globber.on('match', function (filepath) {\n    found = true;\n    var obj = {\n      cwd: cwd,\n      base: basePath,\n      path: removeTrailingSeparator(filepath)\n    };\n\n    if (!self.push(obj)) {\n      globber.pause();\n    }\n  });\n  globber.once('end', function () {\n    if (allowEmpty !== true && !found && globIsSingular(globber)) {\n      var err = new Error(globErrMessage1 + ourGlob + globErrMessage2);\n      return self.destroy(err);\n    }\n\n    self.push(null);\n  });\n\n  function onError(err) {\n    self.destroy(err);\n  }\n\n  globber.once('error', onError);\n}\n\ninherits(GlobStream, Readable);\n\nGlobStream.prototype._read = function () {\n  this._globber.resume();\n};\n\nGlobStream.prototype.destroy = function (err) {\n  var self = this;\n\n  this._globber.abort();\n\n  process.nextTick(function () {\n    if (err) {\n      self.emit('error', err);\n    }\n\n    self.emit('close');\n  });\n};\n\nmodule.exports = GlobStream;","map":{"version":3,"sources":["C:/frontend/node_modules/glob-stream/readable.js"],"names":["inherits","require","glob","extend","Readable","globParent","toAbsoluteGlob","removeTrailingSeparator","globErrMessage1","globErrMessage2","getBasePath","ourGlob","opt","globIsSingular","globSet","minimatch","set","length","every","isString","value","GlobStream","negatives","ourOpt","call","objectMode","highWaterMark","self","resolveNegatives","negative","ourNegatives","map","ignore","cwd","allowEmpty","basePath","base","root","globber","Glob","_globber","found","on","filepath","obj","path","push","pause","once","err","Error","destroy","onError","prototype","_read","resume","abort","process","nextTick","emit","module","exports"],"mappings":"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","sourcesContent":["'use strict';\r\n\r\nvar inherits = require('util').inherits;\r\n\r\nvar glob = require('glob');\r\nvar extend = require('extend');\r\nvar Readable = require('readable-stream').Readable;\r\nvar globParent = require('glob-parent');\r\nvar toAbsoluteGlob = require('to-absolute-glob');\r\nvar removeTrailingSeparator = require('remove-trailing-separator');\r\n\r\nvar globErrMessage1 = 'File not found with singular glob: ';\r\nvar globErrMessage2 = ' (if this was purposeful, use `allowEmpty` option)';\r\n\r\nfunction getBasePath(ourGlob, opt) {\r\n  return globParent(toAbsoluteGlob(ourGlob, opt));\r\n}\r\n\r\nfunction globIsSingular(glob) {\r\n  var globSet = glob.minimatch.set;\r\n  if (globSet.length !== 1) {\r\n    return false;\r\n  }\r\n\r\n  return globSet[0].every(function isString(value) {\r\n    return typeof value === 'string';\r\n  });\r\n}\r\n\r\nfunction GlobStream(ourGlob, negatives, opt) {\r\n  if (!(this instanceof GlobStream)) {\r\n    return new GlobStream(ourGlob, negatives, opt);\r\n  }\r\n\r\n  var ourOpt = extend({}, opt);\r\n\r\n  Readable.call(this, {\r\n    objectMode: true,\r\n    highWaterMark: ourOpt.highWaterMark || 16,\r\n  });\r\n\r\n  // Delete `highWaterMark` after inheriting from Readable\r\n  delete ourOpt.highWaterMark;\r\n\r\n  var self = this;\r\n\r\n  function resolveNegatives(negative) {\r\n    return toAbsoluteGlob(negative, ourOpt);\r\n  }\r\n\r\n  var ourNegatives = negatives.map(resolveNegatives);\r\n  ourOpt.ignore = ourNegatives;\r\n\r\n  var cwd = ourOpt.cwd;\r\n  var allowEmpty = ourOpt.allowEmpty || false;\r\n\r\n  // Extract base path from glob\r\n  var basePath = ourOpt.base || getBasePath(ourGlob, ourOpt);\r\n\r\n  // Remove path relativity to make globs make sense\r\n  ourGlob = toAbsoluteGlob(ourGlob, ourOpt);\r\n  // Delete `root` after all resolving done\r\n  delete ourOpt.root;\r\n\r\n  var globber = new glob.Glob(ourGlob, ourOpt);\r\n  this._globber = globber;\r\n\r\n  var found = false;\r\n\r\n  globber.on('match', function(filepath) {\r\n    found = true;\r\n    var obj = {\r\n      cwd: cwd,\r\n      base: basePath,\r\n      path: removeTrailingSeparator(filepath),\r\n    };\r\n    if (!self.push(obj)) {\r\n      globber.pause();\r\n    }\r\n  });\r\n\r\n  globber.once('end', function() {\r\n    if (allowEmpty !== true && !found && globIsSingular(globber)) {\r\n      var err = new Error(globErrMessage1 + ourGlob + globErrMessage2);\r\n\r\n      return self.destroy(err);\r\n    }\r\n\r\n    self.push(null);\r\n  });\r\n\r\n  function onError(err) {\r\n    self.destroy(err);\r\n  }\r\n\r\n  globber.once('error', onError);\r\n}\r\ninherits(GlobStream, Readable);\r\n\r\nGlobStream.prototype._read = function() {\r\n  this._globber.resume();\r\n};\r\n\r\nGlobStream.prototype.destroy = function(err) {\r\n  var self = this;\r\n\r\n  this._globber.abort();\r\n\r\n  process.nextTick(function() {\r\n    if (err) {\r\n      self.emit('error', err);\r\n    }\r\n    self.emit('close');\r\n  });\r\n};\r\n\r\nmodule.exports = GlobStream;\r\n"]},"metadata":{},"sourceType":"script"}