{"ast":null,"code":"'use strict';\n\nvar util = require('util');\n\nvar fs = require('graceful-fs');\n\nvar assign = require('object.assign');\n\nvar date = require('value-or-function').date;\n\nvar Writable = require('readable-stream').Writable;\n\nvar constants = require('./constants');\n\nvar APPEND_MODE_REGEXP = /a/;\n\nfunction closeFd(propagatedErr, fd, callback) {\n  if (typeof fd !== 'number') {\n    return callback(propagatedErr);\n  }\n\n  fs.close(fd, onClosed);\n\n  function onClosed(closeErr) {\n    if (propagatedErr || closeErr) {\n      return callback(propagatedErr || closeErr);\n    }\n\n    callback();\n  }\n}\n\nfunction isValidUnixId(id) {\n  if (typeof id !== 'number') {\n    return false;\n  }\n\n  if (id < 0) {\n    return false;\n  }\n\n  return true;\n}\n\nfunction getFlags(options) {\n  var flags = !options.append ? 'w' : 'a';\n\n  if (!options.overwrite) {\n    flags += 'x';\n  }\n\n  return flags;\n}\n\nfunction isFatalOverwriteError(err, flags) {\n  if (!err) {\n    return false;\n  }\n\n  if (err.code === 'EEXIST' && flags[1] === 'x') {\n    // Handle scenario for file overwrite failures.\n    return false;\n  } // Otherwise, this is a fatal error\n\n\n  return true;\n}\n\nfunction isFatalUnlinkError(err) {\n  if (!err || err.code === 'ENOENT') {\n    return false;\n  }\n\n  return true;\n}\n\nfunction getModeDiff(fsMode, vinylMode) {\n  var modeDiff = 0;\n\n  if (typeof vinylMode === 'number') {\n    modeDiff = (vinylMode ^ fsMode) & constants.MASK_MODE;\n  }\n\n  return modeDiff;\n}\n\nfunction getTimesDiff(fsStat, vinylStat) {\n  var mtime = date(vinylStat.mtime) || 0;\n\n  if (!mtime) {\n    return;\n  }\n\n  var atime = date(vinylStat.atime) || 0;\n\n  if (+mtime === +fsStat.mtime && +atime === +fsStat.atime) {\n    return;\n  }\n\n  if (!atime) {\n    atime = date(fsStat.atime) || undefined;\n  }\n\n  var timesDiff = {\n    mtime: vinylStat.mtime,\n    atime: atime\n  };\n  return timesDiff;\n}\n\nfunction getOwnerDiff(fsStat, vinylStat) {\n  if (!isValidUnixId(vinylStat.uid) && !isValidUnixId(vinylStat.gid)) {\n    return;\n  }\n\n  if (!isValidUnixId(fsStat.uid) && !isValidUnixId(vinylStat.uid) || !isValidUnixId(fsStat.gid) && !isValidUnixId(vinylStat.gid)) {\n    return;\n  }\n\n  var uid = fsStat.uid; // Default to current uid.\n\n  if (isValidUnixId(vinylStat.uid)) {\n    uid = vinylStat.uid;\n  }\n\n  var gid = fsStat.gid; // Default to current gid.\n\n  if (isValidUnixId(vinylStat.gid)) {\n    gid = vinylStat.gid;\n  }\n\n  if (uid === fsStat.uid && gid === fsStat.gid) {\n    return;\n  }\n\n  var ownerDiff = {\n    uid: uid,\n    gid: gid\n  };\n  return ownerDiff;\n}\n\nfunction isOwner(fsStat) {\n  var hasGetuid = typeof process.getuid === 'function';\n  var hasGeteuid = typeof process.geteuid === 'function'; // If we don't have either, assume we don't have permissions.\n  // This should only happen on Windows.\n  // Windows basically noops fchmod and errors on futimes called on directories.\n\n  if (!hasGeteuid && !hasGetuid) {\n    return false;\n  }\n\n  var uid;\n\n  if (hasGeteuid) {\n    uid = process.geteuid();\n  } else {\n    uid = process.getuid();\n  }\n\n  if (fsStat.uid !== uid && uid !== 0) {\n    return false;\n  }\n\n  return true;\n}\n\nfunction reflectStat(path, file, callback) {\n  // Set file.stat to the reflect current state on disk\n  fs.stat(path, onStat);\n\n  function onStat(statErr, stat) {\n    if (statErr) {\n      return callback(statErr);\n    }\n\n    file.stat = stat;\n    callback();\n  }\n}\n\nfunction reflectLinkStat(path, file, callback) {\n  // Set file.stat to the reflect current state on disk\n  fs.lstat(path, onLstat);\n\n  function onLstat(lstatErr, stat) {\n    if (lstatErr) {\n      return callback(lstatErr);\n    }\n\n    file.stat = stat;\n    callback();\n  }\n}\n\nfunction updateMetadata(fd, file, callback) {\n  fs.fstat(fd, onStat);\n\n  function onStat(statErr, stat) {\n    if (statErr) {\n      return callback(statErr);\n    } // Check if mode needs to be updated\n\n\n    var modeDiff = getModeDiff(stat.mode, file.stat.mode); // Check if atime/mtime need to be updated\n\n    var timesDiff = getTimesDiff(stat, file.stat); // Check if uid/gid need to be updated\n\n    var ownerDiff = getOwnerDiff(stat, file.stat); // Set file.stat to the reflect current state on disk\n\n    assign(file.stat, stat); // Nothing to do\n\n    if (!modeDiff && !timesDiff && !ownerDiff) {\n      return callback();\n    } // Check access, `futimes`, `fchmod` & `fchown` only work if we own\n    // the file, or if we are effectively root (`fchown` only when root).\n\n\n    if (!isOwner(stat)) {\n      return callback();\n    }\n\n    if (modeDiff) {\n      return mode();\n    }\n\n    if (timesDiff) {\n      return times();\n    }\n\n    owner();\n\n    function mode() {\n      var mode = stat.mode ^ modeDiff;\n      fs.fchmod(fd, mode, onFchmod);\n\n      function onFchmod(fchmodErr) {\n        if (!fchmodErr) {\n          file.stat.mode = mode;\n        }\n\n        if (timesDiff) {\n          return times(fchmodErr);\n        }\n\n        if (ownerDiff) {\n          return owner(fchmodErr);\n        }\n\n        callback(fchmodErr);\n      }\n    }\n\n    function times(propagatedErr) {\n      fs.futimes(fd, timesDiff.atime, timesDiff.mtime, onFutimes);\n\n      function onFutimes(futimesErr) {\n        if (!futimesErr) {\n          file.stat.atime = timesDiff.atime;\n          file.stat.mtime = timesDiff.mtime;\n        }\n\n        if (ownerDiff) {\n          return owner(propagatedErr || futimesErr);\n        }\n\n        callback(propagatedErr || futimesErr);\n      }\n    }\n\n    function owner(propagatedErr) {\n      fs.fchown(fd, ownerDiff.uid, ownerDiff.gid, onFchown);\n\n      function onFchown(fchownErr) {\n        if (!fchownErr) {\n          file.stat.uid = ownerDiff.uid;\n          file.stat.gid = ownerDiff.gid;\n        }\n\n        callback(propagatedErr || fchownErr);\n      }\n    }\n  }\n}\n\nfunction symlink(srcPath, destPath, opts, callback) {\n  // Because fs.symlink does not allow atomic overwrite option with flags, we\n  // delete and recreate if the link already exists and overwrite is true.\n  if (opts.flags === 'w') {\n    // TODO What happens when we call unlink with windows junctions?\n    fs.unlink(destPath, onUnlink);\n  } else {\n    fs.symlink(srcPath, destPath, opts.type, onSymlink);\n  }\n\n  function onUnlink(unlinkErr) {\n    if (isFatalUnlinkError(unlinkErr)) {\n      return callback(unlinkErr);\n    }\n\n    fs.symlink(srcPath, destPath, opts.type, onSymlink);\n  }\n\n  function onSymlink(symlinkErr) {\n    if (isFatalOverwriteError(symlinkErr, opts.flags)) {\n      return callback(symlinkErr);\n    }\n\n    callback();\n  }\n}\n/*\r\n  Custom writeFile implementation because we need access to the\r\n  file descriptor after the write is complete.\r\n  Most of the implementation taken from node core.\r\n */\n\n\nfunction writeFile(filepath, data, options, callback) {\n  if (typeof options === 'function') {\n    callback = options;\n    options = {};\n  }\n\n  if (!Buffer.isBuffer(data)) {\n    return callback(new TypeError('Data must be a Buffer'));\n  }\n\n  if (!options) {\n    options = {};\n  } // Default the same as node\n\n\n  var mode = options.mode || constants.DEFAULT_FILE_MODE;\n  var flags = options.flags || 'w';\n  var position = APPEND_MODE_REGEXP.test(flags) ? null : 0;\n  fs.open(filepath, flags, mode, onOpen);\n\n  function onOpen(openErr, fd) {\n    if (openErr) {\n      return onComplete(openErr);\n    }\n\n    fs.write(fd, data, 0, data.length, position, onComplete);\n\n    function onComplete(writeErr) {\n      callback(writeErr, fd);\n    }\n  }\n}\n\nfunction createWriteStream(path, options, flush) {\n  return new WriteStream(path, options, flush);\n} // Taken from node core and altered to receive a flush function and simplified\n// To be used for cleanup (like updating times/mode/etc)\n\n\nfunction WriteStream(path, options, flush) {\n  // Not exposed so we can avoid the case where someone doesn't use `new`\n  if (typeof options === 'function') {\n    flush = options;\n    options = null;\n  }\n\n  options = options || {};\n  Writable.call(this, options);\n  this.flush = flush;\n  this.path = path;\n  this.mode = options.mode || constants.DEFAULT_FILE_MODE;\n  this.flags = options.flags || 'w'; // Used by node's `fs.WriteStream`\n\n  this.fd = null;\n  this.start = null;\n  this.open(); // Dispose on finish.\n\n  this.once('finish', this.close);\n}\n\nutil.inherits(WriteStream, Writable);\n\nWriteStream.prototype.open = function () {\n  var self = this;\n  fs.open(this.path, this.flags, this.mode, onOpen);\n\n  function onOpen(openErr, fd) {\n    if (openErr) {\n      self.destroy();\n      self.emit('error', openErr);\n      return;\n    }\n\n    self.fd = fd;\n    self.emit('open', fd);\n  }\n}; // Use our `end` method since it is patched for flush\n\n\nWriteStream.prototype.destroySoon = WriteStream.prototype.end;\n\nWriteStream.prototype._destroy = function (err, cb) {\n  this.close(function (err2) {\n    cb(err || err2);\n  });\n};\n\nWriteStream.prototype.close = function (cb) {\n  var that = this;\n\n  if (cb) {\n    this.once('close', cb);\n  }\n\n  if (this.closed || typeof this.fd !== 'number') {\n    if (typeof this.fd !== 'number') {\n      this.once('open', closeOnOpen);\n      return;\n    }\n\n    return process.nextTick(function () {\n      that.emit('close');\n    });\n  }\n\n  this.closed = true;\n  fs.close(this.fd, function (er) {\n    if (er) {\n      that.emit('error', er);\n    } else {\n      that.emit('close');\n    }\n  });\n  this.fd = null;\n};\n\nWriteStream.prototype._final = function (callback) {\n  if (typeof this.flush !== 'function') {\n    return callback();\n  }\n\n  this.flush(this.fd, callback);\n};\n\nfunction closeOnOpen() {\n  this.close();\n}\n\nWriteStream.prototype._write = function (data, encoding, callback) {\n  var self = this; // This is from node core but I have no idea how to get code coverage on it\n\n  if (!Buffer.isBuffer(data)) {\n    return this.emit('error', new Error('Invalid data'));\n  }\n\n  if (typeof this.fd !== 'number') {\n    return this.once('open', onOpen);\n  }\n\n  fs.write(this.fd, data, 0, data.length, null, onWrite);\n\n  function onOpen() {\n    self._write(data, encoding, callback);\n  }\n\n  function onWrite(writeErr) {\n    if (writeErr) {\n      self.destroy();\n      callback(writeErr);\n      return;\n    }\n\n    callback();\n  }\n};\n\nmodule.exports = {\n  closeFd: closeFd,\n  isValidUnixId: isValidUnixId,\n  getFlags: getFlags,\n  isFatalOverwriteError: isFatalOverwriteError,\n  isFatalUnlinkError: isFatalUnlinkError,\n  getModeDiff: getModeDiff,\n  getTimesDiff: getTimesDiff,\n  getOwnerDiff: getOwnerDiff,\n  isOwner: isOwner,\n  reflectStat: reflectStat,\n  reflectLinkStat: reflectLinkStat,\n  updateMetadata: updateMetadata,\n  symlink: symlink,\n  writeFile: writeFile,\n  createWriteStream: createWriteStream\n};","map":{"version":3,"sources":["C:/frontend/node_modules/vinyl-fs/lib/file-operations.js"],"names":["util","require","fs","assign","date","Writable","constants","APPEND_MODE_REGEXP","closeFd","propagatedErr","fd","callback","close","onClosed","closeErr","isValidUnixId","id","getFlags","options","flags","append","overwrite","isFatalOverwriteError","err","code","isFatalUnlinkError","getModeDiff","fsMode","vinylMode","modeDiff","MASK_MODE","getTimesDiff","fsStat","vinylStat","mtime","atime","undefined","timesDiff","getOwnerDiff","uid","gid","ownerDiff","isOwner","hasGetuid","process","getuid","hasGeteuid","geteuid","reflectStat","path","file","stat","onStat","statErr","reflectLinkStat","lstat","onLstat","lstatErr","updateMetadata","fstat","mode","times","owner","fchmod","onFchmod","fchmodErr","futimes","onFutimes","futimesErr","fchown","onFchown","fchownErr","symlink","srcPath","destPath","opts","unlink","onUnlink","type","onSymlink","unlinkErr","symlinkErr","writeFile","filepath","data","Buffer","isBuffer","TypeError","DEFAULT_FILE_MODE","position","test","open","onOpen","openErr","onComplete","write","length","writeErr","createWriteStream","flush","WriteStream","call","start","once","inherits","prototype","self","destroy","emit","destroySoon","end","_destroy","cb","err2","that","closed","closeOnOpen","nextTick","er","_final","_write","encoding","Error","onWrite","module","exports"],"mappings":"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","sourcesContent":["'use strict';\r\n\r\nvar util = require('util');\r\n\r\nvar fs = require('graceful-fs');\r\nvar assign = require('object.assign');\r\nvar date = require('value-or-function').date;\r\nvar Writable = require('readable-stream').Writable;\r\n\r\nvar constants = require('./constants');\r\n\r\nvar APPEND_MODE_REGEXP = /a/;\r\n\r\nfunction closeFd(propagatedErr, fd, callback) {\r\n  if (typeof fd !== 'number') {\r\n    return callback(propagatedErr);\r\n  }\r\n\r\n  fs.close(fd, onClosed);\r\n\r\n  function onClosed(closeErr) {\r\n    if (propagatedErr || closeErr) {\r\n      return callback(propagatedErr || closeErr);\r\n    }\r\n\r\n    callback();\r\n  }\r\n}\r\n\r\nfunction isValidUnixId(id) {\r\n  if (typeof id !== 'number') {\r\n    return false;\r\n  }\r\n\r\n  if (id < 0) {\r\n    return false;\r\n  }\r\n\r\n  return true;\r\n}\r\n\r\nfunction getFlags(options) {\r\n  var flags = !options.append ? 'w' : 'a';\r\n  if (!options.overwrite) {\r\n    flags += 'x';\r\n  }\r\n  return flags;\r\n}\r\n\r\nfunction isFatalOverwriteError(err, flags) {\r\n  if (!err) {\r\n    return false;\r\n  }\r\n\r\n  if (err.code === 'EEXIST' && flags[1] === 'x') {\r\n    // Handle scenario for file overwrite failures.\r\n    return false;\r\n  }\r\n\r\n  // Otherwise, this is a fatal error\r\n  return true;\r\n}\r\n\r\nfunction isFatalUnlinkError(err) {\r\n  if (!err || err.code === 'ENOENT') {\r\n    return false;\r\n  }\r\n\r\n  return true;\r\n}\r\n\r\nfunction getModeDiff(fsMode, vinylMode) {\r\n  var modeDiff = 0;\r\n\r\n  if (typeof vinylMode === 'number') {\r\n    modeDiff = (vinylMode ^ fsMode) & constants.MASK_MODE;\r\n  }\r\n\r\n  return modeDiff;\r\n}\r\n\r\nfunction getTimesDiff(fsStat, vinylStat) {\r\n\r\n  var mtime = date(vinylStat.mtime) || 0;\r\n  if (!mtime) {\r\n    return;\r\n  }\r\n\r\n  var atime = date(vinylStat.atime) || 0;\r\n  if (+mtime === +fsStat.mtime &&\r\n      +atime === +fsStat.atime) {\r\n    return;\r\n  }\r\n\r\n  if (!atime) {\r\n    atime = date(fsStat.atime) || undefined;\r\n  }\r\n\r\n  var timesDiff = {\r\n    mtime: vinylStat.mtime,\r\n    atime: atime,\r\n  };\r\n\r\n  return timesDiff;\r\n}\r\n\r\nfunction getOwnerDiff(fsStat, vinylStat) {\r\n  if (!isValidUnixId(vinylStat.uid) &&\r\n      !isValidUnixId(vinylStat.gid)) {\r\n    return;\r\n  }\r\n\r\n  if ((!isValidUnixId(fsStat.uid) && !isValidUnixId(vinylStat.uid)) ||\r\n      (!isValidUnixId(fsStat.gid) && !isValidUnixId(vinylStat.gid))) {\r\n    return;\r\n  }\r\n\r\n  var uid = fsStat.uid; // Default to current uid.\r\n  if (isValidUnixId(vinylStat.uid)) {\r\n    uid = vinylStat.uid;\r\n  }\r\n\r\n  var gid = fsStat.gid; // Default to current gid.\r\n  if (isValidUnixId(vinylStat.gid)) {\r\n    gid = vinylStat.gid;\r\n  }\r\n\r\n  if (uid === fsStat.uid &&\r\n      gid === fsStat.gid) {\r\n    return;\r\n  }\r\n\r\n  var ownerDiff = {\r\n    uid: uid,\r\n    gid: gid,\r\n  };\r\n\r\n  return ownerDiff;\r\n}\r\n\r\nfunction isOwner(fsStat) {\r\n  var hasGetuid = (typeof process.getuid === 'function');\r\n  var hasGeteuid = (typeof process.geteuid === 'function');\r\n\r\n  // If we don't have either, assume we don't have permissions.\r\n  // This should only happen on Windows.\r\n  // Windows basically noops fchmod and errors on futimes called on directories.\r\n  if (!hasGeteuid && !hasGetuid) {\r\n    return false;\r\n  }\r\n\r\n  var uid;\r\n  if (hasGeteuid) {\r\n    uid = process.geteuid();\r\n  } else {\r\n    uid = process.getuid();\r\n  }\r\n\r\n  if (fsStat.uid !== uid && uid !== 0) {\r\n    return false;\r\n  }\r\n\r\n  return true;\r\n}\r\n\r\nfunction reflectStat(path, file, callback) {\r\n  // Set file.stat to the reflect current state on disk\r\n  fs.stat(path, onStat);\r\n\r\n  function onStat(statErr, stat) {\r\n    if (statErr) {\r\n      return callback(statErr);\r\n    }\r\n\r\n    file.stat = stat;\r\n    callback();\r\n  }\r\n}\r\n\r\nfunction reflectLinkStat(path, file, callback) {\r\n  // Set file.stat to the reflect current state on disk\r\n  fs.lstat(path, onLstat);\r\n\r\n  function onLstat(lstatErr, stat) {\r\n    if (lstatErr) {\r\n      return callback(lstatErr);\r\n    }\r\n\r\n    file.stat = stat;\r\n    callback();\r\n  }\r\n}\r\n\r\nfunction updateMetadata(fd, file, callback) {\r\n\r\n  fs.fstat(fd, onStat);\r\n\r\n  function onStat(statErr, stat) {\r\n    if (statErr) {\r\n      return callback(statErr);\r\n    }\r\n\r\n    // Check if mode needs to be updated\r\n    var modeDiff = getModeDiff(stat.mode, file.stat.mode);\r\n\r\n    // Check if atime/mtime need to be updated\r\n    var timesDiff = getTimesDiff(stat, file.stat);\r\n\r\n    // Check if uid/gid need to be updated\r\n    var ownerDiff = getOwnerDiff(stat, file.stat);\r\n\r\n    // Set file.stat to the reflect current state on disk\r\n    assign(file.stat, stat);\r\n\r\n    // Nothing to do\r\n    if (!modeDiff && !timesDiff && !ownerDiff) {\r\n      return callback();\r\n    }\r\n\r\n    // Check access, `futimes`, `fchmod` & `fchown` only work if we own\r\n    // the file, or if we are effectively root (`fchown` only when root).\r\n    if (!isOwner(stat)) {\r\n      return callback();\r\n    }\r\n\r\n    if (modeDiff) {\r\n      return mode();\r\n    }\r\n    if (timesDiff) {\r\n      return times();\r\n    }\r\n    owner();\r\n\r\n    function mode() {\r\n      var mode = stat.mode ^ modeDiff;\r\n\r\n      fs.fchmod(fd, mode, onFchmod);\r\n\r\n      function onFchmod(fchmodErr) {\r\n        if (!fchmodErr) {\r\n          file.stat.mode = mode;\r\n        }\r\n        if (timesDiff) {\r\n          return times(fchmodErr);\r\n        }\r\n        if (ownerDiff) {\r\n          return owner(fchmodErr);\r\n        }\r\n        callback(fchmodErr);\r\n      }\r\n    }\r\n\r\n    function times(propagatedErr) {\r\n      fs.futimes(fd, timesDiff.atime, timesDiff.mtime, onFutimes);\r\n\r\n      function onFutimes(futimesErr) {\r\n        if (!futimesErr) {\r\n          file.stat.atime = timesDiff.atime;\r\n          file.stat.mtime = timesDiff.mtime;\r\n        }\r\n        if (ownerDiff) {\r\n          return owner(propagatedErr || futimesErr);\r\n        }\r\n        callback(propagatedErr || futimesErr);\r\n      }\r\n    }\r\n\r\n    function owner(propagatedErr) {\r\n      fs.fchown(fd, ownerDiff.uid, ownerDiff.gid, onFchown);\r\n\r\n      function onFchown(fchownErr) {\r\n        if (!fchownErr) {\r\n          file.stat.uid = ownerDiff.uid;\r\n          file.stat.gid = ownerDiff.gid;\r\n        }\r\n        callback(propagatedErr || fchownErr);\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\nfunction symlink(srcPath, destPath, opts, callback) {\r\n  // Because fs.symlink does not allow atomic overwrite option with flags, we\r\n  // delete and recreate if the link already exists and overwrite is true.\r\n  if (opts.flags === 'w') {\r\n    // TODO What happens when we call unlink with windows junctions?\r\n    fs.unlink(destPath, onUnlink);\r\n  } else {\r\n    fs.symlink(srcPath, destPath, opts.type, onSymlink);\r\n  }\r\n\r\n  function onUnlink(unlinkErr) {\r\n    if (isFatalUnlinkError(unlinkErr)) {\r\n      return callback(unlinkErr);\r\n    }\r\n    fs.symlink(srcPath, destPath, opts.type, onSymlink);\r\n  }\r\n\r\n  function onSymlink(symlinkErr) {\r\n    if (isFatalOverwriteError(symlinkErr, opts.flags)) {\r\n      return callback(symlinkErr);\r\n    }\r\n    callback();\r\n  }\r\n}\r\n\r\n/*\r\n  Custom writeFile implementation because we need access to the\r\n  file descriptor after the write is complete.\r\n  Most of the implementation taken from node core.\r\n */\r\nfunction writeFile(filepath, data, options, callback) {\r\n  if (typeof options === 'function') {\r\n    callback = options;\r\n    options = {};\r\n  }\r\n\r\n  if (!Buffer.isBuffer(data)) {\r\n    return callback(new TypeError('Data must be a Buffer'));\r\n  }\r\n\r\n  if (!options) {\r\n    options = {};\r\n  }\r\n\r\n  // Default the same as node\r\n  var mode = options.mode || constants.DEFAULT_FILE_MODE;\r\n  var flags = options.flags || 'w';\r\n  var position = APPEND_MODE_REGEXP.test(flags) ? null : 0;\r\n\r\n  fs.open(filepath, flags, mode, onOpen);\r\n\r\n  function onOpen(openErr, fd) {\r\n    if (openErr) {\r\n      return onComplete(openErr);\r\n    }\r\n\r\n    fs.write(fd, data, 0, data.length, position, onComplete);\r\n\r\n    function onComplete(writeErr) {\r\n      callback(writeErr, fd);\r\n    }\r\n  }\r\n}\r\n\r\nfunction createWriteStream(path, options, flush) {\r\n  return new WriteStream(path, options, flush);\r\n}\r\n\r\n// Taken from node core and altered to receive a flush function and simplified\r\n// To be used for cleanup (like updating times/mode/etc)\r\nfunction WriteStream(path, options, flush) {\r\n  // Not exposed so we can avoid the case where someone doesn't use `new`\r\n\r\n  if (typeof options === 'function') {\r\n    flush = options;\r\n    options = null;\r\n  }\r\n\r\n  options = options || {};\r\n\r\n  Writable.call(this, options);\r\n\r\n  this.flush = flush;\r\n  this.path = path;\r\n\r\n  this.mode = options.mode || constants.DEFAULT_FILE_MODE;\r\n  this.flags = options.flags || 'w';\r\n\r\n  // Used by node's `fs.WriteStream`\r\n  this.fd = null;\r\n  this.start = null;\r\n\r\n  this.open();\r\n\r\n  // Dispose on finish.\r\n  this.once('finish', this.close);\r\n}\r\n\r\nutil.inherits(WriteStream, Writable);\r\n\r\nWriteStream.prototype.open = function() {\r\n  var self = this;\r\n\r\n  fs.open(this.path, this.flags, this.mode, onOpen);\r\n\r\n  function onOpen(openErr, fd) {\r\n    if (openErr) {\r\n      self.destroy();\r\n      self.emit('error', openErr);\r\n      return;\r\n    }\r\n\r\n    self.fd = fd;\r\n    self.emit('open', fd);\r\n  }\r\n};\r\n\r\n// Use our `end` method since it is patched for flush\r\nWriteStream.prototype.destroySoon = WriteStream.prototype.end;\r\n\r\nWriteStream.prototype._destroy = function(err, cb) {\r\n  this.close(function(err2) {\r\n    cb(err || err2);\r\n  });\r\n};\r\n\r\nWriteStream.prototype.close = function(cb) {\r\n  var that = this;\r\n\r\n  if (cb) {\r\n    this.once('close', cb);\r\n  }\r\n\r\n  if (this.closed || typeof this.fd !== 'number') {\r\n    if (typeof this.fd !== 'number') {\r\n      this.once('open', closeOnOpen);\r\n      return;\r\n    }\r\n\r\n    return process.nextTick(function() {\r\n      that.emit('close');\r\n    });\r\n  }\r\n\r\n  this.closed = true;\r\n\r\n  fs.close(this.fd, function(er) {\r\n    if (er) {\r\n      that.emit('error', er);\r\n    } else {\r\n      that.emit('close');\r\n    }\r\n  });\r\n\r\n  this.fd = null;\r\n};\r\n\r\nWriteStream.prototype._final = function(callback) {\r\n  if (typeof this.flush !== 'function') {\r\n    return callback();\r\n  }\r\n\r\n  this.flush(this.fd, callback);\r\n};\r\n\r\nfunction closeOnOpen() {\r\n  this.close();\r\n}\r\n\r\nWriteStream.prototype._write = function(data, encoding, callback) {\r\n  var self = this;\r\n\r\n  // This is from node core but I have no idea how to get code coverage on it\r\n  if (!Buffer.isBuffer(data)) {\r\n    return this.emit('error', new Error('Invalid data'));\r\n  }\r\n\r\n  if (typeof this.fd !== 'number') {\r\n    return this.once('open', onOpen);\r\n  }\r\n\r\n  fs.write(this.fd, data, 0, data.length, null, onWrite);\r\n\r\n  function onOpen() {\r\n    self._write(data, encoding, callback);\r\n  }\r\n\r\n  function onWrite(writeErr) {\r\n    if (writeErr) {\r\n      self.destroy();\r\n      callback(writeErr);\r\n      return;\r\n    }\r\n\r\n    callback();\r\n  }\r\n};\r\n\r\nmodule.exports = {\r\n  closeFd: closeFd,\r\n  isValidUnixId: isValidUnixId,\r\n  getFlags: getFlags,\r\n  isFatalOverwriteError: isFatalOverwriteError,\r\n  isFatalUnlinkError: isFatalUnlinkError,\r\n  getModeDiff: getModeDiff,\r\n  getTimesDiff: getTimesDiff,\r\n  getOwnerDiff: getOwnerDiff,\r\n  isOwner: isOwner,\r\n  reflectStat: reflectStat,\r\n  reflectLinkStat: reflectLinkStat,\r\n  updateMetadata: updateMetadata,\r\n  symlink: symlink,\r\n  writeFile: writeFile,\r\n  createWriteStream: createWriteStream,\r\n};\r\n"]},"metadata":{},"sourceType":"script"}