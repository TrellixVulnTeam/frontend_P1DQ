{"ast":null,"code":"'use strict';\n\nvar chokidar = require('chokidar');\n\nvar debounce = require('just-debounce');\n\nvar asyncDone = require('async-done');\n\nvar defaults = require('object.defaults/immutable');\n\nvar isNegatedGlob = require('is-negated-glob');\n\nvar anymatch = require('anymatch');\n\nvar normalize = require('normalize-path');\n\nvar defaultOpts = {\n  delay: 200,\n  events: ['add', 'change', 'unlink'],\n  ignored: [],\n  ignoreInitial: true,\n  queue: true\n};\n\nfunction listenerCount(ee, evtName) {\n  if (typeof ee.listenerCount === 'function') {\n    return ee.listenerCount(evtName);\n  }\n\n  return ee.listeners(evtName).length;\n}\n\nfunction hasErrorListener(ee) {\n  return listenerCount(ee, 'error') !== 0;\n}\n\nfunction exists(val) {\n  return val != null;\n}\n\nfunction watch(glob, options, cb) {\n  if (typeof options === 'function') {\n    cb = options;\n    options = {};\n  }\n\n  var opt = defaults(options, defaultOpts);\n\n  if (!Array.isArray(opt.events)) {\n    opt.events = [opt.events];\n  }\n\n  if (Array.isArray(glob)) {\n    // We slice so we don't mutate the passed globs array\n    glob = glob.slice();\n  } else {\n    glob = [glob];\n  }\n\n  var queued = false;\n  var running = false; // These use sparse arrays to keep track of the index in the\n  // original globs array\n\n  var positives = new Array(glob.length);\n  var negatives = new Array(glob.length); // Reverse the glob here so we don't end up with a positive\n  // and negative glob in position 0 after a reverse\n\n  glob.reverse().forEach(sortGlobs);\n\n  function sortGlobs(globString, index) {\n    var result = isNegatedGlob(globString);\n\n    if (result.negated) {\n      negatives[index] = result.pattern;\n    } else {\n      positives[index] = result.pattern;\n    }\n  }\n\n  var toWatch = positives.filter(exists);\n\n  function joinCwd(glob) {\n    if (glob && opt.cwd) {\n      return normalize(opt.cwd + '/' + glob);\n    }\n\n    return glob;\n  } // We only do add our custom `ignored` if there are some negative globs\n  // TODO: I'm not sure how to test this\n\n\n  if (negatives.some(exists)) {\n    var normalizedPositives = positives.map(joinCwd);\n    var normalizedNegatives = negatives.map(joinCwd);\n\n    var shouldBeIgnored = function (path) {\n      var positiveMatch = anymatch(normalizedPositives, path, true);\n      var negativeMatch = anymatch(normalizedNegatives, path, true); // If negativeMatch is -1, that means it was never negated\n\n      if (negativeMatch === -1) {\n        return false;\n      } // If the negative is \"less than\" the positive, that means\n      // it came later in the glob array before we reversed them\n\n\n      return negativeMatch < positiveMatch;\n    };\n\n    opt.ignored = [].concat(opt.ignored, shouldBeIgnored);\n  }\n\n  var watcher = chokidar.watch(toWatch, opt);\n\n  function runComplete(err) {\n    running = false;\n\n    if (err && hasErrorListener(watcher)) {\n      watcher.emit('error', err);\n    } // If we have a run queued, start onChange again\n\n\n    if (queued) {\n      queued = false;\n      onChange();\n    }\n  }\n\n  function onChange() {\n    if (running) {\n      if (opt.queue) {\n        queued = true;\n      }\n\n      return;\n    }\n\n    running = true;\n    asyncDone(cb, runComplete);\n  }\n\n  var fn;\n\n  if (typeof cb === 'function') {\n    fn = debounce(onChange, opt.delay);\n  }\n\n  function watchEvent(eventName) {\n    watcher.on(eventName, fn);\n  }\n\n  if (fn) {\n    opt.events.forEach(watchEvent);\n  }\n\n  return watcher;\n}\n\nmodule.exports = watch;","map":{"version":3,"sources":["C:/frontend/node_modules/glob-watcher/index.js"],"names":["chokidar","require","debounce","asyncDone","defaults","isNegatedGlob","anymatch","normalize","defaultOpts","delay","events","ignored","ignoreInitial","queue","listenerCount","ee","evtName","listeners","length","hasErrorListener","exists","val","watch","glob","options","cb","opt","Array","isArray","slice","queued","running","positives","negatives","reverse","forEach","sortGlobs","globString","index","result","negated","pattern","toWatch","filter","joinCwd","cwd","some","normalizedPositives","map","normalizedNegatives","shouldBeIgnored","path","positiveMatch","negativeMatch","concat","watcher","runComplete","err","emit","onChange","fn","watchEvent","eventName","on","module","exports"],"mappings":"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","sourcesContent":["'use strict';\r\n\r\nvar chokidar = require('chokidar');\r\nvar debounce = require('just-debounce');\r\nvar asyncDone = require('async-done');\r\nvar defaults = require('object.defaults/immutable');\r\nvar isNegatedGlob = require('is-negated-glob');\r\nvar anymatch = require('anymatch');\r\nvar normalize = require('normalize-path');\r\n\r\nvar defaultOpts = {\r\n  delay: 200,\r\n  events: ['add', 'change', 'unlink'],\r\n  ignored: [],\r\n  ignoreInitial: true,\r\n  queue: true,\r\n};\r\n\r\nfunction listenerCount(ee, evtName) {\r\n  if (typeof ee.listenerCount === 'function') {\r\n    return ee.listenerCount(evtName);\r\n  }\r\n\r\n  return ee.listeners(evtName).length;\r\n}\r\n\r\nfunction hasErrorListener(ee) {\r\n  return listenerCount(ee, 'error') !== 0;\r\n}\r\n\r\nfunction exists(val) {\r\n  return val != null;\r\n}\r\n\r\nfunction watch(glob, options, cb) {\r\n  if (typeof options === 'function') {\r\n    cb = options;\r\n    options = {};\r\n  }\r\n\r\n  var opt = defaults(options, defaultOpts);\r\n\r\n  if (!Array.isArray(opt.events)) {\r\n    opt.events = [opt.events];\r\n  }\r\n\r\n  if (Array.isArray(glob)) {\r\n    // We slice so we don't mutate the passed globs array\r\n    glob = glob.slice();\r\n  } else {\r\n    glob = [glob];\r\n  }\r\n\r\n  var queued = false;\r\n  var running = false;\r\n\r\n  // These use sparse arrays to keep track of the index in the\r\n  // original globs array\r\n  var positives = new Array(glob.length);\r\n  var negatives = new Array(glob.length);\r\n\r\n  // Reverse the glob here so we don't end up with a positive\r\n  // and negative glob in position 0 after a reverse\r\n  glob.reverse().forEach(sortGlobs);\r\n\r\n  function sortGlobs(globString, index) {\r\n    var result = isNegatedGlob(globString);\r\n    if (result.negated) {\r\n      negatives[index] = result.pattern;\r\n    } else {\r\n      positives[index] = result.pattern;\r\n    }\r\n  }\r\n\r\n  var toWatch = positives.filter(exists);\r\n\r\n  function joinCwd(glob) {\r\n    if (glob && opt.cwd) {\r\n      return normalize(opt.cwd + '/' + glob);\r\n    }\r\n\r\n    return glob;\r\n  }\r\n\r\n  // We only do add our custom `ignored` if there are some negative globs\r\n  // TODO: I'm not sure how to test this\r\n  if (negatives.some(exists)) {\r\n    var normalizedPositives = positives.map(joinCwd);\r\n    var normalizedNegatives = negatives.map(joinCwd);\r\n    var shouldBeIgnored = function(path) {\r\n      var positiveMatch = anymatch(normalizedPositives, path, true);\r\n      var negativeMatch = anymatch(normalizedNegatives, path, true);\r\n      // If negativeMatch is -1, that means it was never negated\r\n      if (negativeMatch === -1) {\r\n        return false;\r\n      }\r\n\r\n      // If the negative is \"less than\" the positive, that means\r\n      // it came later in the glob array before we reversed them\r\n      return negativeMatch < positiveMatch;\r\n    };\r\n\r\n    opt.ignored = [].concat(opt.ignored, shouldBeIgnored);\r\n  }\r\n  var watcher = chokidar.watch(toWatch, opt);\r\n\r\n  function runComplete(err) {\r\n    running = false;\r\n\r\n    if (err && hasErrorListener(watcher)) {\r\n      watcher.emit('error', err);\r\n    }\r\n\r\n    // If we have a run queued, start onChange again\r\n    if (queued) {\r\n      queued = false;\r\n      onChange();\r\n    }\r\n  }\r\n\r\n  function onChange() {\r\n    if (running) {\r\n      if (opt.queue) {\r\n        queued = true;\r\n      }\r\n      return;\r\n    }\r\n\r\n    running = true;\r\n    asyncDone(cb, runComplete);\r\n  }\r\n\r\n  var fn;\r\n  if (typeof cb === 'function') {\r\n    fn = debounce(onChange, opt.delay);\r\n  }\r\n\r\n  function watchEvent(eventName) {\r\n    watcher.on(eventName, fn);\r\n  }\r\n\r\n  if (fn) {\r\n    opt.events.forEach(watchEvent);\r\n  }\r\n\r\n  return watcher;\r\n}\r\n\r\nmodule.exports = watch;\r\n"]},"metadata":{},"sourceType":"script"}