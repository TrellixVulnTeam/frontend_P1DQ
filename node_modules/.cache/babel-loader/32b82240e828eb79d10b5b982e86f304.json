{"ast":null,"code":"'use strict';\n\nvar normalize = require('value-or-function');\n\nvar slice = Array.prototype.slice;\n\nfunction createResolver(config, options) {\n  // TODO: should the config object be validated?\n  config = config || {};\n  options = options || {};\n  var resolver = {\n    resolve: resolve\n  }; // Keep constants separately\n\n  var constants = {};\n\n  function resolveConstant(key) {\n    if (constants.hasOwnProperty(key)) {\n      return constants[key];\n    }\n\n    var definition = config[key]; // Ignore options that are not defined\n\n    if (!definition) {\n      return;\n    }\n\n    var option = options[key];\n\n    if (option != null) {\n      if (typeof option === 'function') {\n        return;\n      }\n\n      option = normalize.call(resolver, definition.type, option);\n\n      if (option != null) {\n        constants[key] = option;\n        return option;\n      }\n    }\n\n    var fallback = definition.default;\n\n    if (option == null && typeof fallback !== 'function') {\n      constants[key] = fallback;\n      return fallback;\n    }\n  } // Keep requested keys to detect (and disallow) recursive resolution\n\n\n  var stack = [];\n\n  function resolve(key) {\n    var option = resolveConstant(key);\n\n    if (option != null) {\n      return option;\n    }\n\n    var definition = config[key]; // Ignore options that are not defined\n\n    if (!definition) {\n      return;\n    }\n\n    if (stack.indexOf(key) >= 0) {\n      throw new Error('Recursive resolution denied.');\n    }\n\n    option = options[key];\n    var fallback = definition.default;\n    var appliedArgs = slice.call(arguments, 1);\n    var args = [definition.type, option].concat(appliedArgs);\n\n    function toResolve() {\n      stack.push(key);\n      var option = normalize.apply(resolver, args);\n\n      if (option == null) {\n        option = fallback;\n\n        if (typeof option === 'function') {\n          option = option.apply(resolver, appliedArgs);\n        }\n      }\n\n      return option;\n    }\n\n    function onResolve() {\n      stack.pop();\n    }\n\n    return tryResolve(toResolve, onResolve);\n  }\n\n  return resolver;\n}\n\nfunction tryResolve(toResolve, onResolve) {\n  try {\n    return toResolve();\n  } finally {\n    onResolve();\n  }\n}\n\nmodule.exports = createResolver;","map":{"version":3,"sources":["C:/frontend/node_modules/resolve-options/index.js"],"names":["normalize","require","slice","Array","prototype","createResolver","config","options","resolver","resolve","constants","resolveConstant","key","hasOwnProperty","definition","option","call","type","fallback","default","stack","indexOf","Error","appliedArgs","arguments","args","concat","toResolve","push","apply","onResolve","pop","tryResolve","module","exports"],"mappings":"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","sourcesContent":["'use strict';\r\n\r\nvar normalize = require('value-or-function');\r\n\r\nvar slice = Array.prototype.slice;\r\n\r\nfunction createResolver(config, options) {\r\n  // TODO: should the config object be validated?\r\n  config = config || {};\r\n  options = options || {};\r\n\r\n  var resolver = {\r\n    resolve: resolve,\r\n  };\r\n\r\n\r\n  // Keep constants separately\r\n  var constants = {};\r\n\r\n  function resolveConstant(key) {\r\n    if (constants.hasOwnProperty(key)) {\r\n      return constants[key];\r\n    }\r\n\r\n    var definition = config[key];\r\n    // Ignore options that are not defined\r\n    if (!definition) {\r\n      return;\r\n    }\r\n\r\n    var option = options[key];\r\n\r\n    if (option != null) {\r\n      if (typeof option === 'function') {\r\n        return;\r\n      }\r\n      option = normalize.call(resolver, definition.type, option);\r\n      if (option != null) {\r\n        constants[key] = option;\r\n        return option;\r\n      }\r\n    }\r\n\r\n    var fallback = definition.default;\r\n    if (option == null && typeof fallback !== 'function') {\r\n      constants[key] = fallback;\r\n      return fallback;\r\n    }\r\n  }\r\n\r\n\r\n  // Keep requested keys to detect (and disallow) recursive resolution\r\n  var stack = [];\r\n\r\n  function resolve(key) {\r\n    var option = resolveConstant(key);\r\n    if (option != null) {\r\n      return option;\r\n    }\r\n\r\n    var definition = config[key];\r\n    // Ignore options that are not defined\r\n    if (!definition) {\r\n      return;\r\n    }\r\n\r\n    if (stack.indexOf(key) >= 0) {\r\n      throw new Error('Recursive resolution denied.');\r\n    }\r\n\r\n    option = options[key];\r\n    var fallback = definition.default;\r\n    var appliedArgs = slice.call(arguments, 1);\r\n    var args = [definition.type, option].concat(appliedArgs);\r\n\r\n    function toResolve() {\r\n      stack.push(key);\r\n      var option = normalize.apply(resolver, args);\r\n\r\n      if (option == null) {\r\n        option = fallback;\r\n        if (typeof option === 'function') {\r\n          option = option.apply(resolver, appliedArgs);\r\n        }\r\n      }\r\n\r\n      return option;\r\n    }\r\n\r\n    function onResolve() {\r\n      stack.pop();\r\n    }\r\n\r\n    return tryResolve(toResolve, onResolve);\r\n  }\r\n\r\n\r\n  return resolver;\r\n}\r\n\r\n\r\nfunction tryResolve(toResolve, onResolve) {\r\n  try {\r\n    return toResolve();\r\n  } finally {\r\n    onResolve();\r\n  }\r\n}\r\n\r\n\r\nmodule.exports = createResolver;\r\n"]},"metadata":{},"sourceType":"script"}