{"ast":null,"code":"'use strict';\n\nvar Combine = require('ordered-read-streams');\n\nvar unique = require('unique-stream');\n\nvar pumpify = require('pumpify');\n\nvar isNegatedGlob = require('is-negated-glob');\n\nvar extend = require('extend');\n\nvar GlobStream = require('./readable');\n\nfunction globStream(globs, opt) {\n  if (!opt) {\n    opt = {};\n  }\n\n  var ourOpt = extend({}, opt);\n  var ignore = ourOpt.ignore;\n  ourOpt.cwd = typeof ourOpt.cwd === 'string' ? ourOpt.cwd : process.cwd();\n  ourOpt.dot = typeof ourOpt.dot === 'boolean' ? ourOpt.dot : false;\n  ourOpt.silent = typeof ourOpt.silent === 'boolean' ? ourOpt.silent : true;\n  ourOpt.cwdbase = typeof ourOpt.cwdbase === 'boolean' ? ourOpt.cwdbase : false;\n  ourOpt.uniqueBy = typeof ourOpt.uniqueBy === 'string' || typeof ourOpt.uniqueBy === 'function' ? ourOpt.uniqueBy : 'path';\n\n  if (ourOpt.cwdbase) {\n    ourOpt.base = ourOpt.cwd;\n  } // Normalize string `ignore` to array\n\n\n  if (typeof ignore === 'string') {\n    ignore = [ignore];\n  } // Ensure `ignore` is an array\n\n\n  if (!Array.isArray(ignore)) {\n    ignore = [];\n  } // Only one glob no need to aggregate\n\n\n  if (!Array.isArray(globs)) {\n    globs = [globs];\n  }\n\n  var positives = [];\n  var negatives = [];\n  globs.forEach(sortGlobs);\n\n  function sortGlobs(globString, index) {\n    if (typeof globString !== 'string') {\n      throw new Error('Invalid glob at index ' + index);\n    }\n\n    var glob = isNegatedGlob(globString);\n    var globArray = glob.negated ? negatives : positives;\n    globArray.push({\n      index: index,\n      glob: glob.pattern\n    });\n  }\n\n  if (positives.length === 0) {\n    throw new Error('Missing positive glob');\n  } // Create all individual streams\n\n\n  var streams = positives.map(streamFromPositive); // Then just pipe them to a single unique stream and return it\n\n  var aggregate = new Combine(streams);\n  var uniqueStream = unique(ourOpt.uniqueBy);\n  return pumpify.obj(aggregate, uniqueStream);\n\n  function streamFromPositive(positive) {\n    var negativeGlobs = negatives.filter(indexGreaterThan(positive.index)).map(toGlob).concat(ignore);\n    return new GlobStream(positive.glob, negativeGlobs, ourOpt);\n  }\n}\n\nfunction indexGreaterThan(index) {\n  return function (obj) {\n    return obj.index > index;\n  };\n}\n\nfunction toGlob(obj) {\n  return obj.glob;\n}\n\nmodule.exports = globStream;","map":{"version":3,"sources":["C:/frontend/node_modules/glob-stream/index.js"],"names":["Combine","require","unique","pumpify","isNegatedGlob","extend","GlobStream","globStream","globs","opt","ourOpt","ignore","cwd","process","dot","silent","cwdbase","uniqueBy","base","Array","isArray","positives","negatives","forEach","sortGlobs","globString","index","Error","glob","globArray","negated","push","pattern","length","streams","map","streamFromPositive","aggregate","uniqueStream","obj","positive","negativeGlobs","filter","indexGreaterThan","toGlob","concat","module","exports"],"mappings":"AAAA;;AAEA,IAAIA,OAAO,GAAGC,OAAO,CAAC,sBAAD,CAArB;;AACA,IAAIC,MAAM,GAAGD,OAAO,CAAC,eAAD,CAApB;;AACA,IAAIE,OAAO,GAAGF,OAAO,CAAC,SAAD,CAArB;;AACA,IAAIG,aAAa,GAAGH,OAAO,CAAC,iBAAD,CAA3B;;AACA,IAAII,MAAM,GAAGJ,OAAO,CAAC,QAAD,CAApB;;AAEA,IAAIK,UAAU,GAAGL,OAAO,CAAC,YAAD,CAAxB;;AAEA,SAASM,UAAT,CAAoBC,KAApB,EAA2BC,GAA3B,EAAgC;AAC9B,MAAI,CAACA,GAAL,EAAU;AACRA,IAAAA,GAAG,GAAG,EAAN;AACD;;AAED,MAAIC,MAAM,GAAGL,MAAM,CAAC,EAAD,EAAKI,GAAL,CAAnB;AACA,MAAIE,MAAM,GAAGD,MAAM,CAACC,MAApB;AAEAD,EAAAA,MAAM,CAACE,GAAP,GAAa,OAAOF,MAAM,CAACE,GAAd,KAAsB,QAAtB,GAAiCF,MAAM,CAACE,GAAxC,GAA8CC,OAAO,CAACD,GAAR,EAA3D;AACAF,EAAAA,MAAM,CAACI,GAAP,GAAa,OAAOJ,MAAM,CAACI,GAAd,KAAsB,SAAtB,GAAkCJ,MAAM,CAACI,GAAzC,GAA+C,KAA5D;AACAJ,EAAAA,MAAM,CAACK,MAAP,GAAgB,OAAOL,MAAM,CAACK,MAAd,KAAyB,SAAzB,GAAqCL,MAAM,CAACK,MAA5C,GAAqD,IAArE;AACAL,EAAAA,MAAM,CAACM,OAAP,GAAiB,OAAON,MAAM,CAACM,OAAd,KAA0B,SAA1B,GAAsCN,MAAM,CAACM,OAA7C,GAAuD,KAAxE;AACAN,EAAAA,MAAM,CAACO,QAAP,GAAmB,OAAOP,MAAM,CAACO,QAAd,KAA2B,QAA3B,IACD,OAAOP,MAAM,CAACO,QAAd,KAA2B,UAD1B,GACuCP,MAAM,CAACO,QAD9C,GACyD,MAD5E;;AAGA,MAAIP,MAAM,CAACM,OAAX,EAAoB;AAClBN,IAAAA,MAAM,CAACQ,IAAP,GAAcR,MAAM,CAACE,GAArB;AACD,GAjB6B,CAkB9B;;;AACA,MAAI,OAAOD,MAAP,KAAkB,QAAtB,EAAgC;AAC9BA,IAAAA,MAAM,GAAG,CAACA,MAAD,CAAT;AACD,GArB6B,CAsB9B;;;AACA,MAAI,CAACQ,KAAK,CAACC,OAAN,CAAcT,MAAd,CAAL,EAA4B;AAC1BA,IAAAA,MAAM,GAAG,EAAT;AACD,GAzB6B,CA2B9B;;;AACA,MAAI,CAACQ,KAAK,CAACC,OAAN,CAAcZ,KAAd,CAAL,EAA2B;AACzBA,IAAAA,KAAK,GAAG,CAACA,KAAD,CAAR;AACD;;AAED,MAAIa,SAAS,GAAG,EAAhB;AACA,MAAIC,SAAS,GAAG,EAAhB;AAEAd,EAAAA,KAAK,CAACe,OAAN,CAAcC,SAAd;;AAEA,WAASA,SAAT,CAAmBC,UAAnB,EAA+BC,KAA/B,EAAsC;AACpC,QAAI,OAAOD,UAAP,KAAsB,QAA1B,EAAoC;AAClC,YAAM,IAAIE,KAAJ,CAAU,2BAA2BD,KAArC,CAAN;AACD;;AAED,QAAIE,IAAI,GAAGxB,aAAa,CAACqB,UAAD,CAAxB;AACA,QAAII,SAAS,GAAGD,IAAI,CAACE,OAAL,GAAeR,SAAf,GAA2BD,SAA3C;AAEAQ,IAAAA,SAAS,CAACE,IAAV,CAAe;AACbL,MAAAA,KAAK,EAAEA,KADM;AAEbE,MAAAA,IAAI,EAAEA,IAAI,CAACI;AAFE,KAAf;AAID;;AAED,MAAIX,SAAS,CAACY,MAAV,KAAqB,CAAzB,EAA4B;AAC1B,UAAM,IAAIN,KAAJ,CAAU,uBAAV,CAAN;AACD,GArD6B,CAuD9B;;;AACA,MAAIO,OAAO,GAAGb,SAAS,CAACc,GAAV,CAAcC,kBAAd,CAAd,CAxD8B,CA0D9B;;AACA,MAAIC,SAAS,GAAG,IAAIrC,OAAJ,CAAYkC,OAAZ,CAAhB;AACA,MAAII,YAAY,GAAGpC,MAAM,CAACQ,MAAM,CAACO,QAAR,CAAzB;AAEA,SAAOd,OAAO,CAACoC,GAAR,CAAYF,SAAZ,EAAuBC,YAAvB,CAAP;;AAEA,WAASF,kBAAT,CAA4BI,QAA5B,EAAsC;AACpC,QAAIC,aAAa,GAAGnB,SAAS,CAC1BoB,MADiB,CACVC,gBAAgB,CAACH,QAAQ,CAACd,KAAV,CADN,EAEjBS,GAFiB,CAEbS,MAFa,EAGjBC,MAHiB,CAGVlC,MAHU,CAApB;AAIA,WAAO,IAAIL,UAAJ,CAAekC,QAAQ,CAACZ,IAAxB,EAA8Ba,aAA9B,EAA6C/B,MAA7C,CAAP;AACD;AACF;;AAED,SAASiC,gBAAT,CAA0BjB,KAA1B,EAAiC;AAC/B,SAAO,UAASa,GAAT,EAAc;AACnB,WAAOA,GAAG,CAACb,KAAJ,GAAYA,KAAnB;AACD,GAFD;AAGD;;AAED,SAASkB,MAAT,CAAgBL,GAAhB,EAAqB;AACnB,SAAOA,GAAG,CAACX,IAAX;AACD;;AAEDkB,MAAM,CAACC,OAAP,GAAiBxC,UAAjB","sourcesContent":["'use strict';\r\n\r\nvar Combine = require('ordered-read-streams');\r\nvar unique = require('unique-stream');\r\nvar pumpify = require('pumpify');\r\nvar isNegatedGlob = require('is-negated-glob');\r\nvar extend = require('extend');\r\n\r\nvar GlobStream = require('./readable');\r\n\r\nfunction globStream(globs, opt) {\r\n  if (!opt) {\r\n    opt = {};\r\n  }\r\n\r\n  var ourOpt = extend({}, opt);\r\n  var ignore = ourOpt.ignore;\r\n\r\n  ourOpt.cwd = typeof ourOpt.cwd === 'string' ? ourOpt.cwd : process.cwd();\r\n  ourOpt.dot = typeof ourOpt.dot === 'boolean' ? ourOpt.dot : false;\r\n  ourOpt.silent = typeof ourOpt.silent === 'boolean' ? ourOpt.silent : true;\r\n  ourOpt.cwdbase = typeof ourOpt.cwdbase === 'boolean' ? ourOpt.cwdbase : false;\r\n  ourOpt.uniqueBy =  typeof ourOpt.uniqueBy === 'string' ||\r\n                    typeof ourOpt.uniqueBy === 'function' ? ourOpt.uniqueBy : 'path';\r\n\r\n  if (ourOpt.cwdbase) {\r\n    ourOpt.base = ourOpt.cwd;\r\n  }\r\n  // Normalize string `ignore` to array\r\n  if (typeof ignore === 'string') {\r\n    ignore = [ignore];\r\n  }\r\n  // Ensure `ignore` is an array\r\n  if (!Array.isArray(ignore)) {\r\n    ignore = [];\r\n  }\r\n\r\n  // Only one glob no need to aggregate\r\n  if (!Array.isArray(globs)) {\r\n    globs = [globs];\r\n  }\r\n\r\n  var positives = [];\r\n  var negatives = [];\r\n\r\n  globs.forEach(sortGlobs);\r\n\r\n  function sortGlobs(globString, index) {\r\n    if (typeof globString !== 'string') {\r\n      throw new Error('Invalid glob at index ' + index);\r\n    }\r\n\r\n    var glob = isNegatedGlob(globString);\r\n    var globArray = glob.negated ? negatives : positives;\r\n\r\n    globArray.push({\r\n      index: index,\r\n      glob: glob.pattern,\r\n    });\r\n  }\r\n\r\n  if (positives.length === 0) {\r\n    throw new Error('Missing positive glob');\r\n  }\r\n\r\n  // Create all individual streams\r\n  var streams = positives.map(streamFromPositive);\r\n\r\n  // Then just pipe them to a single unique stream and return it\r\n  var aggregate = new Combine(streams);\r\n  var uniqueStream = unique(ourOpt.uniqueBy);\r\n\r\n  return pumpify.obj(aggregate, uniqueStream);\r\n\r\n  function streamFromPositive(positive) {\r\n    var negativeGlobs = negatives\r\n      .filter(indexGreaterThan(positive.index))\r\n      .map(toGlob)\r\n      .concat(ignore);\r\n    return new GlobStream(positive.glob, negativeGlobs, ourOpt);\r\n  }\r\n}\r\n\r\nfunction indexGreaterThan(index) {\r\n  return function(obj) {\r\n    return obj.index > index;\r\n  };\r\n}\r\n\r\nfunction toGlob(obj) {\r\n  return obj.glob;\r\n}\r\n\r\nmodule.exports = globStream;\r\n"]},"metadata":{},"sourceType":"script"}