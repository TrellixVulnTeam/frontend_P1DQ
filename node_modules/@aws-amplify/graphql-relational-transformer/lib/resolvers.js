"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.updateTableForConnection = exports.makeQueryConnectionWithKeyResolver = exports.makeGetItemConnectionWithKeyResolver = void 0;
const assert_1 = __importDefault(require("assert"));
const graphql_transformer_core_1 = require("@aws-amplify/graphql-transformer-core");
const cdk = __importStar(require("@aws-cdk/core"));
const graphql_mapping_template_1 = require("graphql-mapping-template");
const graphql_transformer_common_1 = require("graphql-transformer-common");
const utils_1 = require("./utils");
function makeGetItemConnectionWithKeyResolver(config, ctx) {
    const { connectionFields, field, fields, object, relatedType, relatedTypeIndex } = config;
    assert_1.default(relatedTypeIndex.length > 0);
    const localFields = fields.length > 0 ? fields : connectionFields;
    const table = getTable(ctx, relatedType);
    const { keySchema } = table;
    const dataSource = ctx.api.host.getDataSource(`${relatedType.name.value}Table`);
    const partitionKeyName = keySchema[0].attributeName;
    const keyObj = {
        [partitionKeyName]: graphql_mapping_template_1.ref(`util.dynamodb.toDynamoDBJson($util.defaultIfNullOrBlank($ctx.source.${localFields[0]}, "${graphql_transformer_common_1.NONE_VALUE}"))`),
    };
    if (relatedTypeIndex.length > 2) {
        const rangeKeyFields = localFields.slice(1);
        const sortKeyName = keySchema[1].attributeName;
        const condensedSortKeyValue = condenseRangeKey(rangeKeyFields.map(keyField => `\${ctx.source.${keyField}}`));
        keyObj[sortKeyName] = graphql_mapping_template_1.ref(`util.dynamodb.toDynamoDBJson($util.defaultIfNullOrBlank("${condensedSortKeyValue}", "${graphql_transformer_common_1.NONE_VALUE}"))`);
    }
    else if (relatedTypeIndex.length === 2) {
        const sortKeyName = keySchema[1].attributeName;
        keyObj[sortKeyName] = graphql_mapping_template_1.ref(`util.dynamodb.toDynamoDBJson($util.defaultIfNullOrBlank($ctx.source.${localFields[1]}, "${graphql_transformer_common_1.NONE_VALUE}"))`);
    }
    const resolver = ctx.resolvers.generateQueryResolver(object.name.value, field.name.value, dataSource, graphql_transformer_core_1.MappingTemplate.s3MappingTemplateFromString(graphql_mapping_template_1.print(graphql_mapping_template_1.ifElse(graphql_mapping_template_1.or(localFields.map(f => graphql_mapping_template_1.raw(`$util.isNull($ctx.source.${f})`))), graphql_mapping_template_1.raw('#return'), graphql_mapping_template_1.compoundExpression([
        graphql_mapping_template_1.DynamoDBMappingTemplate.getItem({
            key: graphql_mapping_template_1.obj(keyObj),
        }),
    ]))), `${object.name.value}.${field.name.value}.req.vtl`), graphql_transformer_core_1.MappingTemplate.s3MappingTemplateFromString(graphql_mapping_template_1.print(graphql_mapping_template_1.DynamoDBMappingTemplate.dynamoDBResponse(false)), `${object.name.value}.${field.name.value}.res.vtl`));
    resolver.mapToStack(table.stack);
    ctx.resolvers.addResolver(object.name.value, field.name.value, resolver);
}
exports.makeGetItemConnectionWithKeyResolver = makeGetItemConnectionWithKeyResolver;
function makeQueryConnectionWithKeyResolver(config, ctx) {
    const { connectionFields, field, fields, indexName, limit, object, relatedType } = config;
    const table = getTable(ctx, relatedType);
    const dataSource = ctx.api.host.getDataSource(`${relatedType.name.value}Table`);
    const connectionAttributes = fields.length > 0 ? fields : connectionFields;
    assert_1.default(connectionAttributes.length > 0);
    const keySchema = getKeySchema(table, indexName);
    const setup = [
        graphql_mapping_template_1.set(graphql_mapping_template_1.ref('limit'), graphql_mapping_template_1.ref(`util.defaultIfNull($context.args.limit, ${limit})`)),
        graphql_mapping_template_1.set(graphql_mapping_template_1.ref('query'), makeExpression(keySchema, connectionAttributes)),
    ];
    if (keySchema[1] && !connectionAttributes[1]) {
        const sortKeyFieldName = keySchema[1].attributeName;
        const sortKeyField = relatedType.fields.find(f => f.name.value === sortKeyFieldName);
        if (sortKeyField) {
            setup.push(graphql_transformer_common_1.applyKeyConditionExpression(sortKeyFieldName, graphql_transformer_common_1.attributeTypeFromScalar(sortKeyField.type), 'query'));
        }
        else {
            const sortKeyFieldNames = sortKeyFieldName.split(graphql_transformer_common_1.ModelResourceIDs.ModelCompositeKeySeparator());
            setup.push(graphql_transformer_common_1.applyCompositeKeyConditionExpression(sortKeyFieldNames, 'query', graphql_transformer_common_1.toCamelCase(sortKeyFieldNames), sortKeyFieldName));
        }
    }
    const queryArguments = {
        query: graphql_mapping_template_1.raw('$util.toJson($query)'),
        scanIndexForward: graphql_mapping_template_1.ifElse(graphql_mapping_template_1.ref('context.args.sortDirection'), graphql_mapping_template_1.ifElse(graphql_mapping_template_1.equals(graphql_mapping_template_1.ref('context.args.sortDirection'), graphql_mapping_template_1.str('ASC')), graphql_mapping_template_1.bool(true), graphql_mapping_template_1.bool(false)), graphql_mapping_template_1.bool(true)),
        filter: graphql_mapping_template_1.ifElse(graphql_mapping_template_1.ref('context.args.filter'), graphql_mapping_template_1.ref('util.transform.toDynamoDBFilterExpression($ctx.args.filter)'), graphql_mapping_template_1.nul()),
        limit: graphql_mapping_template_1.ref('limit'),
        nextToken: graphql_mapping_template_1.ifElse(graphql_mapping_template_1.ref('context.args.nextToken'), graphql_mapping_template_1.ref('util.toJson($context.args.nextToken)'), graphql_mapping_template_1.nul()),
    };
    if (indexName) {
        queryArguments.index = graphql_mapping_template_1.str(indexName);
    }
    const queryObj = graphql_mapping_template_1.DynamoDBMappingTemplate.query(queryArguments);
    const resolver = ctx.resolvers.generateQueryResolver(object.name.value, field.name.value, dataSource, graphql_transformer_core_1.MappingTemplate.s3MappingTemplateFromString(graphql_mapping_template_1.print(graphql_mapping_template_1.ifElse(graphql_mapping_template_1.raw(`$util.isNull($ctx.source.${connectionAttributes[0]})`), graphql_mapping_template_1.compoundExpression([graphql_mapping_template_1.set(graphql_mapping_template_1.ref('result'), graphql_mapping_template_1.obj({ items: graphql_mapping_template_1.list([]) })), graphql_mapping_template_1.raw('#return($result)')]), graphql_mapping_template_1.compoundExpression([...setup, queryObj]))), `${object.name.value}.${field.name.value}.req.vtl`), graphql_transformer_core_1.MappingTemplate.s3MappingTemplateFromString(graphql_mapping_template_1.print(graphql_mapping_template_1.DynamoDBMappingTemplate.dynamoDBResponse(false, graphql_mapping_template_1.compoundExpression([graphql_mapping_template_1.iff(graphql_mapping_template_1.raw('!$result'), graphql_mapping_template_1.set(graphql_mapping_template_1.ref('result'), graphql_mapping_template_1.ref('ctx.result'))), graphql_mapping_template_1.raw('$util.toJson($result)')]))), `${object.name.value}.${field.name.value}.res.vtl`));
    resolver.mapToStack(table.stack);
    ctx.resolvers.addResolver(object.name.value, field.name.value, resolver);
}
exports.makeQueryConnectionWithKeyResolver = makeQueryConnectionWithKeyResolver;
function makeExpression(keySchema, connectionAttributes) {
    if (keySchema[1] && connectionAttributes[1]) {
        let condensedSortKeyValue;
        if (connectionAttributes.length > 2) {
            const rangeKeyFields = connectionAttributes.slice(1);
            condensedSortKeyValue = rangeKeyFields
                .map(keyField => `\${context.source.${keyField}}`)
                .join(graphql_transformer_common_1.ModelResourceIDs.ModelCompositeKeySeparator());
        }
        return graphql_mapping_template_1.obj({
            expression: graphql_mapping_template_1.str('#partitionKey = :partitionKey AND #sortKey = :sortKey'),
            expressionNames: graphql_mapping_template_1.obj({
                '#partitionKey': graphql_mapping_template_1.str(keySchema[0].attributeName),
                '#sortKey': graphql_mapping_template_1.str(keySchema[1].attributeName),
            }),
            expressionValues: graphql_mapping_template_1.obj({
                ':partitionKey': graphql_mapping_template_1.ref(`util.dynamodb.toDynamoDB($context.source.${connectionAttributes[0]})`),
                ':sortKey': graphql_mapping_template_1.ref(`util.dynamodb.toDynamoDB(${condensedSortKeyValue ? `"${condensedSortKeyValue}"` : `$context.source.${connectionAttributes[1]}`})`),
            }),
        });
    }
    return graphql_mapping_template_1.obj({
        expression: graphql_mapping_template_1.str('#partitionKey = :partitionKey'),
        expressionNames: graphql_mapping_template_1.obj({
            '#partitionKey': graphql_mapping_template_1.str(keySchema[0].attributeName),
        }),
        expressionValues: graphql_mapping_template_1.obj({
            ':partitionKey': graphql_mapping_template_1.ref(`util.dynamodb.toDynamoDB($context.source.${connectionAttributes[0]})`),
        }),
    });
}
function getTable(ctx, object) {
    const ddbDataSource = ctx.dataSources.get(object);
    const tableName = graphql_transformer_common_1.ModelResourceIDs.ModelTableResourceID(object.name.value);
    const table = ddbDataSource.ds.stack.node.findChild(tableName);
    assert_1.default(table);
    return table;
}
function getKeySchema(table, indexName) {
    var _a, _b, _c;
    return ((_c = (_b = ((_a = table.globalSecondaryIndexes.find((gsi) => gsi.indexName === indexName)) !== null && _a !== void 0 ? _a : table.localSecondaryIndexes.find((gsi) => gsi.indexName === indexName))) === null || _b === void 0 ? void 0 : _b.keySchema) !== null && _c !== void 0 ? _c : table.keySchema);
}
function condenseRangeKey(fields) {
    return fields.join(graphql_transformer_common_1.ModelResourceIDs.ModelCompositeKeySeparator());
}
function updateTableForConnection(config, ctx) {
    let { fields, indexName } = config;
    if (indexName || fields.length > 0) {
        return;
    }
    const { field, object, relatedType } = config;
    const connectionName = utils_1.getConnectionAttributeName(object.name.value, field.name.value);
    const table = getTable(ctx, relatedType);
    const gsis = table.globalSecondaryIndexes;
    indexName = `gsi-${object.name.value}.${field.name.value}`;
    config.indexName = indexName;
    if (gsis.some((gsi) => gsi.indexName === indexName)) {
        return;
    }
    table.addGlobalSecondaryIndex({
        indexName,
        projectionType: 'ALL',
        partitionKey: {
            name: connectionName,
            type: 'S',
        },
        readCapacity: cdk.Fn.ref(graphql_transformer_common_1.ResourceConstants.PARAMETERS.DynamoDBModelTableReadIOPS),
        writeCapacity: cdk.Fn.ref(graphql_transformer_common_1.ResourceConstants.PARAMETERS.DynamoDBModelTableWriteIOPS),
    });
    const cfnTable = table.table;
    const gsi = gsis.find((gsi) => gsi.indexName === indexName);
    cfnTable.globalSecondaryIndexes = appendIndex(cfnTable.globalSecondaryIndexes, {
        indexName,
        keySchema: gsi.keySchema,
        projection: { projectionType: 'ALL' },
        provisionedThroughput: cdk.Fn.conditionIf(graphql_transformer_common_1.ResourceConstants.CONDITIONS.ShouldUsePayPerRequestBilling, cdk.Fn.ref('AWS::NoValue'), {
            ReadCapacityUnits: cdk.Fn.ref(graphql_transformer_common_1.ResourceConstants.PARAMETERS.DynamoDBModelTableReadIOPS),
            WriteCapacityUnits: cdk.Fn.ref(graphql_transformer_common_1.ResourceConstants.PARAMETERS.DynamoDBModelTableWriteIOPS),
        }),
    });
}
exports.updateTableForConnection = updateTableForConnection;
function appendIndex(list, newIndex) {
    if (Array.isArray(list)) {
        list.push(newIndex);
        return list;
    }
    return [newIndex];
}
//# sourceMappingURL=resolvers.js.map