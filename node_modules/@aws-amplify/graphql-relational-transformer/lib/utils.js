"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.getConnectionAttributeName = exports.validateRelatedModelDirective = exports.getFieldsNodes = exports.getRelatedType = exports.validateModelDirective = exports.getModelDirective = exports.ensureFieldsArray = exports.getRelatedTypeIndex = void 0;
const assert_1 = __importDefault(require("assert"));
const graphql_transformer_core_1 = require("@aws-amplify/graphql-transformer-core");
const graphql_1 = require("graphql");
const graphql_transformer_common_1 = require("graphql-transformer-common");
function getRelatedTypeIndex(config, ctx, indexName) {
    const { directiveName, field, fieldNodes, relatedType } = config;
    const fieldMap = new Map();
    let partitionFieldName;
    let partitionField;
    const sortFieldNames = [];
    const sortFields = [];
    for (const field of relatedType.fields) {
        fieldMap.set(field.name.value, field);
        for (const directive of field.directives) {
            const directiveName = directive.name.value;
            const name = getIndexName(directive);
            if ((!indexName && directiveName === 'primaryKey') || (indexName === name && directiveName === 'index')) {
                partitionFieldName = field.name.value;
                for (const argument of directive.arguments) {
                    if (argument.name.value === 'sortKeyFields') {
                        if (argument.value.kind === graphql_1.Kind.STRING) {
                            sortFieldNames.push(argument.value.value);
                        }
                        else if (argument.value.kind === graphql_1.Kind.LIST) {
                            for (const keyField of argument.value.values) {
                                sortFieldNames.push(keyField.value);
                            }
                        }
                    }
                }
                break;
            }
        }
    }
    if (partitionFieldName === undefined) {
        if (indexName) {
            throw new graphql_transformer_core_1.InvalidDirectiveError(`Index ${indexName} does not exist for model ${relatedType.name.value}`);
        }
        partitionFieldName = 'id';
    }
    partitionField = fieldMap.get(partitionFieldName);
    assert_1.default(partitionField);
    for (const sortFieldName of sortFieldNames) {
        const sortField = fieldMap.get(sortFieldName);
        assert_1.default(sortField);
        sortFields.push(sortField);
    }
    if (fieldNodes.length > 0) {
        if (graphql_transformer_common_1.getBaseType(fieldNodes[0].type) !== graphql_transformer_common_1.getBaseType(partitionField.type)) {
            throw new graphql_transformer_core_1.InvalidDirectiveError(`${fieldNodes[0].name.value} field is not of type ${graphql_transformer_common_1.getBaseType(partitionField.type)}`);
        }
        if (fieldNodes.length > 1) {
            if (sortFields.length !== fieldNodes.length - 1) {
                throw new graphql_transformer_core_1.InvalidDirectiveError(`Invalid @${directiveName} directive on ${field.name.value}. Partial sort keys are not accepted.`);
            }
            for (let i = 0; i < sortFields.length; i++) {
                const sortField = sortFields[i];
                const fieldNode = fieldNodes[i + 1];
                if (graphql_transformer_common_1.getBaseType(fieldNode.type) !== graphql_transformer_common_1.getBaseType(sortField.type)) {
                    throw new graphql_transformer_core_1.InvalidDirectiveError(`${fieldNode.name.value} field is not of type ${graphql_transformer_common_1.getBaseType(sortField.type)}`);
                }
            }
        }
    }
    return [partitionField, ...sortFields];
}
exports.getRelatedTypeIndex = getRelatedTypeIndex;
function ensureFieldsArray(config) {
    if (!config.fields) {
        config.fields = [];
    }
    else if (!Array.isArray(config.fields)) {
        config.fields = [config.fields];
    }
    else if (config.fields.length === 0) {
        throw new graphql_transformer_core_1.InvalidDirectiveError(`No fields passed to @${config.directiveName} directive.`);
    }
}
exports.ensureFieldsArray = ensureFieldsArray;
function getModelDirective(objectType) {
    return objectType.directives.find(directive => {
        return directive.name.value === 'model';
    });
}
exports.getModelDirective = getModelDirective;
function validateModelDirective(config) {
    if (!getModelDirective(config.object)) {
        throw new graphql_transformer_core_1.InvalidDirectiveError(`@${config.directiveName} must be on an @model object type field.`);
    }
}
exports.validateModelDirective = validateModelDirective;
function getRelatedType(config, ctx) {
    const { field } = config;
    const relatedTypeName = graphql_transformer_common_1.getBaseType(field.type);
    const relatedType = ctx.inputDocument.definitions.find((d) => d.kind === graphql_1.Kind.OBJECT_TYPE_DEFINITION && d.name.value === relatedTypeName);
    assert_1.default(relatedType);
    return relatedType;
}
exports.getRelatedType = getRelatedType;
function getFieldsNodes(config, ctx) {
    const { directiveName, fields, object } = config;
    const enums = ctx.output.getTypeDefinitionsOfKind(graphql_1.Kind.ENUM_TYPE_DEFINITION);
    return fields.map(fieldName => {
        const fieldNode = object.fields.find(field => field.name.value === fieldName);
        if (!fieldNode) {
            throw new graphql_transformer_core_1.InvalidDirectiveError(`${fieldName} is not a field in ${object.name.value}`);
        }
        if (!graphql_transformer_common_1.isScalarOrEnum(fieldNode.type, enums)) {
            throw new graphql_transformer_core_1.InvalidDirectiveError(`All fields provided to @${directiveName} must be scalar or enum fields.`);
        }
        return fieldNode;
    });
}
exports.getFieldsNodes = getFieldsNodes;
function validateRelatedModelDirective(config) {
    if (!getModelDirective(config.relatedType)) {
        throw new graphql_transformer_core_1.InvalidDirectiveError(`Object type ${config.relatedType.name.value} must be annotated with @model.`);
    }
}
exports.validateRelatedModelDirective = validateRelatedModelDirective;
function getIndexName(directive) {
    for (const argument of directive.arguments) {
        if (argument.name.value === 'name') {
            return argument.value.value;
        }
    }
}
function getConnectionAttributeName(type, field) {
    return graphql_transformer_common_1.toCamelCase([type, field, 'id']);
}
exports.getConnectionAttributeName = getConnectionAttributeName;
//# sourceMappingURL=utils.js.map