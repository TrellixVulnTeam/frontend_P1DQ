"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ManyToManyTransformer = void 0;
const graphql_transformer_core_1 = require("@aws-amplify/graphql-transformer-core");
const graphql_transformer_common_1 = require("graphql-transformer-common");
const utils_1 = require("./utils");
const resolvers_1 = require("./resolvers");
const schema_1 = require("./schema");
const directiveName = 'manyToMany';
const defaultLimit = 100;
const directiveDefinition = `
  directive @${directiveName}(relationName: String!, limit: Int = ${defaultLimit}) on FIELD_DEFINITION
`;
class ManyToManyTransformer extends graphql_transformer_core_1.TransformerPluginBase {
    constructor(modelTransformer, indexTransformer, hasOneTransformer) {
        super('amplify-many-to-many-transformer', directiveDefinition);
        this.relationMap = new Map();
        this.directiveList = [];
        this.field = (parent, definition, directive, context) => {
            const directiveWrapped = new graphql_transformer_core_1.DirectiveWrapper(directive);
            const args = directiveWrapped.getArguments({
                directiveName,
                object: parent,
                field: definition,
                directive,
                limit: defaultLimit,
            });
            utils_1.validateModelDirective(args);
            args.connectionFields = [];
            if (!graphql_transformer_common_1.isListType(definition.type)) {
                throw new graphql_transformer_core_1.InvalidDirectiveError(`@${directiveName} must be used with a list.`);
            }
            addDirectiveToRelationMap(this.relationMap, args);
            this.directiveList.push(args);
        };
        this.validate = (ctx) => {
            this.relationMap.forEach(relation => {
                const { directive1, directive2, name } = relation;
                if (!directive2) {
                    throw new graphql_transformer_core_1.InvalidDirectiveError(`@${directiveName} relation '${name}' must be used in exactly two locations.`);
                }
                const d1ExpectedType = graphql_transformer_common_1.getBaseType(directive1.field.type);
                const d2ExpectedType = graphql_transformer_common_1.getBaseType(directive2.field.type);
                if (d1ExpectedType !== directive2.object.name.value) {
                    throw new graphql_transformer_core_1.InvalidDirectiveError(`@${directiveName} relation '${name}' expects '${d1ExpectedType}' but got '${directive2.object.name.value}'.`);
                }
                if (d2ExpectedType !== directive1.object.name.value) {
                    throw new graphql_transformer_core_1.InvalidDirectiveError(`@${directiveName} relation '${name}' expects '${d2ExpectedType}' but got '${directive1.object.name.value}'.`);
                }
                if (ctx.output.hasType(name)) {
                    throw new graphql_transformer_core_1.InvalidDirectiveError(`@${directiveName} relation name '${name}' (derived from '${directive1.relationName}') already exists as a type in the schema.`);
                }
            });
        };
        this.prepare = (ctx) => {
            const context = ctx;
            this.relationMap.forEach(relation => {
                const { directive1, directive2, name } = relation;
                const d1TypeName = directive1.object.name.value;
                const d2TypeName = directive2.object.name.value;
                const d1FieldName = d1TypeName.charAt(0).toLowerCase() + d1TypeName.slice(1);
                const d2FieldName = d2TypeName.charAt(0).toLowerCase() + d2TypeName.slice(1);
                const d1PartitionKey = schema_1.getPartitionKeyField(directive1.object);
                const d2PartitionKey = schema_1.getPartitionKeyField(directive2.object);
                const d1IndexName = `by${d1TypeName}`;
                const d2IndexName = `by${d2TypeName}`;
                const d1FieldNameId = `${d1FieldName}ID`;
                const d2FieldNameId = `${d2FieldName}ID`;
                const joinModelDirective = graphql_transformer_common_1.makeDirective('model', []);
                const d1IndexDirective = graphql_transformer_common_1.makeDirective('index', [
                    graphql_transformer_common_1.makeArgument('name', graphql_transformer_common_1.makeValueNode(d1IndexName)),
                    graphql_transformer_common_1.makeArgument('sortKeyFields', graphql_transformer_common_1.makeValueNode([d2FieldNameId])),
                ]);
                const d2IndexDirective = graphql_transformer_common_1.makeDirective('index', [
                    graphql_transformer_common_1.makeArgument('name', graphql_transformer_common_1.makeValueNode(d2IndexName)),
                    graphql_transformer_common_1.makeArgument('sortKeyFields', graphql_transformer_common_1.makeValueNode([d1FieldNameId])),
                ]);
                const d1HasOneDirective = graphql_transformer_common_1.makeDirective('hasOne', [graphql_transformer_common_1.makeArgument('fields', graphql_transformer_common_1.makeValueNode([d1FieldNameId]))]);
                const d2HasOneDirective = graphql_transformer_common_1.makeDirective('hasOne', [graphql_transformer_common_1.makeArgument('fields', graphql_transformer_common_1.makeValueNode([d2FieldNameId]))]);
                const d1RelatedField = graphql_transformer_common_1.makeField(d1FieldNameId, [], graphql_transformer_common_1.wrapNonNull(graphql_transformer_common_1.makeNamedType(graphql_transformer_common_1.getBaseType(d1PartitionKey.type))), [d1IndexDirective]);
                const d2RelatedField = graphql_transformer_common_1.makeField(d2FieldNameId, [], graphql_transformer_common_1.wrapNonNull(graphql_transformer_common_1.makeNamedType(graphql_transformer_common_1.getBaseType(d2PartitionKey.type))), [d2IndexDirective]);
                const d1Field = graphql_transformer_common_1.makeField(d1FieldName, [], graphql_transformer_common_1.wrapNonNull(graphql_transformer_common_1.makeNamedType(d1TypeName)), [d1HasOneDirective]);
                const d2Field = graphql_transformer_common_1.makeField(d2FieldName, [], graphql_transformer_common_1.wrapNonNull(graphql_transformer_common_1.makeNamedType(d2TypeName)), [d2HasOneDirective]);
                const joinType = {
                    ...graphql_transformer_common_1.blankObject(name),
                    fields: [graphql_transformer_common_1.makeField('id', [], graphql_transformer_common_1.wrapNonNull(graphql_transformer_common_1.makeNamedType('ID'))), d1RelatedField, d2RelatedField, d1Field, d2Field],
                    directives: [joinModelDirective],
                };
                ctx.output.addObject(joinType);
                directive1.indexName = d1IndexName;
                directive2.indexName = d2IndexName;
                directive1.fields = [d1PartitionKey.name.value];
                directive2.fields = [d1PartitionKey.name.value];
                directive1.fieldNodes = [d1PartitionKey];
                directive2.fieldNodes = [d2PartitionKey];
                directive1.relatedType = joinType;
                directive2.relatedType = joinType;
                directive1.relatedTypeIndex = [d1RelatedField];
                directive2.relatedTypeIndex = [d2RelatedField];
                this.modelTransformer.object(joinType, joinModelDirective, context);
                this.indexTransformer.field(joinType, d1RelatedField, d1IndexDirective, context);
                this.indexTransformer.field(joinType, d2RelatedField, d2IndexDirective, context);
                this.hasOneTransformer.field(joinType, d1Field, d1HasOneDirective, context);
                this.hasOneTransformer.field(joinType, d2Field, d2HasOneDirective, context);
                context.providerRegistry.registerDataSourceProvider(joinType, this.modelTransformer);
            });
        };
        this.transformSchema = (ctx) => {
            const context = ctx;
            for (const config of this.directiveList) {
                schema_1.ensureHasManyConnectionField(config, context);
                schema_1.extendTypeWithConnection(config, context);
            }
        };
        this.generateResolvers = (ctx) => {
            const context = ctx;
            for (const config of this.directiveList) {
                resolvers_1.updateTableForConnection(config, context);
                resolvers_1.makeQueryConnectionWithKeyResolver(config, context);
            }
        };
        this.modelTransformer = modelTransformer;
        this.indexTransformer = indexTransformer;
        this.hasOneTransformer = hasOneTransformer;
    }
}
exports.ManyToManyTransformer = ManyToManyTransformer;
function addDirectiveToRelationMap(map, directive) {
    const { relationName } = directive;
    const gqlName = getGraphqlRelationName(relationName);
    let relation;
    relation = map.get(gqlName);
    if (relation === undefined) {
        relation = { name: gqlName, directive1: directive };
        map.set(gqlName, relation);
        return;
    }
    if (relation.directive2) {
        throw new graphql_transformer_core_1.InvalidDirectiveError(`@${directiveName} relation '${relationName}' must be used in exactly two locations.`);
    }
    relation.directive2 = directive;
}
function getGraphqlRelationName(name) {
    return graphql_transformer_common_1.graphqlName(graphql_transformer_common_1.toUpper(name));
}
//# sourceMappingURL=graphql-many-to-many-transformer.js.map