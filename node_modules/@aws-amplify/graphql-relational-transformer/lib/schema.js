"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.getPartitionKeyField = exports.ensureHasManyConnectionField = exports.ensureHasOneConnectionField = exports.extendTypeWithConnection = void 0;
const assert_1 = __importDefault(require("assert"));
const graphql_model_transformer_1 = require("@aws-amplify/graphql-model-transformer");
const graphql_1 = require("graphql");
const graphql_transformer_common_1 = require("graphql-transformer-common");
const utils_1 = require("./utils");
function extendTypeWithConnection(config, ctx) {
    const { field, object } = config;
    generateModelXConnectionType(config, ctx);
    const type = ctx.output.getType(object.name.value);
    assert_1.default((type === null || type === void 0 ? void 0 : type.kind) === graphql_1.Kind.OBJECT_TYPE_DEFINITION || (type === null || type === void 0 ? void 0 : type.kind) === graphql_1.Kind.INTERFACE_TYPE_DEFINITION);
    const newFields = type.fields.map((f) => {
        if (f.name.value === field.name.value) {
            return makeModelConnectionField(config);
        }
        return f;
    });
    const updatedType = {
        ...type,
        fields: newFields,
    };
    ctx.output.putType(updatedType);
    ensureModelSortDirectionEnum(ctx);
    generateFilterAndKeyConditionInputs(config, ctx);
}
exports.extendTypeWithConnection = extendTypeWithConnection;
function generateModelXConnectionType(config, ctx) {
    const { relatedType } = config;
    const tableXConnectionName = graphql_transformer_common_1.ModelResourceIDs.ModelConnectionTypeName(relatedType.name.value);
    if (ctx.output.hasType(tableXConnectionName)) {
        return;
    }
    const connectionType = graphql_transformer_common_1.blankObject(tableXConnectionName);
    let connectionTypeExtension = graphql_transformer_common_1.blankObjectExtension(tableXConnectionName);
    connectionTypeExtension = graphql_transformer_common_1.extensionWithFields(connectionTypeExtension, [
        graphql_transformer_common_1.makeField('items', [], graphql_transformer_common_1.makeListType(graphql_transformer_common_1.makeNamedType(tableXConnectionName))),
    ]);
    connectionTypeExtension = graphql_transformer_common_1.extensionWithFields(connectionTypeExtension, [graphql_transformer_common_1.makeField('nextToken', [], graphql_transformer_common_1.makeNamedType('String'))]);
    ctx.output.addObject(connectionType);
    ctx.output.addObjectExtension(connectionTypeExtension);
}
function generateFilterAndKeyConditionInputs(config, ctx) {
    const { relatedTypeIndex } = config;
    const tableXQueryFilterInput = makeModelXFilterInputObject(config, ctx);
    if (!ctx.output.hasType(tableXQueryFilterInput.name.value)) {
        ctx.output.addInput(tableXQueryFilterInput);
    }
    if (relatedTypeIndex.length === 2) {
        const sortKeyType = relatedTypeIndex[1].type;
        const baseType = graphql_transformer_common_1.getBaseType(sortKeyType);
        const namedType = graphql_transformer_common_1.makeNamedType(baseType);
        const sortKeyConditionInput = graphql_transformer_common_1.makeScalarKeyConditionForType(namedType);
        if (!ctx.output.hasType(sortKeyConditionInput.name.value)) {
            ctx.output.addInput(sortKeyConditionInput);
        }
    }
}
function ensureModelSortDirectionEnum(ctx) {
    if (!ctx.output.hasType('ModelSortDirection')) {
        const modelSortDirection = graphql_model_transformer_1.makeModelSortDirectionEnumObject();
        ctx.output.addEnum(modelSortDirection);
    }
}
function ensureHasOneConnectionField(config, ctx) {
    const { field, fieldNodes, object } = config;
    if (fieldNodes.length > 0) {
        return;
    }
    const connectionAttributeName = utils_1.getConnectionAttributeName(object.name.value, field.name.value);
    const createInputName = graphql_transformer_common_1.ModelResourceIDs.ModelCreateInputObjectName(object.name.value);
    const createInput = ctx.output.getType(createInputName);
    if (createInput) {
        const updated = updateCreateInputWithConnectionField(createInput, connectionAttributeName, graphql_transformer_common_1.isNonNullType(field.type));
        ctx.output.putType(updated);
    }
    const updateInputName = graphql_transformer_common_1.ModelResourceIDs.ModelUpdateInputObjectName(object.name.value);
    const updateInput = ctx.output.getType(updateInputName);
    if (updateInput) {
        const updated = updateUpdateInputWithConnectionField(updateInput, connectionAttributeName);
        ctx.output.putType(updated);
    }
    config.connectionFields.push(connectionAttributeName);
}
exports.ensureHasOneConnectionField = ensureHasOneConnectionField;
function ensureHasManyConnectionField(config, ctx) {
    const { field, fieldNodes, object, relatedType } = config;
    if (fieldNodes.length > 0) {
        return;
    }
    const connectionAttributeName = utils_1.getConnectionAttributeName(object.name.value, field.name.value);
    const createInputName = graphql_transformer_common_1.ModelResourceIDs.ModelCreateInputObjectName(relatedType.name.value);
    const createInput = ctx.output.getType(createInputName);
    if (createInput) {
        const updated = updateCreateInputWithConnectionField(createInput, connectionAttributeName, graphql_transformer_common_1.isNonNullType(field.type));
        ctx.output.putType(updated);
    }
    const updateInputName = graphql_transformer_common_1.ModelResourceIDs.ModelUpdateInputObjectName(relatedType.name.value);
    const updateInput = ctx.output.getType(updateInputName);
    if (updateInput) {
        const updated = updateUpdateInputWithConnectionField(updateInput, connectionAttributeName);
        ctx.output.putType(updated);
    }
    let connectionFieldName = 'id';
    for (const field of object.fields) {
        for (const directive of field.directives) {
            if (directive.name.value === 'primaryKey') {
                connectionFieldName = field.name.value;
                break;
            }
        }
    }
    config.connectionFields.push(connectionFieldName);
}
exports.ensureHasManyConnectionField = ensureHasManyConnectionField;
function updateCreateInputWithConnectionField(input, connectionFieldName, nonNull = false) {
    const keyFieldExists = input.fields.some(f => f.name.value === connectionFieldName);
    if (keyFieldExists) {
        return input;
    }
    const updatedFields = [
        ...input.fields,
        graphql_transformer_common_1.makeInputValueDefinition(connectionFieldName, nonNull ? graphql_transformer_common_1.makeNonNullType(graphql_transformer_common_1.makeNamedType('ID')) : graphql_transformer_common_1.makeNamedType('ID')),
    ];
    return {
        ...input,
        fields: updatedFields,
    };
}
function updateUpdateInputWithConnectionField(input, connectionFieldName) {
    const keyFieldExists = input.fields.some(f => f.name.value === connectionFieldName);
    if (keyFieldExists) {
        return input;
    }
    const updatedFields = [...input.fields, graphql_transformer_common_1.makeInputValueDefinition(connectionFieldName, graphql_transformer_common_1.makeNamedType('ID'))];
    return {
        ...input,
        fields: updatedFields,
    };
}
function makeModelConnectionField(config) {
    const { field, fields, indexName, relatedType, relatedTypeIndex } = config;
    const args = [
        graphql_transformer_common_1.makeInputValueDefinition('filter', graphql_transformer_common_1.makeNamedType(graphql_transformer_common_1.ModelResourceIDs.ModelFilterInputTypeName(relatedType.name.value))),
        graphql_transformer_common_1.makeInputValueDefinition('sortDirection', graphql_transformer_common_1.makeNamedType('ModelSortDirection')),
        graphql_transformer_common_1.makeInputValueDefinition('limit', graphql_transformer_common_1.makeNamedType('Int')),
        graphql_transformer_common_1.makeInputValueDefinition('nextToken', graphql_transformer_common_1.makeNamedType('String')),
    ];
    if (fields.length < 2 && relatedTypeIndex.length > 1) {
        let fieldName;
        let namedType;
        if (relatedTypeIndex.length === 2) {
            const sortKeyField = relatedTypeIndex[1];
            const baseType = graphql_transformer_common_1.getBaseType(sortKeyField.type);
            fieldName = sortKeyField.name.value;
            namedType = graphql_transformer_common_1.makeNamedType(graphql_transformer_common_1.ModelResourceIDs.ModelKeyConditionInputTypeName(baseType));
        }
        else {
            const sortKeyFieldNames = relatedTypeIndex.slice(1).map(field => field.name.value);
            fieldName = graphql_transformer_common_1.toCamelCase(sortKeyFieldNames);
            namedType = graphql_transformer_common_1.makeNamedType(graphql_transformer_common_1.ModelResourceIDs.ModelCompositeKeyConditionInputTypeName(relatedType.name.value, graphql_transformer_common_1.toUpper(indexName !== null && indexName !== void 0 ? indexName : 'Primary')));
        }
        args.unshift(graphql_transformer_common_1.makeInputValueDefinition(fieldName, namedType));
    }
    return graphql_transformer_common_1.makeField(field.name.value, args, graphql_transformer_common_1.makeNamedType(graphql_transformer_common_1.ModelResourceIDs.ModelConnectionTypeName(relatedType.name.value)), field.directives);
}
function makeModelXFilterInputObject(config, ctx) {
    const { relatedType } = config;
    const name = graphql_transformer_common_1.ModelResourceIDs.ModelFilterInputTypeName(relatedType.name.value);
    const fields = relatedType
        .fields.filter((field) => {
        const fieldType = ctx.output.getType(graphql_transformer_common_1.getBaseType(field.type));
        return graphql_transformer_common_1.isScalar(field.type) || (fieldType && fieldType.kind === graphql_1.Kind.ENUM_TYPE_DEFINITION);
    })
        .map((field) => {
        const baseType = graphql_transformer_common_1.getBaseType(field.type);
        const isList = graphql_transformer_common_1.isListType(field.type);
        let filterTypeName = baseType;
        if (graphql_transformer_common_1.isScalar(field.type) || isList) {
            filterTypeName = isList
                ? graphql_transformer_common_1.ModelResourceIDs.ModelFilterListInputTypeName(baseType, true)
                : graphql_transformer_common_1.ModelResourceIDs.ModelScalarFilterInputTypeName(baseType, false);
        }
        return {
            kind: graphql_1.Kind.INPUT_VALUE_DEFINITION,
            name: field.name,
            type: graphql_transformer_common_1.makeNamedType(filterTypeName),
            directives: [],
        };
    });
    fields.push({
        kind: graphql_1.Kind.INPUT_VALUE_DEFINITION,
        name: {
            kind: 'Name',
            value: 'and',
        },
        type: graphql_transformer_common_1.makeListType(graphql_transformer_common_1.makeNamedType(name)),
        directives: [],
    }, {
        kind: graphql_1.Kind.INPUT_VALUE_DEFINITION,
        name: {
            kind: 'Name',
            value: 'or',
        },
        type: graphql_transformer_common_1.makeListType(graphql_transformer_common_1.makeNamedType(name)),
        directives: [],
    }, {
        kind: graphql_1.Kind.INPUT_VALUE_DEFINITION,
        name: {
            kind: 'Name',
            value: 'not',
        },
        type: graphql_transformer_common_1.makeNamedType(name),
        directives: [],
    });
    return {
        kind: 'InputObjectTypeDefinition',
        name: {
            kind: 'Name',
            value: name,
        },
        fields,
        directives: [],
    };
}
function getPartitionKeyField(object) {
    const fieldMap = new Map();
    let name = 'id';
    for (const field of object.fields) {
        fieldMap.set(field.name.value, field);
        for (const directive of field.directives) {
            if (directive.name.value === 'primaryKey') {
                name = field.name.value;
                break;
            }
        }
    }
    return fieldMap.get(name);
}
exports.getPartitionKeyField = getPartitionKeyField;
//# sourceMappingURL=schema.js.map