"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.updateResolversForIndex = exports.appendSecondaryIndex = exports.updateResolvers = exports.replaceDdbPrimaryKey = void 0;
const assert_1 = __importDefault(require("assert"));
const graphql_model_transformer_1 = require("@aws-amplify/graphql-model-transformer");
const graphql_transformer_core_1 = require("@aws-amplify/graphql-transformer-core");
const cdk = __importStar(require("@aws-cdk/core"));
const graphql_1 = require("graphql");
const graphql_mapping_template_1 = require("graphql-mapping-template");
const graphql_transformer_common_1 = require("graphql-transformer-common");
const utils_1 = require("./utils");
function replaceDdbPrimaryKey(config, ctx) {
    var _a, _b, _c;
    const { field, object } = config;
    const table = getTable(ctx, object);
    const cfnTable = table.table;
    const tableAttrDefs = table.attributeDefinitions;
    const tableKeySchema = table.keySchema;
    const keySchema = getDdbKeySchema(config);
    const attrDefs = attributeDefinitions(config, ctx);
    const existingAttrDefSet = new Set(tableAttrDefs.map((ad) => ad.attributeName));
    const primaryKeyPartitionKeyName = (_a = field.name.value) !== null && _a !== void 0 ? _a : 'id';
    const primaryKeyPartitionKeyType = (_c = (_b = attrDefs.find(attr => attr.attributeName === primaryKeyPartitionKeyName)) === null || _b === void 0 ? void 0 : _b.attributeType) !== null && _c !== void 0 ? _c : 'S';
    for (const existingKey of tableKeySchema) {
        if (existingAttrDefSet.has(existingKey.attributeName)) {
            table.attributeDefinitions = tableAttrDefs.filter((ad) => {
                return ad.attributeName !== existingKey.attributeName;
            });
            existingAttrDefSet.delete(existingKey.attributeName);
        }
    }
    table.keySchema = keySchema;
    table.tablePartitionKey = { name: primaryKeyPartitionKeyName, type: primaryKeyPartitionKeyType };
    for (const attr of attrDefs) {
        if (!existingAttrDefSet.has(attr.attributeName)) {
            table.attributeDefinitions.push(attr);
        }
    }
    cfnTable.keySchema = table.keySchema;
    cfnTable.attributeDefinitions = table.attributeDefinitions;
}
exports.replaceDdbPrimaryKey = replaceDdbPrimaryKey;
function updateResolvers(config, ctx) {
    const getResolver = getResolverObject(config, ctx, 'get');
    const listResolver = getResolverObject(config, ctx, 'list');
    const createResolver = getResolverObject(config, ctx, 'create');
    const updateResolver = getResolverObject(config, ctx, 'update');
    const deleteResolver = getResolverObject(config, ctx, 'delete');
    if (getResolver) {
        addIndexToResolverSlot(getResolver, [setPrimaryKeySnippet(config, false)]);
    }
    if (listResolver) {
        addIndexToResolverSlot(listResolver, [
            graphql_mapping_template_1.print(setQuerySnippet(config, ctx, true)),
            `$util.qr($ctx.stash.put("${graphql_transformer_common_1.ResourceConstants.SNIPPETS.ModelQueryExpression}", $${graphql_transformer_common_1.ResourceConstants.SNIPPETS.ModelQueryExpression}))`,
        ]);
    }
    if (createResolver) {
        addIndexToResolverSlot(createResolver, [
            mergeInputsAndDefaultsSnippet(),
            setPrimaryKeySnippet(config, true),
            ensureCompositeKeySnippet(config, false),
        ]);
    }
    if (updateResolver) {
        addIndexToResolverSlot(updateResolver, [
            mergeInputsAndDefaultsSnippet(),
            setPrimaryKeySnippet(config, true),
            ensureCompositeKeySnippet(config, false),
        ]);
    }
    if (deleteResolver) {
        addIndexToResolverSlot(deleteResolver, [mergeInputsAndDefaultsSnippet(), setPrimaryKeySnippet(config, true)]);
    }
}
exports.updateResolvers = updateResolvers;
function getTable(context, object) {
    const ddbDataSource = context.dataSources.get(object);
    const tableName = graphql_transformer_common_1.ModelResourceIDs.ModelTableResourceID(object.name.value);
    const table = ddbDataSource.ds.stack.node.findChild(tableName);
    assert_1.default(table);
    return table;
}
function getDdbKeySchema(config) {
    const schema = [{ attributeName: config.field.name.value, keyType: 'HASH' }];
    if (config.sortKey.length > 0) {
        schema.push({ attributeName: getSortKeyName(config), keyType: 'RANGE' });
    }
    return schema;
}
function attributeTypeFromType(type, ctx) {
    const baseTypeName = graphql_transformer_common_1.getBaseType(type);
    const ofType = ctx.output.getType(baseTypeName);
    if (ofType && ofType.kind === graphql_1.Kind.ENUM_TYPE_DEFINITION) {
        return 'S';
    }
    return graphql_transformer_common_1.attributeTypeFromScalar(type);
}
function attributeDefinitions(config, ctx) {
    const { field, sortKey, sortKeyFields } = config;
    const definitions = [{ attributeName: field.name.value, attributeType: attributeTypeFromType(field.type, ctx) }];
    if (sortKeyFields.length === 1) {
        definitions.push({
            attributeName: sortKeyFields[0],
            attributeType: attributeTypeFromType(sortKey[0].type, ctx),
        });
    }
    else if (sortKeyFields.length > 1) {
        definitions.push({
            attributeName: getSortKeyName(config),
            attributeType: 'S',
        });
    }
    return definitions;
}
function getSortKeyName(config) {
    return config.sortKeyFields.join(graphql_transformer_common_1.ModelResourceIDs.ModelCompositeKeySeparator());
}
function getResolverObject(config, ctx, op) {
    var _a;
    const resolverName = utils_1.lookupResolverName(config, ctx, op);
    if (!resolverName) {
        return null;
    }
    const objectName = op === 'get' || op === 'list' ? ctx.output.getQueryTypeName() : ctx.output.getMutationTypeName();
    if (!objectName) {
        return null;
    }
    return (_a = ctx.resolvers.getResolver(objectName, resolverName)) !== null && _a !== void 0 ? _a : null;
}
function setPrimaryKeySnippet(config, isMutation) {
    const cmds = [
        graphql_mapping_template_1.qref(graphql_mapping_template_1.methodCall(graphql_mapping_template_1.ref('ctx.stash.metadata.put'), graphql_mapping_template_1.str(graphql_transformer_common_1.ResourceConstants.SNIPPETS.ModelObjectKey), modelObjectKeySnippet(config, isMutation))),
    ];
    return graphql_mapping_template_1.printBlock('Set the primary key')(graphql_mapping_template_1.compoundExpression(cmds));
}
function modelObjectKeySnippet(config, isMutation) {
    const { field, sortKeyFields } = config;
    const argsPrefix = isMutation ? 'mergedValues' : 'ctx.args';
    const modelObject = {
        [field.name.value]: graphql_mapping_template_1.ref(`util.dynamodb.toDynamoDB($${argsPrefix}.${field.name.value})`),
    };
    if (sortKeyFields.length > 1) {
        const compositeSortKey = getSortKeyName(config);
        const compositeSortKeyValue = sortKeyFields
            .map(keyField => {
            return `\${${argsPrefix}.${keyField}}`;
        })
            .join(graphql_transformer_common_1.ModelResourceIDs.ModelCompositeKeySeparator());
        modelObject[compositeSortKey] = graphql_mapping_template_1.ref(`util.dynamodb.toDynamoDB("${compositeSortKeyValue}")`);
    }
    else if (sortKeyFields.length === 1) {
        modelObject[sortKeyFields[0]] = graphql_mapping_template_1.ref(`util.dynamodb.toDynamoDB($${argsPrefix}.${sortKeyFields[0]})`);
    }
    return graphql_mapping_template_1.obj(modelObject);
}
function ensureCompositeKeySnippet(config, conditionallySetSortKey) {
    const { sortKeyFields } = config;
    if (sortKeyFields.length < 2) {
        return '';
    }
    const argsPrefix = 'mergedValues';
    const condensedSortKey = getSortKeyName(config);
    const dynamoDBFriendlySortKeyName = graphql_transformer_common_1.toCamelCase(sortKeyFields.map(f => graphql_transformer_common_1.graphqlName(f)));
    const condensedSortKeyValue = sortKeyFields
        .map(keyField => {
        return `\${${argsPrefix}.${keyField}}`;
    })
        .join(graphql_transformer_common_1.ModelResourceIDs.ModelCompositeKeySeparator());
    return graphql_mapping_template_1.print(graphql_mapping_template_1.compoundExpression([
        graphql_mapping_template_1.ifElse(graphql_mapping_template_1.raw(`$util.isNull($ctx.stash.metadata.${graphql_transformer_common_1.ResourceConstants.SNIPPETS.DynamoDBNameOverrideMap})`), graphql_mapping_template_1.qref(graphql_mapping_template_1.methodCall(graphql_mapping_template_1.ref('ctx.stash.metadata.put'), graphql_mapping_template_1.str(graphql_transformer_common_1.ResourceConstants.SNIPPETS.DynamoDBNameOverrideMap), graphql_mapping_template_1.obj({
            [condensedSortKey]: graphql_mapping_template_1.str(dynamoDBFriendlySortKeyName),
        }))), graphql_mapping_template_1.qref(graphql_mapping_template_1.methodCall(graphql_mapping_template_1.ref(`ctx.stash.metadata.${graphql_transformer_common_1.ResourceConstants.SNIPPETS.DynamoDBNameOverrideMap}.put`), graphql_mapping_template_1.str(condensedSortKey), graphql_mapping_template_1.str(dynamoDBFriendlySortKeyName)))),
        conditionallySetSortKey
            ? graphql_mapping_template_1.iff(graphql_mapping_template_1.ref(graphql_transformer_common_1.ResourceConstants.SNIPPETS.HasSeenSomeKeyArg), graphql_mapping_template_1.qref(`$ctx.args.input.put("${condensedSortKey}","${condensedSortKeyValue}")`))
            : graphql_mapping_template_1.qref(`$ctx.args.input.put("${condensedSortKey}","${condensedSortKeyValue}")`),
    ]));
}
function setQuerySnippet(config, ctx, isListResolver) {
    const { field, sortKey, sortKeyFields } = config;
    const keyFields = [field, ...sortKey];
    const keyNames = [field.name.value, ...sortKeyFields];
    const keyTypes = keyFields.map(k => attributeTypeFromType(k.type, ctx));
    const expressions = [];
    if (keyNames.length === 1) {
        const sortDirectionValidation = graphql_mapping_template_1.iff(graphql_mapping_template_1.raw(`!$util.isNull($ctx.args.sortDirection)`), graphql_mapping_template_1.raw(`$util.error("sortDirection is not supported for List operations without a Sort key defined.", "InvalidArgumentsError")`));
        expressions.push(sortDirectionValidation);
    }
    else if (isListResolver === true && keyNames.length >= 1) {
        const sortDirectionValidation = graphql_mapping_template_1.iff(graphql_mapping_template_1.and([graphql_mapping_template_1.raw(`$util.isNull($ctx.args.${keyNames[0]})`), graphql_mapping_template_1.raw(`!$util.isNull($ctx.args.sortDirection)`)]), graphql_mapping_template_1.raw(`$util.error("When providing argument 'sortDirection' you must also provide argument '${keyNames[0]}'.", "InvalidArgumentsError")`));
        expressions.push(sortDirectionValidation);
    }
    expressions.push(graphql_mapping_template_1.set(graphql_mapping_template_1.ref(graphql_transformer_common_1.ResourceConstants.SNIPPETS.ModelQueryExpression), graphql_mapping_template_1.obj({})), graphql_transformer_common_1.applyKeyExpressionForCompositeKey(keyNames, keyTypes, graphql_transformer_common_1.ResourceConstants.SNIPPETS.ModelQueryExpression));
    return graphql_mapping_template_1.block(`Set query expression for key`, expressions);
}
function appendSecondaryIndex(config, ctx) {
    var _a, _b, _c, _d, _e, _f, _g, _h;
    const { name, object, primaryKeyField } = config;
    const table = getTable(ctx, object);
    const keySchema = getDdbKeySchema(config);
    const attrDefs = attributeDefinitions(config, ctx);
    const primaryKeyPartitionKeyName = (_b = (_a = primaryKeyField === null || primaryKeyField === void 0 ? void 0 : primaryKeyField.name) === null || _a === void 0 ? void 0 : _a.value) !== null && _b !== void 0 ? _b : 'id';
    const partitionKeyName = (_c = keySchema[0]) === null || _c === void 0 ? void 0 : _c.attributeName;
    const sortKeyName = (_d = keySchema === null || keySchema === void 0 ? void 0 : keySchema[1]) === null || _d === void 0 ? void 0 : _d.attributeName;
    const partitionKeyType = (_f = (_e = attrDefs.find(attr => attr.attributeName === partitionKeyName)) === null || _e === void 0 ? void 0 : _e.attributeType) !== null && _f !== void 0 ? _f : 'S';
    const sortKeyType = sortKeyName ? (_h = (_g = attrDefs.find(attr => attr.attributeName === sortKeyName)) === null || _g === void 0 ? void 0 : _g.attributeType) !== null && _h !== void 0 ? _h : 'S' : undefined;
    const defaultGSI = ctx.featureFlags.getBoolean('secondaryKeyAsGSI', false);
    if (!defaultGSI && primaryKeyPartitionKeyName === partitionKeyName) {
        table.addLocalSecondaryIndex({
            indexName: name,
            projectionType: 'ALL',
            sortKey: sortKeyName
                ? {
                    name: sortKeyName,
                    type: sortKeyType,
                }
                : undefined,
        });
    }
    else {
        table.addGlobalSecondaryIndex({
            indexName: name,
            projectionType: 'ALL',
            partitionKey: {
                name: partitionKeyName,
                type: partitionKeyType,
            },
            sortKey: sortKeyName
                ? {
                    name: sortKeyName,
                    type: sortKeyType,
                }
                : undefined,
            readCapacity: cdk.Fn.ref(graphql_transformer_common_1.ResourceConstants.PARAMETERS.DynamoDBModelTableReadIOPS),
            writeCapacity: cdk.Fn.ref(graphql_transformer_common_1.ResourceConstants.PARAMETERS.DynamoDBModelTableWriteIOPS),
        });
        const cfnTable = table.table;
        cfnTable.globalSecondaryIndexes = appendIndex(cfnTable.globalSecondaryIndexes, {
            indexName: name,
            keySchema,
            projection: { projectionType: 'ALL' },
            provisionedThroughput: cdk.Fn.conditionIf(graphql_transformer_common_1.ResourceConstants.CONDITIONS.ShouldUsePayPerRequestBilling, cdk.Fn.ref('AWS::NoValue'), {
                ReadCapacityUnits: cdk.Fn.ref(graphql_transformer_common_1.ResourceConstants.PARAMETERS.DynamoDBModelTableReadIOPS),
                WriteCapacityUnits: cdk.Fn.ref(graphql_transformer_common_1.ResourceConstants.PARAMETERS.DynamoDBModelTableWriteIOPS),
            }),
        });
    }
}
exports.appendSecondaryIndex = appendSecondaryIndex;
function appendIndex(list, newIndex) {
    if (Array.isArray(list)) {
        list.push(newIndex);
        return list;
    }
    return [newIndex];
}
function updateResolversForIndex(config, ctx) {
    const { queryField } = config;
    const createResolver = getResolverObject(config, ctx, 'create');
    const updateResolver = getResolverObject(config, ctx, 'update');
    const deleteResolver = getResolverObject(config, ctx, 'delete');
    if (createResolver) {
        const checks = [validateIndexArgumentSnippet(config, 'create'), ensureCompositeKeySnippet(config, true)];
        if (checks[0] || checks[1]) {
            addIndexToResolverSlot(createResolver, [mergeInputsAndDefaultsSnippet(), ...checks]);
        }
    }
    if (updateResolver) {
        const checks = [validateIndexArgumentSnippet(config, 'update'), ensureCompositeKeySnippet(config, true)];
        if (checks[0] || checks[1]) {
            addIndexToResolverSlot(updateResolver, [mergeInputsAndDefaultsSnippet(), ...checks]);
        }
    }
    if (deleteResolver) {
        const checks = [ensureCompositeKeySnippet(config, false)];
        if (checks[0]) {
            addIndexToResolverSlot(deleteResolver, [mergeInputsAndDefaultsSnippet(), ...checks]);
        }
    }
    if (queryField) {
        makeQueryResolver(config, ctx);
    }
}
exports.updateResolversForIndex = updateResolversForIndex;
function makeQueryResolver(config, ctx) {
    const { name, object, queryField } = config;
    const dataSource = ctx.api.host.getDataSource(`${object.name.value}Table`);
    const queryTypeName = ctx.output.getQueryTypeName();
    const table = getTable(ctx, object);
    const requestVariable = 'QueryRequest';
    assert_1.default(dataSource);
    const resolver = ctx.resolvers.generateQueryResolver(queryTypeName, queryField, dataSource, graphql_transformer_core_1.MappingTemplate.s3MappingTemplateFromString(graphql_mapping_template_1.print(graphql_mapping_template_1.compoundExpression([
        setQuerySnippet(config, ctx, false),
        graphql_mapping_template_1.set(graphql_mapping_template_1.ref('limit'), graphql_mapping_template_1.ref(`util.defaultIfNull($context.args.limit, ${graphql_transformer_common_1.ResourceConstants.DEFAULT_PAGE_LIMIT})`)),
        graphql_mapping_template_1.set(graphql_mapping_template_1.ref(requestVariable), graphql_mapping_template_1.obj({
            version: graphql_mapping_template_1.str(graphql_mapping_template_1.RESOLVER_VERSION_ID),
            operation: graphql_mapping_template_1.str('Query'),
            limit: graphql_mapping_template_1.ref('limit'),
            query: graphql_mapping_template_1.ref(graphql_transformer_common_1.ResourceConstants.SNIPPETS.ModelQueryExpression),
            index: graphql_mapping_template_1.str(name),
        })),
        graphql_mapping_template_1.ifElse(graphql_mapping_template_1.raw(`!$util.isNull($ctx.args.sortDirection)
                      && $ctx.args.sortDirection == "DESC"`), graphql_mapping_template_1.set(graphql_mapping_template_1.ref(`${requestVariable}.scanIndexForward`), graphql_mapping_template_1.bool(false)), graphql_mapping_template_1.set(graphql_mapping_template_1.ref(`${requestVariable}.scanIndexForward`), graphql_mapping_template_1.bool(true))),
        graphql_mapping_template_1.iff(graphql_mapping_template_1.ref('context.args.nextToken'), graphql_mapping_template_1.set(graphql_mapping_template_1.ref(`${requestVariable}.nextToken`), graphql_mapping_template_1.ref('context.args.nextToken')), true),
        graphql_mapping_template_1.iff(graphql_mapping_template_1.ref('context.args.filter'), graphql_mapping_template_1.set(graphql_mapping_template_1.ref(`${requestVariable}.filter`), graphql_mapping_template_1.ref('util.parseJson("$util.transform.toDynamoDBFilterExpression($ctx.args.filter)")')), true),
        graphql_mapping_template_1.raw(`$util.toJson($${requestVariable})`),
    ])), `${queryTypeName}.${queryField}.req.vtl`), graphql_transformer_core_1.MappingTemplate.s3MappingTemplateFromString(graphql_mapping_template_1.print(graphql_mapping_template_1.compoundExpression([
        graphql_mapping_template_1.iff(graphql_mapping_template_1.ref('ctx.error'), graphql_mapping_template_1.raw('$util.error($ctx.error.message, $ctx.error.type)')),
        graphql_mapping_template_1.raw('$util.toJson($ctx.result)'),
    ])), `${queryTypeName}.${queryField}.res.vtl`));
    resolver.mapToStack(table.stack);
    ctx.resolvers.addResolver(object.name.value, queryField, resolver);
}
function validateIndexArgumentSnippet(config, keyOperation) {
    const { name, sortKeyFields } = config;
    if (sortKeyFields.length < 2) {
        return '';
    }
    return graphql_mapping_template_1.printBlock(`Validate ${keyOperation} mutation for @index '${name}'`)(graphql_mapping_template_1.compoundExpression([
        graphql_mapping_template_1.set(graphql_mapping_template_1.ref(graphql_transformer_common_1.ResourceConstants.SNIPPETS.HasSeenSomeKeyArg), graphql_mapping_template_1.bool(false)),
        graphql_mapping_template_1.set(graphql_mapping_template_1.ref('keyFieldNames'), graphql_mapping_template_1.list(sortKeyFields.map(f => graphql_mapping_template_1.str(f)))),
        graphql_mapping_template_1.forEach(graphql_mapping_template_1.ref('keyFieldName'), graphql_mapping_template_1.ref('keyFieldNames'), [
            graphql_mapping_template_1.iff(graphql_mapping_template_1.raw(`$ctx.args.input.containsKey("$keyFieldName")`), graphql_mapping_template_1.set(graphql_mapping_template_1.ref(graphql_transformer_common_1.ResourceConstants.SNIPPETS.HasSeenSomeKeyArg), graphql_mapping_template_1.bool(true)), true),
        ]),
        graphql_mapping_template_1.forEach(graphql_mapping_template_1.ref('keyFieldName'), graphql_mapping_template_1.ref('keyFieldNames'), [
            graphql_mapping_template_1.iff(graphql_mapping_template_1.raw(`$${graphql_transformer_common_1.ResourceConstants.SNIPPETS.HasSeenSomeKeyArg} && !$ctx.args.input.containsKey("$keyFieldName")`), graphql_mapping_template_1.raw(`$util.error("When ${keyOperation.replace(/.$/, 'ing')} any part of the composite sort key for @index '${name}',` +
                ` you must provide all fields for the key. Missing key: '$keyFieldName'.")`)),
        ]),
    ]));
}
function mergeInputsAndDefaultsSnippet() {
    return graphql_mapping_template_1.printBlock('Merge default values and inputs')(graphql_model_transformer_1.generateApplyDefaultsToInputTemplate('mergedValues'));
}
function addIndexToResolverSlot(resolver, lines) {
    const res = resolver;
    res.addToSlot('postAuth', graphql_transformer_core_1.MappingTemplate.s3MappingTemplateFromString(lines.join('\n') + '\n{}', `${res.typeName}.${res.fieldName}.{slotName}.{slotIndex}.req.vtl`));
}
//# sourceMappingURL=resolvers.js.map