"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.IndexTransformer = void 0;
const graphql_transformer_core_1 = require("@aws-amplify/graphql-transformer-core");
const graphql_1 = require("graphql");
const graphql_transformer_common_1 = require("graphql-transformer-common");
const resolvers_1 = require("./resolvers");
const schema_1 = require("./schema");
const directiveName = 'index';
const directiveDefinition = `
  directive @${directiveName}(name: String!, sortKeyFields: [String], queryField: String) repeatable on FIELD_DEFINITION
`;
class IndexTransformer extends graphql_transformer_core_1.TransformerPluginBase {
    constructor() {
        super('amplify-index-transformer', directiveDefinition);
        this.directiveList = [];
        this.field = (parent, definition, directive, context) => {
            const directiveWrapped = new graphql_transformer_core_1.DirectiveWrapper(directive);
            const args = directiveWrapped.getArguments({
                object: parent,
                field: definition,
                directive,
            });
            if (!args.sortKeyFields) {
                args.sortKeyFields = [];
            }
            else if (!Array.isArray(args.sortKeyFields)) {
                args.sortKeyFields = [args.sortKeyFields];
            }
            args.sortKey = [];
            validate(args, context);
            this.directiveList.push(args);
        };
        this.transformSchema = (ctx) => {
            const context = ctx;
            for (const config of this.directiveList) {
                schema_1.ensureQueryField(config, context);
                schema_1.addKeyConditionInputs(config, context);
                schema_1.updateMutationConditionInput(config, context);
            }
        };
        this.generateResolvers = (ctx) => {
            for (const config of this.directiveList) {
                resolvers_1.appendSecondaryIndex(config, ctx);
                resolvers_1.updateResolversForIndex(config, ctx);
            }
        };
    }
}
exports.IndexTransformer = IndexTransformer;
function validate(config, ctx) {
    const { name, object, field, sortKeyFields } = config;
    const modelDirective = object.directives.find(directive => {
        return directive.name.value === 'model';
    });
    if (!modelDirective) {
        throw new graphql_transformer_core_1.InvalidDirectiveError(`The @${directiveName} directive may only be added to object definitions annotated with @model.`);
    }
    config.modelDirective = modelDirective;
    const fieldMap = new Map();
    for (const objectField of object.fields) {
        fieldMap.set(objectField.name.value, objectField);
        for (const peerDirective of objectField.directives) {
            if (peerDirective === config.directive) {
                continue;
            }
            if (peerDirective.name.value === 'primaryKey') {
                config.primaryKeyField = objectField;
                if (!peerDirective.arguments.some((arg) => arg.name.value === 'sortKeyFields')) {
                    throw new graphql_transformer_core_1.InvalidDirectiveError(`Invalid @index '${name}'. You may not create an index where the partition key ` +
                        'is the same as that of the primary key unless the primary key has a sort field. ' +
                        'You cannot have a local secondary index without a sort key in the primary key.');
                }
            }
            if (peerDirective.name.value === directiveName &&
                peerDirective.arguments.some((arg) => arg.name.value === 'name' && arg.value.value === name)) {
                throw new graphql_transformer_core_1.InvalidDirectiveError(`You may only supply one @${directiveName} with the name '${name}' on type '${object.name.value}'.`);
            }
        }
    }
    const enums = ctx.output.getTypeDefinitionsOfKind(graphql_1.Kind.ENUM_TYPE_DEFINITION);
    if (!graphql_transformer_common_1.isScalarOrEnum(field.type, enums)) {
        throw new graphql_transformer_core_1.InvalidDirectiveError(`Index '${name}' on type '${object.name.value}.${field.name.value}' cannot be a non-scalar.`);
    }
    for (const sortKeyFieldName of sortKeyFields) {
        const sortField = fieldMap.get(sortKeyFieldName);
        if (!sortField) {
            throw new graphql_transformer_core_1.InvalidDirectiveError(`Can't find field '${sortKeyFieldName}' in ${object.name.value}, but it was specified in index '${name}'.`);
        }
        if (!graphql_transformer_common_1.isScalarOrEnum(sortField.type, enums)) {
            throw new graphql_transformer_core_1.InvalidDirectiveError(`The sort key of index '${name}' on type '${object.name.value}.${sortField.name.value}' cannot be a non-scalar.`);
        }
        config.sortKey.push(sortField);
    }
}
//# sourceMappingURL=graphql-index-transformer.js.map