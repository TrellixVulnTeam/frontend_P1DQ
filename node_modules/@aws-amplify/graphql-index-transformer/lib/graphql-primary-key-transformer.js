"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.PrimaryKeyTransformer = void 0;
const graphql_transformer_core_1 = require("@aws-amplify/graphql-transformer-core");
const graphql_1 = require("graphql");
const graphql_transformer_common_1 = require("graphql-transformer-common");
const resolvers_1 = require("./resolvers");
const schema_1 = require("./schema");
const directiveName = 'primaryKey';
const directiveDefinition = `
  directive @${directiveName}(sortKeyFields: [String]) on FIELD_DEFINITION
`;
class PrimaryKeyTransformer extends graphql_transformer_core_1.TransformerPluginBase {
    constructor() {
        super('amplify-primary-key-transformer', directiveDefinition);
        this.directiveList = [];
        this.field = (parent, definition, directive, context) => {
            const directiveWrapped = new graphql_transformer_core_1.DirectiveWrapper(directive);
            const args = directiveWrapped.getArguments({
                object: parent,
                field: definition,
                directive,
            });
            if (!args.sortKeyFields) {
                args.sortKeyFields = [];
            }
            else if (!Array.isArray(args.sortKeyFields)) {
                args.sortKeyFields = [args.sortKeyFields];
            }
            args.sortKey = [];
            validate(args, context);
            this.directiveList.push(args);
        };
        this.transformSchema = (ctx) => {
            const context = ctx;
            for (const config of this.directiveList) {
                schema_1.updateGetField(config, context);
                schema_1.updateListField(config, context);
                schema_1.updateInputObjects(config, context);
                schema_1.removeAutoCreatedPrimaryKey(config, context);
                schema_1.addKeyConditionInputs(config, context);
                schema_1.updateMutationConditionInput(config, context);
            }
        };
        this.generateResolvers = (ctx) => {
            for (const config of this.directiveList) {
                resolvers_1.replaceDdbPrimaryKey(config, ctx);
                resolvers_1.updateResolvers(config, ctx);
            }
        };
    }
}
exports.PrimaryKeyTransformer = PrimaryKeyTransformer;
function validate(config, ctx) {
    const { object, field, sortKeyFields } = config;
    const modelDirective = object.directives.find(directive => {
        return directive.name.value === 'model';
    });
    if (!modelDirective) {
        throw new graphql_transformer_core_1.InvalidDirectiveError(`The @${directiveName} directive may only be added to object definitions annotated with @model.`);
    }
    config.modelDirective = modelDirective;
    const fieldMap = new Map();
    for (const objectField of object.fields) {
        fieldMap.set(objectField.name.value, objectField);
        if (field === objectField) {
            continue;
        }
        for (const directive of objectField.directives) {
            if (directive.name.value === directiveName) {
                throw new graphql_transformer_core_1.InvalidDirectiveError(`You may only supply one primary key on type '${object.name.value}'.`);
            }
        }
    }
    if (!graphql_transformer_common_1.isNonNullType(field.type)) {
        throw new graphql_transformer_core_1.InvalidDirectiveError(`The primary key on type '${object.name.value}' must reference non-null fields.`);
    }
    const enums = ctx.output.getTypeDefinitionsOfKind(graphql_1.Kind.ENUM_TYPE_DEFINITION);
    if (!graphql_transformer_common_1.isScalarOrEnum(field.type, enums)) {
        throw new graphql_transformer_core_1.InvalidDirectiveError(`The primary key on type '${object.name.value}.${field.name.value}' cannot be a non-scalar.`);
    }
    for (const sortKeyFieldName of sortKeyFields) {
        const sortField = fieldMap.get(sortKeyFieldName);
        if (!sortField) {
            throw new graphql_transformer_core_1.InvalidDirectiveError(`Can't find field '${sortKeyFieldName}' in ${object.name.value}, but it was specified in the primary key.`);
        }
        if (!graphql_transformer_common_1.isScalarOrEnum(sortField.type, enums)) {
            throw new graphql_transformer_core_1.InvalidDirectiveError(`The primary key's sort key on type '${object.name.value}.${sortField.name.value}' cannot be a non-scalar.`);
        }
        config.sortKey.push(sortField);
    }
}
//# sourceMappingURL=graphql-primary-key-transformer.js.map