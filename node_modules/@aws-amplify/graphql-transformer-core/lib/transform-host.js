"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.DefaultTransformHost = void 0;
const core_1 = require("@aws-cdk/core");
const searchable_datasource_1 = require("./cdk-compat/searchable-datasource");
const aws_appsync_1 = require("@aws-cdk/aws-appsync");
const aws_lambda_1 = require("@aws-cdk/aws-lambda");
const appsync_function_1 = require("./appsync-function");
const template_asset_1 = require("./cdk-compat/template-asset");
const graphql_transformer_common_1 = require("graphql-transformer-common");
class DefaultTransformHost {
    constructor(options) {
        this.dataSources = new Map();
        this.getDataSource = (name) => {
            if (this.hasDataSource(name)) {
                return this.dataSources.get(name);
            }
        };
        this.api = options.api;
    }
    setAPI(api) {
        this.api = api;
    }
    hasDataSource(name) {
        return this.dataSources.has(name);
    }
    addSearchableDataSource(name, awsRegion, endpoint, options, stack) {
        if (this.dataSources.has(name)) {
            throw new Error(`DataSource ${name} already exists in the API`);
        }
        const data = this.doAddSearchableDataSource(name, endpoint, awsRegion, options, stack);
        this.dataSources.set((options === null || options === void 0 ? void 0 : options.name) || name, data);
        return data;
    }
    addHttpDataSource(name, endpoint, options, stack) {
        if (this.dataSources.has(name)) {
            throw new Error(`DataSource ${name} already exists in the API`);
        }
        const dataSource = this.doAddHttpDataSource(name, endpoint, options, stack);
        this.dataSources.set(name, dataSource);
        return dataSource;
    }
    addDynamoDbDataSource(name, table, options, stack) {
        if (this.dataSources.has(name)) {
            throw new Error(`DataSource ${name} already exists in the API`);
        }
        const dataSource = this.doAddDynamoDbDataSource(name, table, options, stack);
        this.dataSources.set((options === null || options === void 0 ? void 0 : options.name) || name, dataSource);
        return dataSource;
    }
    addNoneDataSource(name, options, stack) {
        if (this.dataSources.has(name)) {
            throw new Error(`DataSource ${name} already exists in the API`);
        }
        const dataSource = this.doAddNoneDataSource(name, options, stack);
        this.dataSources.set(name, dataSource);
        return dataSource;
    }
    addLambdaDataSource(name, lambdaFunction, options, stack) {
        if (!core_1.Token.isUnresolved(name) && this.dataSources.has(name)) {
            throw new Error(`DataSource ${name} already exists in the API`);
        }
        const dataSource = this.doAddLambdaDataSource(name, lambdaFunction, options, stack);
        this.dataSources.set(name, dataSource);
        return dataSource;
    }
    addAppSyncFunction(name, requestMappingTemplate, responseMappingTemplate, dataSourceName, stack) {
        if (dataSourceName && !core_1.Token.isUnresolved(dataSourceName) && !this.dataSources.has(dataSourceName)) {
            throw new Error(`DataSource ${dataSourceName} is missing in the API`);
        }
        const dataSource = this.dataSources.get(dataSourceName);
        const fn = new appsync_function_1.AppSyncFunctionConfiguration(stack || this.api, name, {
            api: this.api,
            dataSource: dataSource || dataSourceName,
            requestMappingTemplate,
            responseMappingTemplate,
        });
        return fn;
    }
    addResolver(typeName, fieldName, requestMappingTemplate, responseMappingTemplate, dataSourceName, pipelineConfig, stack) {
        if (dataSourceName && !core_1.Token.isUnresolved(dataSourceName) && !this.dataSources.has(dataSourceName)) {
            throw new Error(`DataSource ${dataSourceName} is missing in the API`);
        }
        const requestTemplateLocation = requestMappingTemplate.bind(this.api);
        const responseTemplateLocation = responseMappingTemplate.bind(this.api);
        const resolverName = graphql_transformer_common_1.toCamelCase([typeName, fieldName, 'Resolver']);
        if (dataSourceName) {
            const dataSource = this.dataSources.get(dataSourceName);
            const resolver = new aws_appsync_1.CfnResolver(stack || this.api, resolverName, {
                apiId: this.api.apiId,
                fieldName: fieldName,
                typeName: typeName,
                kind: 'UNIT',
                dataSourceName: (dataSource === null || dataSource === void 0 ? void 0 : dataSource.ds.attrName) || dataSourceName,
                ...(requestMappingTemplate instanceof template_asset_1.InlineTemplate
                    ? { requestMappingTemplate: requestTemplateLocation }
                    : { requestMappingTemplateS3Location: requestTemplateLocation }),
                ...(responseMappingTemplate instanceof template_asset_1.InlineTemplate
                    ? { responseMappingTemplate: responseTemplateLocation }
                    : { responseMappingTemplateS3Location: responseTemplateLocation }),
            });
            this.api.addSchemaDependency(resolver);
            return resolver;
        }
        else if (pipelineConfig) {
            const resolver = new aws_appsync_1.CfnResolver(stack || this.api, resolverName, {
                apiId: this.api.apiId,
                fieldName: fieldName,
                typeName: typeName,
                kind: 'PIPELINE',
                ...(requestMappingTemplate instanceof template_asset_1.InlineTemplate
                    ? { requestMappingTemplate: requestTemplateLocation }
                    : { requestMappingTemplateS3Location: requestTemplateLocation }),
                ...(responseMappingTemplate instanceof template_asset_1.InlineTemplate
                    ? { responseMappingTemplate: responseTemplateLocation }
                    : { responseMappingTemplateS3Location: responseTemplateLocation }),
                pipelineConfig: {
                    functions: pipelineConfig,
                },
            });
            this.api.addSchemaDependency(resolver);
            return resolver;
        }
        else {
            throw new Error('Resolver needs either dataSourceName or pipelineConfig to be passed');
        }
    }
    addLambdaFunction(functionName, functionKey, handlerName, filePath, runtime, layers, role, environment, timeout, stack) {
        const dummycode = `if __name__ == "__main__":`;
        const fn = new aws_lambda_1.Function(stack || this.api, functionName, {
            code: aws_lambda_1.Code.fromInline(dummycode),
            handler: handlerName,
            runtime,
            role,
            layers,
            environment,
            timeout,
        });
        fn.addLayers();
        const functionCode = new template_asset_1.S3MappingFunctionCode(functionKey, filePath).bind(fn);
        fn.node.defaultChild.code = {
            s3Key: functionCode.s3ObjectKey,
            s3Bucket: functionCode.s3BucketName,
        };
        return fn;
    }
    doAddNoneDataSource(id, options, stack) {
        return new aws_appsync_1.NoneDataSource(stack !== null && stack !== void 0 ? stack : this.api, id, {
            api: this.api,
            name: options === null || options === void 0 ? void 0 : options.name,
            description: options === null || options === void 0 ? void 0 : options.description,
        });
    }
    doAddDynamoDbDataSource(id, table, options, stack) {
        return new aws_appsync_1.DynamoDbDataSource(stack !== null && stack !== void 0 ? stack : this.api, id, {
            api: this.api,
            table,
            name: options === null || options === void 0 ? void 0 : options.name,
            description: options === null || options === void 0 ? void 0 : options.description,
            serviceRole: options === null || options === void 0 ? void 0 : options.serviceRole,
        });
    }
    doAddHttpDataSource(id, endpoint, options, stack) {
        return new aws_appsync_1.HttpDataSource(stack !== null && stack !== void 0 ? stack : this.api, id, {
            api: this.api,
            endpoint,
            name: options === null || options === void 0 ? void 0 : options.name,
            description: options === null || options === void 0 ? void 0 : options.description,
            authorizationConfig: options === null || options === void 0 ? void 0 : options.authorizationConfig,
        });
    }
    doAddSearchableDataSource(id, endpoint, region, options, stack) {
        return new searchable_datasource_1.SearchableDataSource(stack !== null && stack !== void 0 ? stack : this.api, id, {
            api: this.api,
            name: options === null || options === void 0 ? void 0 : options.name,
            endpoint,
            region,
            serviceRole: options === null || options === void 0 ? void 0 : options.serviceRole,
        });
    }
    doAddLambdaDataSource(id, lambdaFunction, options, stack) {
        return new aws_appsync_1.LambdaDataSource(stack || this.api, id, {
            api: this.api,
            lambdaFunction,
            name: options === null || options === void 0 ? void 0 : options.name,
            description: options === null || options === void 0 ? void 0 : options.description,
        });
    }
}
exports.DefaultTransformHost = DefaultTransformHost;
//# sourceMappingURL=transform-host.js.map