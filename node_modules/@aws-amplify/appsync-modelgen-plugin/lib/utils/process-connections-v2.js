"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.processConnectionsV2 = exports.getConnectedFieldV2 = void 0;
const process_connections_1 = require("./process-connections");
const process_has_one_1 = require("./process-has-one");
const process_belongs_to_1 = require("./process-belongs-to");
const process_has_many_1 = require("./process-has-many");
function getConnectedFieldV2(field, model, connectedModel, directiveName) {
    const connectionInfo = process_connections_1.getDirective(field)(directiveName);
    if (!connectionInfo) {
        throw new Error(`The ${field.name} on model ${model.name} is not connected`);
    }
    const indexName = connectionInfo.arguments.indexName;
    const connectionFields = connectionInfo.arguments.fields;
    if (connectionFields) {
        let indexDirective;
        if (indexName) {
            indexDirective = process_connections_1.flattenFieldDirectives(connectedModel).find(dir => {
                return dir.name === 'index' && dir.arguments.name === indexName;
            });
            if (!indexDirective) {
                throw new Error(`Error processing @${connectionInfo.name} directive on ${model.name}.${field.name}, @index directive with name ${indexName} was not found in connected model ${connectedModel.name}`);
            }
        }
        else {
            indexDirective = process_connections_1.flattenFieldDirectives(connectedModel).find(dir => {
                return dir.name === 'primaryKey';
            });
        }
        const connectedFieldName = indexDirective ? ((fieldDir) => { return fieldDir.fieldName; })(indexDirective) : process_connections_1.DEFAULT_HASH_KEY_FIELD;
        const otherSideConnectedField = connectedModel.fields.find(f => {
            return f.directives.find(d => {
                return (d.name === 'belongsTo' || d.name === 'hasOne' || d.name === 'hasMany') && d.arguments.fields && d.arguments.fields[0] === connectedFieldName;
            });
        });
        if (otherSideConnectedField) {
            return otherSideConnectedField;
        }
        const connectedField = connectedModel.fields.find(f => f.name === connectedFieldName);
        if (!connectedField) {
            throw new Error(`Can not find key field ${connectedFieldName} in ${connectedModel}`);
        }
        return connectedField;
    }
    const connectedFieldName = process_connections_1.makeConnectionAttributeName(model.name, field.name);
    const connectedField = connectedModel.fields.find(f => f.name === connectedFieldName);
    return connectedField
        ? connectedField
        : {
            name: connectedFieldName,
            directives: [],
            type: 'ID',
            isList: false,
            isNullable: true,
        };
}
exports.getConnectedFieldV2 = getConnectedFieldV2;
function processConnectionsV2(field, model, modelMap) {
    const connectionDirective = field.directives.find(d => d.name === 'hasOne' || d.name === 'hasMany' || d.name === 'belongsTo');
    if (connectionDirective) {
        switch (connectionDirective.name) {
            case 'hasOne':
                return process_has_one_1.processHasOneConnection(field, model, modelMap, connectionDirective);
            case 'belongsTo':
                return process_belongs_to_1.processBelongsToConnection(field, model, modelMap, connectionDirective);
            case 'hasMany':
                return process_has_many_1.processHasManyConnection(field, model, modelMap, connectionDirective);
            default:
                break;
        }
    }
}
exports.processConnectionsV2 = processConnectionsV2;
//# sourceMappingURL=process-connections-v2.js.map