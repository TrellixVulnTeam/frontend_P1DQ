"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.AppSyncModelDartVisitor = void 0;
const appsync_visitor_1 = require("./appsync-visitor");
const dart_declaration_block_1 = require("../languages/dart-declaration-block");
const process_connections_1 = require("../utils/process-connections");
const visitor_plugin_common_1 = require("@graphql-codegen/visitor-plugin-common");
const process_auth_1 = require("../utils/process-auth");
const warn_1 = require("../utils/warn");
const dart_config_1 = require("../configs/dart-config");
const dart_style_1 = __importDefault(require("dart-style"));
const generateLicense_1 = require("../utils/generateLicense");
const lower_case_first_1 = require("lower-case-first");
const scalars_1 = require("../scalars");
class AppSyncModelDartVisitor extends appsync_visitor_1.AppSyncModelVisitor {
    constructor(schema, rawConfig, additionalConfig, defaultScalars = scalars_1.DART_SCALAR_MAP) {
        super(schema, rawConfig, additionalConfig, defaultScalars);
        this._parsedConfig.enableDartNullSafety = rawConfig.enableDartNullSafety || false;
    }
    generate() {
        this.processDirectives();
        this.validateReservedKeywords();
        if (this._parsedConfig.generate === appsync_visitor_1.CodeGenGenerateEnum.loader) {
            return this.generateClassLoader();
        }
        else if (this.selectedTypeIsEnum()) {
            return this.generateEnums();
        }
        return this.generateModelClasses();
    }
    validateReservedKeywords() {
        Object.entries({ ...this.models, ...this.nonModels }).forEach(([name, obj]) => {
            if (dart_config_1.DART_RESERVED_KEYWORDS.includes(name)) {
                throw new Error(`Type name '${name}' is a reserved word in dart. Please use a non-reserved name instead.`);
            }
            obj.fields.forEach(field => {
                const fieldName = this.getFieldName(field);
                if (dart_config_1.DART_RESERVED_KEYWORDS.includes(fieldName)) {
                    throw new Error(`Field name '${fieldName}' in type '${name}' is a reserved word in dart. Please use a non-reserved name instead.`);
                }
            });
        });
        Object.entries(this.enums).forEach(([name, enumVal]) => {
            if (dart_config_1.DART_RESERVED_KEYWORDS.includes(name)) {
                throw new Error(`Enum name '${name}' is a reserved word in dart. Please use a non-reserved name instead.`);
            }
            Object.values(enumVal.values).forEach(val => {
                if (dart_config_1.DART_RESERVED_KEYWORDS.includes(val)) {
                    throw new Error(`Enum value '${val}' in enum '${name}' is a reserved word in dart. Please use a non-reserved name instead.`);
                }
            });
        });
    }
    generateClassLoader() {
        const result = [];
        const modelNames = Object.keys(this.modelMap).sort();
        const exportClasses = [...modelNames, ...Object.keys(this.enumMap)].sort();
        const license = generateLicense_1.generateLicense();
        result.push(license);
        result.push(dart_config_1.IGNORE_FOR_FILE);
        const packageImports = ['package:amplify_datastore_plugin_interface/amplify_datastore_plugin_interface', ...modelNames];
        const packageExports = [...exportClasses];
        const classDeclarationBlock = new dart_declaration_block_1.DartDeclarationBlock()
            .asKind('class')
            .withName(dart_config_1.LOADER_CLASS_NAME)
            .implements([`${dart_config_1.LOADER_CLASS_NAME}Interface`])
            .addClassMember('version', 'String', `"${this.computeVersion()}"`, undefined, ['override'])
            .addClassMember('modelSchemas', 'List<ModelSchema>', `[${modelNames.map(m => `${m}.schema`).join(', ')}]`, undefined, ['override'])
            .addClassMember('_instance', dart_config_1.LOADER_CLASS_NAME, `${dart_config_1.LOADER_CLASS_NAME}()`, { static: true, final: true })
            .addClassMethod('get instance', dart_config_1.LOADER_CLASS_NAME, [], ' => _instance;', { isBlock: false, isGetter: true, static: true });
        if (modelNames.length) {
            const getModelTypeImplStr = [
                'switch(modelName) {',
                ...modelNames.map(modelName => [`case "${modelName}": {`, `return ${modelName}.classType;`, '}', 'break;'].join('\n')),
                'default: {',
                'throw Exception("Failed to find model in model provider for model name: " + modelName);',
                '}',
                '}',
            ].join('\n');
            classDeclarationBlock.addClassMethod('getModelTypeByModelName', 'ModelType', [{ type: 'String', name: 'modelName' }], getModelTypeImplStr);
        }
        result.push(packageImports.map(p => `import '${p}.dart';`).join('\n'));
        result.push(packageExports.map(p => `export '${p}.dart';`).join('\n'));
        result.push(classDeclarationBlock.string);
        return this.formatDartCode(result.join('\n\n'));
    }
    generateEnums() {
        const result = [];
        const license = generateLicense_1.generateLicense();
        result.push(license);
        result.push(dart_config_1.IGNORE_FOR_FILE);
        Object.entries(this.getSelectedEnums()).forEach(([name, enumVal]) => {
            const body = Object.values(enumVal.values).join(',\n');
            result.push([`enum ${name} {`, visitor_plugin_common_1.indentMultiline(body), '}'].join('\n'));
        });
        return this.formatDartCode(result.join('\n\n'));
    }
    generateModelClasses() {
        const result = [];
        const license = generateLicense_1.generateLicense();
        result.push(license);
        result.push(dart_config_1.IGNORE_FOR_FILE);
        const packageImports = this.generatePackageHeader();
        result.push(packageImports);
        Object.entries(this.getSelectedModels()).forEach(([name, model]) => {
            const modelDeclaration = this.generateModelClass(model);
            const modelType = this.generateModelType(model);
            result.push(modelDeclaration);
            result.push(modelType);
        });
        return this.formatDartCode(result.join('\n\n'));
    }
    generatePackageHeader() {
        let usingCollection = false;
        let usingOtherClass = false;
        Object.entries(this.getSelectedModels()).forEach(([name, model]) => {
            model.fields.forEach(f => {
                if (f.isList) {
                    usingCollection = true;
                }
                if (this.isModelType(f) || this.isEnumType(f)) {
                    usingOtherClass = true;
                }
            });
        });
        return ([...dart_config_1.BASE_IMPORT_PACKAGES, usingCollection ? dart_config_1.COLLECTION_PACKAGE : '', usingOtherClass ? `${dart_config_1.LOADER_CLASS_NAME}.dart` : '']
            .filter(f => f)
            .sort()
            .map(pckg => `import '${pckg}';`)
            .join('\n') + '\n');
    }
    generateModelClass(model) {
        const classDeclarationBlock = new dart_declaration_block_1.DartDeclarationBlock()
            .asKind('class')
            .withName(this.getModelName(model))
            .extends(['Model'])
            .withComment(`This is an auto generated class representing the ${model.name} type in your schema.`)
            .annotate(['immutable']);
        classDeclarationBlock.addClassMember('classType', '', `const _${this.getModelName(model)}ModelType()`, { static: true, const: true });
        model.fields.forEach(field => {
            this.generateModelField(field, '', classDeclarationBlock);
        });
        classDeclarationBlock.addClassMethod('getInstanceType', '', [], ' => classType;', { isBlock: false }, ['override']);
        this.generateGetters(model, classDeclarationBlock);
        this.generateConstructor(model, classDeclarationBlock);
        this.generateEqualsMethodAndOperator(model, classDeclarationBlock);
        this.generateHashCodeMethod(model, classDeclarationBlock);
        this.generateToStringMethod(model, classDeclarationBlock);
        this.generateCopyWithMethod(model, classDeclarationBlock);
        this.generateSerializationMethod(model, classDeclarationBlock);
        this.generateModelSchema(model, classDeclarationBlock);
        return classDeclarationBlock.string;
    }
    generateModelType(model) {
        const modelName = this.getModelName(model);
        const classDeclarationBlock = new dart_declaration_block_1.DartDeclarationBlock()
            .asKind('class')
            .withName(`_${modelName}ModelType`)
            .extends([`ModelType<${modelName}>`]);
        classDeclarationBlock.addClassMethod(`_${modelName}ModelType`, '', [], ';', { const: true, isBlock: false });
        classDeclarationBlock.addClassMethod('fromJson', modelName, [{ name: 'jsonData', type: 'Map<String, dynamic>' }], `return ${modelName}.fromJson(jsonData);`, undefined, ['override']);
        return classDeclarationBlock.string;
    }
    generateModelField(field, value, classDeclarationBlock) {
        const fieldType = this.getNativeType(field);
        const fieldName = this.getFieldName(field);
        if (this.isNullSafety() && fieldName !== 'id') {
            classDeclarationBlock.addClassMember(`_${fieldName}`, `${fieldType}?`, value, { final: true });
        }
        else {
            classDeclarationBlock.addClassMember(fieldName, fieldType, value, { final: true });
        }
    }
    generateGetters(model, declarationBlock) {
        declarationBlock.addClassMethod('getId', 'String', [], 'return id;', {}, ['override']);
        if (this.isNullSafety()) {
            model.fields.forEach(field => {
                const fieldName = this.getFieldName(field);
                const fieldType = this.getNativeType(field);
                const returnType = this.isFieldRequired(field) ? fieldType : `${fieldType}?`;
                const getterImpl = this.isFieldRequired(field)
                    ? [
                        `try {`,
                        visitor_plugin_common_1.indent(`return _${fieldName}!;`),
                        '} catch(e) {',
                        visitor_plugin_common_1.indent('throw new DataStoreException(DataStoreExceptionMessages.codeGenRequiredFieldForceCastExceptionMessage, recoverySuggestion: DataStoreExceptionMessages.codeGenRequiredFieldForceCastRecoverySuggestion, underlyingException: e.toString());'),
                        '}',
                    ].join('\n')
                    : `return _${fieldName};`;
                if (fieldName !== 'id') {
                    declarationBlock.addClassMethod(`get ${fieldName}`, returnType, undefined, getterImpl, { isGetter: true, isBlock: true });
                }
            });
        }
    }
    generateConstructor(model, declarationBlock) {
        const args = this.isNullSafety()
            ? `{${model.fields
                .map(f => `${this.isFieldRequired(f) ? 'required ' : ''}${this.getFieldName(f) === 'id' ? 'this.' : ''}${this.getFieldName(f)}`)
                .join(', ')}}`
            : `{${model.fields.map(f => `${this.isFieldRequired(f) ? '@required ' : ''}this.${this.getFieldName(f)}`).join(', ')}}`;
        const internalFields = model.fields.filter(f => this.getFieldName(f) !== 'id');
        const internalImpl = this.isNullSafety()
            ? internalFields.length
                ? `: ${internalFields.map(f => `_${this.getFieldName(f)} = ${this.getFieldName(f)}`).join(', ')};`
                : ';'
            : ';';
        declarationBlock.addClassMethod(`${this.getModelName(model)}._internal`, '', [{ name: args }], internalImpl, {
            const: true,
            isBlock: false,
        });
        const returnParamStr = model.fields
            .map(field => {
            const fieldName = this.getFieldName(field);
            if (fieldName === 'id') {
                return 'id: id == null ? UUID.getUUID() : id';
            }
            else if (field.isList) {
                return `${fieldName}: ${fieldName} != null ? ${this.getNativeType(field)}.unmodifiable(${fieldName}) : ${fieldName}`;
            }
            else {
                return `${fieldName}: ${fieldName}`;
            }
        })
            .join(',\n');
        const factoryImpl = [`return ${this.getModelName(model)}._internal(`, visitor_plugin_common_1.indentMultiline(`${returnParamStr});`)].join('\n');
        const factoryParam = this.isNullSafety()
            ? `{${model.fields
                .map(f => {
                if (this.getFieldName(f) === 'id' || !this.isFieldRequired(f)) {
                    return `${this.getNativeType(f)}? ${this.getFieldName(f)}`;
                }
                return `required ${this.getNativeType(f)} ${this.getFieldName(f)}`;
            })
                .join(', ')}}`
            : `{${model.fields
                .map(f => `${this.getFieldName(f) !== 'id' && this.isFieldRequired(f) ? '@required ' : ''}${this.getNativeType(f)} ${this.getFieldName(f)}`)
                .join(', ')}}`;
        declarationBlock.addClassMethod(this.getModelName(model), 'factory', [{ name: factoryParam }], factoryImpl);
    }
    generateEqualsMethodAndOperator(model, declarationBlock) {
        declarationBlock.addClassMethod('equals', 'bool', [{ name: 'other', type: 'Object' }], 'return this == other;');
        const equalImpl = [
            'if (identical(other, this)) return true;',
            `return other is ${this.getModelName(model)} &&`,
            visitor_plugin_common_1.indentMultiline(`${model.fields
                .map(f => {
                const fieldName = `${this.isNullSafety() && f.name !== 'id' ? '_' : ''}${this.getFieldName(f)}`;
                return f.isList ? `DeepCollectionEquality().equals(${fieldName}, other.${fieldName})` : `${fieldName} == other.${fieldName}`;
            })
                .join(' &&\n')};`),
        ].join('\n');
        declarationBlock.addClassMethod('operator ==', 'bool', [{ name: 'other', type: 'Object' }], equalImpl, undefined, ['override']);
    }
    generateHashCodeMethod(model, declarationBlock) {
        declarationBlock.addClassMethod(`get hashCode`, `int`, undefined, ' => toString().hashCode;', { isGetter: true, isBlock: false }, [
            'override',
        ]);
    }
    generateToStringMethod(model, declarationBlock) {
        const fields = this.getNonConnectedField(model);
        declarationBlock.addClassMethod('toString', 'String', [], [
            'var buffer = new StringBuffer();',
            '',
            `buffer.write("${this.getModelName(model)} {");`,
            ...fields.map((field, index) => {
                const fieldDelimiter = ', ';
                const varName = this.getFieldName(field);
                const fieldName = `${this.isNullSafety() && field.name !== 'id' ? '_' : ''}${this.getFieldName(field)}`;
                let toStringVal = '';
                if (this.isEnumType(field)) {
                    if (field.isList) {
                        toStringVal = this.isNullSafety()
                            ? `(${fieldName} != null ? ${fieldName}!.map((e) => enumToString(e)).toString() : "null")`
                            : `${fieldName}?.map((e) => enumToString(e)).toString()`;
                    }
                    else {
                        toStringVal = `(${fieldName} != null ? enumToString(${fieldName})${this.isNullSafety() ? '!' : ''} : "null")`;
                    }
                }
                else {
                    const fieldNativeType = this.getNativeType(field);
                    switch (fieldNativeType) {
                        case 'String':
                            toStringVal = `"$${fieldName}"`;
                            break;
                        case this.scalars['AWSDate']:
                        case this.scalars['AWSTime']:
                        case this.scalars['AWSDateTime']:
                            toStringVal = `(${fieldName} != null ? ${fieldName}${this.isNullSafety() ? '!' : ''}.format() : "null")`;
                            break;
                        default:
                            toStringVal = `(${fieldName} != null ? ${fieldName}${this.isNullSafety() ? '!' : ''}.toString() : "null")`;
                    }
                }
                if (index !== fields.length - 1) {
                    return `buffer.write("${varName}=" + ${toStringVal} + "${fieldDelimiter}");`;
                }
                return `buffer.write("${varName}=" + ${toStringVal});`;
            }),
            `buffer.write("}");`,
            '',
            'return buffer.toString();',
        ].join('\n'), undefined, ['override']);
    }
    generateCopyWithMethod(model, declarationBlock) {
        const copyParam = `{${model.fields
            .map(f => `${this.getNativeType(f)}${this.isNullSafety() ? '?' : ''} ${this.getFieldName(f)}`)
            .join(', ')}}`;
        declarationBlock.addClassMethod('copyWith', this.getModelName(model), [{ name: copyParam }], [
            `return ${this.getModelName(model)}(`,
            visitor_plugin_common_1.indentMultiline(`${model.fields
                .map(field => {
                const fieldName = this.getFieldName(field);
                return `${fieldName}: ${fieldName} ?? this.${fieldName}`;
            })
                .join(',\n')});`),
        ].join('\n'));
    }
    generateSerializationMethod(model, declarationBlock) {
        const serializationImpl = `\n: ${visitor_plugin_common_1.indentMultiline(model.fields
            .map(field => {
            const varName = this.getFieldName(field);
            const fieldName = `${this.isNullSafety() && field.name !== 'id' ? '_' : ''}${this.getFieldName(field)}`;
            if (this.isModelType(field)) {
                if (field.isList) {
                    return [
                        `${fieldName} = json['${varName}'] is List`,
                        visitor_plugin_common_1.indent(`? (json['${varName}'] as List)`),
                        this.isNullSafety() ? visitor_plugin_common_1.indent(`.where((e) => e?['serializedData'] != null)`, 2) : undefined,
                        visitor_plugin_common_1.indent(`.map((e) => ${this.getNativeType({ ...field, isList: false })}.fromJson(new Map<String, dynamic>.from(e${this.isNullSafety() ? `['serializedData']` : ''})))`, 2),
                        visitor_plugin_common_1.indent(`.toList()`, 2),
                        visitor_plugin_common_1.indent(`: null`),
                    ]
                        .filter(e => e !== undefined)
                        .join('\n');
                }
                return [
                    `${fieldName} = json['${varName}']${this.isNullSafety() ? `?['serializedData']` : ''} != null`,
                    visitor_plugin_common_1.indent(`? ${this.getNativeType(field)}.fromJson(new Map<String, dynamic>.from(json['${varName}']${this.isNullSafety() ? `['serializedData']` : ''}))`),
                    visitor_plugin_common_1.indent(`: null`),
                ].join('\n');
            }
            if (this.isEnumType(field)) {
                if (field.isList) {
                    return [
                        `${fieldName} = json['${varName}'] is List`,
                        visitor_plugin_common_1.indent(`? (json['${varName}'] as List)`),
                        visitor_plugin_common_1.indent(`.map((e) => enumFromString<${field.type}>(e, ${field.type}.values)${this.isNullSafety() ? '!' : ''})`, 2),
                        visitor_plugin_common_1.indent(`.toList()`, 2),
                        visitor_plugin_common_1.indent(`: null`),
                    ].join('\n');
                }
                return `${fieldName} = enumFromString<${field.type}>(json['${varName}'], ${field.type}.values)`;
            }
            const fieldNativeType = this.getNativeType({ ...field, isList: false });
            switch (fieldNativeType) {
                case this.scalars['AWSDate']:
                case this.scalars['AWSTime']:
                case this.scalars['AWSDateTime']:
                    return field.isList
                        ? `${fieldName} = (json['${varName}'] as ${this.getNullSafetyTypeStr('List')})?.map((e) => ${fieldNativeType}.fromString(e)).toList()`
                        : `${fieldName} = json['${varName}'] != null ? ${fieldNativeType}.fromString(json['${varName}']) : null`;
                case this.scalars['AWSTimestamp']:
                    return field.isList
                        ? `${fieldName} = (json['${varName}'] as ${this.getNullSafetyTypeStr('List')})?.map((e) => ${fieldNativeType}.fromSeconds(e)).toList()`
                        : `${fieldName} = json['${varName}'] != null ? ${fieldNativeType}.fromSeconds(json['${varName}']) : null`;
                case this.scalars['Int']:
                    return field.isList
                        ? `${fieldName} = (json['${varName}'] as ${this.getNullSafetyTypeStr('List')})?.map((e) => (e as num).toInt()).toList()`
                        : `${fieldName} = (json['${varName}'] as ${this.getNullSafetyTypeStr('num')})?.toInt()`;
                case this.scalars['Float']:
                    return field.isList
                        ? `${fieldName} = (json['${varName}'] as ${this.getNullSafetyTypeStr('List')})?.map((e) => (e as num).toDouble()).toList()`
                        : `${fieldName} = (json['${varName}'] as ${this.getNullSafetyTypeStr('num')})?.toDouble()`;
                default:
                    return field.isList
                        ? `${fieldName} = json['${varName}']?.cast<${this.getNativeType({ ...field, isList: false })}>()`
                        : `${fieldName} = json['${varName}']`;
            }
        })
            .join(',\n')).trim()};`;
        declarationBlock.addClassMethod(`${this.getModelName(model)}.fromJson`, ``, [{ name: 'json', type: 'Map<String, dynamic>' }], visitor_plugin_common_1.indentMultiline(serializationImpl), { isBlock: false });
        const toJsonFields = model.fields
            .map(field => {
            const varName = this.getFieldName(field);
            const fieldName = `${this.isNullSafety() && field.name !== 'id' ? '_' : ''}${this.getFieldName(field)}`;
            if (this.isModelType(field)) {
                if (field.isList) {
                    const modelName = this.getNativeType({ ...field, isList: false });
                    return `'${varName}': ${fieldName}?.map((${modelName}? e) => e?.toJson()).toList()`;
                }
                return `'${varName}': ${fieldName}?.toJson()`;
            }
            if (this.isEnumType(field)) {
                if (field.isList) {
                    return `'${varName}': ${fieldName}?.map((e) => enumToString(e)).toList()`;
                }
                return `'${varName}': enumToString(${fieldName})`;
            }
            const fieldNativeType = this.getNativeType({ ...field, isList: false });
            switch (fieldNativeType) {
                case this.scalars['AWSDate']:
                case this.scalars['AWSTime']:
                case this.scalars['AWSDateTime']:
                    return field.isList ? `'${varName}': ${fieldName}?.map((e) => e.format()).toList()` : `'${varName}': ${fieldName}?.format()`;
                case this.scalars['AWSTimestamp']:
                    return field.isList
                        ? `'${varName}': ${fieldName}?.map((e) => e.toSeconds()).toList()`
                        : `'${varName}': ${fieldName}?.toSeconds()`;
                default:
                    return `'${varName}': ${fieldName}`;
            }
        })
            .join(', ');
        const deserializationImpl = [' => {', visitor_plugin_common_1.indentMultiline(toJsonFields), '};'].join('\n');
        declarationBlock.addClassMethod('toJson', 'Map<String, dynamic>', [], deserializationImpl, { isBlock: false });
    }
    generateModelSchema(model, classDeclarationBlock) {
        const schemaDeclarationBlock = new dart_declaration_block_1.DartDeclarationBlock();
        model.fields.forEach(field => {
            this.generateQueryField(model, field, schemaDeclarationBlock);
        });
        this.generateSchemaField(model, schemaDeclarationBlock);
        classDeclarationBlock.addBlock(schemaDeclarationBlock);
    }
    generateQueryField(model, field, declarationBlock) {
        const fieldName = this.getFieldName(field);
        const queryFieldName = this.getQueryFieldName(field);
        let value = `QueryField(fieldName: "${fieldName}")`;
        if (this.isModelType(field)) {
            const modelName = this.getNativeType({ ...field, isList: false });
            value = [
                'QueryField(',
                visitor_plugin_common_1.indent(`fieldName: "${fieldName}",`),
                visitor_plugin_common_1.indent(`fieldType: ModelFieldType(ModelFieldTypeEnum.model, ofModelName: (${modelName}).toString()))`),
            ].join('\n');
        }
        else if (fieldName === 'id') {
            value = `QueryField(fieldName: "${lower_case_first_1.lowerCaseFirst(model.name)}.id")`;
        }
        declarationBlock.addClassMember(queryFieldName, 'QueryField', value, { static: true, final: true });
    }
    getQueryFieldName(field) {
        return this.getFieldName(field).toUpperCase();
    }
    generateSchemaField(model, declarationBlock) {
        const schema = [
            'Model.defineSchema(define: (ModelSchemaDefinition modelSchemaDefinition) {',
            visitor_plugin_common_1.indentMultiline([
                `modelSchemaDefinition.name = "${this.getModelName(model)}";\nmodelSchemaDefinition.pluralName = "${this.pluralizeModelName(model)}";`,
                this.generateAuthRules(model),
                this.generateAddFields(model),
            ]
                .filter(f => f)
                .join('\n\n')),
            '})',
        ].join('\n');
        declarationBlock.addClassMember('schema', '', schema, { static: true, var: true });
    }
    generateAuthRules(model) {
        const authDirectives = model.directives.filter(d => d.name === 'auth');
        if (authDirectives.length) {
            const rules = [];
            authDirectives.forEach(directive => {
                var _a;
                (_a = directive.arguments) === null || _a === void 0 ? void 0 : _a.rules.forEach(rule => {
                    var _a;
                    const authRule = [];
                    const authStrategy = `authStrategy: AuthStrategy.${rule.allow.toUpperCase()}`;
                    switch (rule.allow) {
                        case process_auth_1.AuthStrategy.owner:
                            authRule.push(authStrategy);
                            authRule.push(`ownerField: "${rule.ownerField}"`);
                            authRule.push(`identityClaim: "${rule.identityClaim}"`);
                            break;
                        case process_auth_1.AuthStrategy.private:
                        case process_auth_1.AuthStrategy.public:
                            authRule.push(authStrategy);
                            break;
                        case process_auth_1.AuthStrategy.groups:
                            authRule.push(authStrategy);
                            authRule.push(`groupClaim: "${rule.groupClaim}"`);
                            if (rule.groups) {
                                authRule.push(`groups: [ ${(_a = rule.groups) === null || _a === void 0 ? void 0 : _a.map(group => `"${group}"`).join(', ')} ]`);
                            }
                            else {
                                authRule.push(`groupsField: "${rule.groupField}"`);
                            }
                            break;
                        default:
                            warn_1.printWarning(`Model has auth with authStrategy ${rule.allow} of which is not yet supported`);
                            return '';
                    }
                    authRule.push(['operations: [', visitor_plugin_common_1.indentMultiline(rule.operations.map(op => `ModelOperation.${op.toUpperCase()}`).join(',\n')), ']'].join('\n'));
                    rules.push(`AuthRule(\n${visitor_plugin_common_1.indentMultiline(authRule.join(',\n'))})`);
                });
            });
            if (rules.length) {
                return ['modelSchemaDefinition.authRules = [', visitor_plugin_common_1.indentMultiline(rules.join(',\n')), '];'].join('\n');
            }
        }
        return '';
    }
    generateAddFields(model) {
        if (model.fields.length) {
            const fieldsToAdd = [];
            model.fields.forEach(field => {
                const fieldName = this.getFieldName(field);
                const modelName = this.getModelName(model);
                const queryFieldName = this.getQueryFieldName(field);
                let fieldParam = '';
                if (fieldName === 'id') {
                    fieldsToAdd.push('ModelFieldDefinition.id()');
                }
                else if (field.connectionInfo) {
                    const connectedModelName = this.getNativeType({ ...field, isList: false });
                    switch (field.connectionInfo.kind) {
                        case process_connections_1.CodeGenConnectionType.HAS_ONE:
                            fieldParam = [
                                `key: ${modelName}.${queryFieldName}`,
                                `isRequired: ${!field.isNullable}`,
                                `ofModelName: (${connectedModelName}).toString()`,
                                `associatedKey: ${connectedModelName}.${this.getQueryFieldName(field.connectionInfo.associatedWith)}`,
                            ].join(',\n');
                            fieldsToAdd.push(['ModelFieldDefinition.hasOne(', visitor_plugin_common_1.indentMultiline(fieldParam), ')'].join('\n'));
                            break;
                        case process_connections_1.CodeGenConnectionType.HAS_MANY:
                            fieldParam = [
                                `key: ${modelName}.${queryFieldName}`,
                                `isRequired: ${!field.isNullable}`,
                                `ofModelName: (${connectedModelName}).toString()`,
                                `associatedKey: ${connectedModelName}.${this.getQueryFieldName(field.connectionInfo.associatedWith)}`,
                            ].join(',\n');
                            fieldsToAdd.push(['ModelFieldDefinition.hasMany(', visitor_plugin_common_1.indentMultiline(fieldParam), ')'].join('\n'));
                            break;
                        case process_connections_1.CodeGenConnectionType.BELONGS_TO:
                            fieldParam = [
                                `key: ${modelName}.${queryFieldName}`,
                                `isRequired: ${!field.isNullable}`,
                                `targetName: "${field.connectionInfo.targetName}"`,
                                `ofModelName: (${connectedModelName}).toString()`,
                            ].join(',\n');
                            fieldsToAdd.push(['ModelFieldDefinition.belongsTo(', visitor_plugin_common_1.indentMultiline(fieldParam), ')'].join('\n'));
                            break;
                    }
                }
                else {
                    const ofType = this.isEnumType(field) ? '.enumeration' : field.type in dart_config_1.typeToEnumMap ? dart_config_1.typeToEnumMap[field.type] : '.string';
                    const ofTypeStr = field.isList
                        ? `ofType: ModelFieldType(ModelFieldTypeEnum.collection, ofModelName: describeEnum(ModelFieldTypeEnum${ofType}))`
                        : `ofType: ModelFieldType(ModelFieldTypeEnum${ofType})`;
                    fieldParam = [
                        `key: ${modelName}.${queryFieldName}`,
                        `isRequired: ${this.isFieldRequired(field)}`,
                        field.isList ? 'isArray: true' : '',
                        ofTypeStr,
                    ]
                        .filter(f => f)
                        .join(',\n');
                    fieldsToAdd.push(['ModelFieldDefinition.field(', visitor_plugin_common_1.indentMultiline(fieldParam), ')'].join('\n'));
                }
            });
            return fieldsToAdd.map(field => `modelSchemaDefinition.addField(${field});`).join('\n\n');
        }
        return '';
    }
    getNonConnectedField(model) {
        return model.fields.filter(f => {
            if (!f.connectionInfo) {
                return true;
            }
            if (f.connectionInfo.kind == process_connections_1.CodeGenConnectionType.BELONGS_TO) {
                return true;
            }
        });
    }
    formatDartCode(dartCode) {
        if (this.isNullSafety()) {
            return dartCode;
        }
        const result = dart_style_1.default.formatCode(dartCode);
        if (result.error) {
            throw new Error(result.error);
        }
        return result.code || '';
    }
    isFieldRequired(field) {
        return !((field.isNullable && !field.isList) || field.isListNullable);
    }
    isNullSafety() {
        return this._parsedConfig.enableDartNullSafety;
    }
    getNullSafetyTypeStr(type) {
        return this.isNullSafety() ? `${type}?` : type;
    }
}
exports.AppSyncModelDartVisitor = AppSyncModelDartVisitor;
//# sourceMappingURL=appsync-dart-visitor.js.map