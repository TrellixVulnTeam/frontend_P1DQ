"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.makeModelSortDirectionEnumObject = exports.makeEnumFilterInput = exports.makeSizeInputType = exports.makeSubscriptionField = exports.makeAttributeTypeEnum = exports.makeModelScalarFilterInputObject = exports.createEnumModelFilters = exports.generateModelScalarFilterInputName = exports.addModelConditionInputs = exports.makeConditionFilterInput = void 0;
const graphql_1 = require("graphql");
const graphql_transformer_common_1 = require("graphql-transformer-common");
const definitions_1 = require("../definitions");
const object_definition_wrapper_1 = require("../wrappers/object-definition-wrapper");
const makeConditionFilterInput = (ctx, name, object) => {
    const supportsConditions = true;
    const input = object_definition_wrapper_1.InputObjectDefinitionWrapper.create(name);
    const wrappedObject = new object_definition_wrapper_1.ObjectDefinitionWrapper(object);
    for (let field of wrappedObject.fields) {
        const fieldType = ctx.output.getType(field.getTypeName());
        const isEnumType = fieldType && fieldType.kind === graphql_1.Kind.ENUM_TYPE_DEFINITION;
        if (field.isScalar() || isEnumType) {
            const conditionTypeName = isEnumType && field.isList()
                ? graphql_transformer_common_1.ModelResourceIDs.ModelFilterListInputTypeName(field.getTypeName(), !supportsConditions)
                : graphql_transformer_common_1.ModelResourceIDs.ModelFilterScalarInputTypeName(field.getTypeName(), !supportsConditions);
            const inputField = object_definition_wrapper_1.InputFieldWrapper.create(field.name, conditionTypeName, true);
            input.addField(inputField);
        }
    }
    for (let additionalField of ['and', 'or']) {
        const inputField = object_definition_wrapper_1.InputFieldWrapper.create(additionalField, name, true, true);
        input.addField(inputField);
    }
    for (let additionalField of ['not']) {
        const inputField = object_definition_wrapper_1.InputFieldWrapper.create(additionalField, name, true, false);
        input.addField(inputField);
    }
    return input;
};
exports.makeConditionFilterInput = makeConditionFilterInput;
const addModelConditionInputs = (ctx) => {
    const conditionsInput = ['String', 'Int', 'Float', 'Boolean', 'ID'].map(scalarName => makeModelScalarFilterInputObject(scalarName, true));
    conditionsInput.push(makeAttributeTypeEnum());
    conditionsInput.push(makeSizeInputType());
    conditionsInput.forEach(input => {
        const inputName = input.name.value;
        if (!ctx.output.getType(inputName)) {
            ctx.output.addType(input);
        }
    });
};
exports.addModelConditionInputs = addModelConditionInputs;
function generateModelScalarFilterInputName(typeName, includeFilter) {
    const nameOverride = graphql_transformer_common_1.DEFAULT_SCALARS[typeName];
    if (nameOverride) {
        return `Model${nameOverride}${includeFilter ? 'Filter' : ''}Input`;
    }
    return `Model${typeName}${includeFilter ? 'Filter' : ''}Input`;
}
exports.generateModelScalarFilterInputName = generateModelScalarFilterInputName;
const createEnumModelFilters = (ctx, type) => {
    const typeWrapper = new object_definition_wrapper_1.ObjectDefinitionWrapper(type);
    const enumFields = typeWrapper.fields.filter(field => {
        const typeName = field.getTypeName();
        const typeObj = ctx.output.getType(typeName);
        return typeObj && typeObj.kind === 'EnumTypeDefinition';
    });
    return enumFields.map(field => makeEnumFilterInput(field));
};
exports.createEnumModelFilters = createEnumModelFilters;
function makeModelScalarFilterInputObject(type, supportsConditions) {
    const name = generateModelScalarFilterInputName(type, !supportsConditions);
    const conditions = getScalarConditions(type);
    const scalarConditionInput = object_definition_wrapper_1.InputObjectDefinitionWrapper.create(name);
    for (let condition of conditions) {
        let typeName;
        switch (condition) {
            case 'and':
            case 'or':
                typeName = name;
                break;
            default:
                typeName = type;
        }
        const field = object_definition_wrapper_1.InputFieldWrapper.create(condition, typeName, true);
        if (condition === 'between') {
            field.wrapListType();
        }
        scalarConditionInput.addField(field);
    }
    makeFunctionInputFields(type).map(f => scalarConditionInput.addField(f));
    return scalarConditionInput.serialize();
}
exports.makeModelScalarFilterInputObject = makeModelScalarFilterInputObject;
function getScalarConditions(type) {
    switch (type) {
        case 'String':
            return definitions_1.STRING_CONDITIONS;
        case 'ID':
            return definitions_1.ID_CONDITIONS;
        case 'Int':
            return definitions_1.INT_CONDITIONS;
        case 'Float':
            return definitions_1.FLOAT_CONDITIONS;
        case 'Boolean':
            return definitions_1.BOOLEAN_CONDITIONS;
        default:
            throw new Error('Valid types are String, ID, Int, Float, Boolean');
    }
}
function getFunctionListForType(typeName) {
    switch (typeName) {
        case 'String':
            return definitions_1.STRING_FUNCTIONS;
        case 'ID':
            return definitions_1.ID_FUNCTIONS;
        case 'Int':
            return definitions_1.INT_FUNCTIONS;
        case 'Float':
            return definitions_1.FLOAT_FUNCTIONS;
        case 'Boolean':
            return definitions_1.BOOLEAN_FUNCTIONS;
        default:
            throw new Error('Valid types are String, ID, Int, Float, Boolean');
    }
}
function makeFunctionInputFields(typeName) {
    const functions = getFunctionListForType(typeName);
    const fields = new Array();
    if (functions.has('attributeExists')) {
        fields.push(object_definition_wrapper_1.InputFieldWrapper.create('attributeExists', 'Boolean', true));
    }
    if (functions.has('attributeType')) {
        fields.push(object_definition_wrapper_1.InputFieldWrapper.create('attributeType', 'ModelAttributeTypes', true));
    }
    if (functions.has('size')) {
        fields.push(object_definition_wrapper_1.InputFieldWrapper.create('size', 'ModelSizeInput', true));
    }
    return fields;
}
function makeAttributeTypeEnum() {
    return object_definition_wrapper_1.EnumWrapper.create('ModelAttributeTypes', definitions_1.ATTRIBUTE_TYPES).serialize();
}
exports.makeAttributeTypeEnum = makeAttributeTypeEnum;
function makeSubscriptionField(fieldName, returnTypeName, mutations) {
    return graphql_transformer_common_1.makeField(fieldName, [], graphql_transformer_common_1.makeNamedType(returnTypeName), [
        graphql_transformer_common_1.makeDirective('aws_subscribe', [graphql_transformer_common_1.makeArgument('mutations', graphql_transformer_common_1.makeValueNode(mutations))]),
    ]);
}
exports.makeSubscriptionField = makeSubscriptionField;
function makeSizeInputType() {
    const name = 'ModelSizeInput';
    const input = object_definition_wrapper_1.InputObjectDefinitionWrapper.create(name);
    for (let condition of definitions_1.SIZE_CONDITIONS) {
        const field = object_definition_wrapper_1.InputFieldWrapper.create(condition, 'Int', true);
        if (condition === 'between')
            field.wrapListType();
        input.addField(field);
    }
    return input.serialize();
}
exports.makeSizeInputType = makeSizeInputType;
function makeEnumFilterInput(fieldWrapper) {
    const supportsConditions = true;
    const conditionTypeName = fieldWrapper.isList()
        ? graphql_transformer_common_1.ModelResourceIDs.ModelFilterListInputTypeName(fieldWrapper.getTypeName(), !supportsConditions)
        : graphql_transformer_common_1.ModelResourceIDs.ModelFilterScalarInputTypeName(fieldWrapper.getTypeName(), !supportsConditions);
    const input = object_definition_wrapper_1.InputObjectDefinitionWrapper.create(conditionTypeName);
    ['eq', 'ne'].forEach(fieldName => {
        const field = object_definition_wrapper_1.InputFieldWrapper.create(fieldName, fieldWrapper.getTypeName(), true, fieldWrapper.isList());
        input.addField(field);
    });
    if (fieldWrapper.isList()) {
        ['contains', 'notContains'].forEach(fieldName => {
            const field = object_definition_wrapper_1.InputFieldWrapper.create(fieldName, fieldWrapper.getTypeName(), true);
            input.addField(field);
        });
    }
    return input.serialize();
}
exports.makeEnumFilterInput = makeEnumFilterInput;
function makeModelSortDirectionEnumObject() {
    const name = 'ModelSortDirection';
    return object_definition_wrapper_1.EnumWrapper.create(name, ['ASC', 'DESC']).serialize();
}
exports.makeModelSortDirectionEnumObject = makeModelSortDirectionEnumObject;
//# sourceMappingURL=common.js.map