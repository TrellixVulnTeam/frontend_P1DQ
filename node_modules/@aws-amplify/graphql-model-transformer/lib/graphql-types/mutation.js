"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.makeMutationConditionInput = exports.makeCreateInputField = exports.makeDeleteInputField = exports.makeUpdateInputField = void 0;
const graphql_transformer_common_1 = require("graphql-transformer-common");
const object_definition_wrapper_1 = require("../wrappers/object-definition-wrapper");
const common_1 = require("./common");
const makeUpdateInputField = (obj, modelDirectiveConfig, knownModelTypes, document, isSyncEnabled) => {
    var _a;
    const objectWrapped = new object_definition_wrapper_1.ObjectDefinitionWrapper(obj);
    const typeName = objectWrapped.name;
    const name = graphql_transformer_common_1.toPascalCase([`Update`, typeName, 'Input']);
    const hasIdField = objectWrapped.hasField('id');
    const fieldsToRemove = objectWrapped
        .fields.filter(field => {
        if (knownModelTypes.has(field.getTypeName())) {
            return true;
        }
        return false;
    })
        .map(field => {
        return field.name;
    });
    const objectTypeDefinition = {
        ...obj,
        fields: (_a = obj.fields) === null || _a === void 0 ? void 0 : _a.filter(f => !fieldsToRemove.includes(f.name.value)),
    };
    const input = object_definition_wrapper_1.InputObjectDefinitionWrapper.fromObject(name, objectTypeDefinition, document);
    input.fields.forEach(f => f.makeNullable());
    if (!hasIdField) {
        input.addField(object_definition_wrapper_1.InputFieldWrapper.create('id', 'ID', false));
    }
    else {
        const idField = input.fields.find(f => f.name === 'id');
        if (idField) {
            idField.makeNonNullable();
        }
    }
    for (let timeStampFieldName of Object.values((modelDirectiveConfig === null || modelDirectiveConfig === void 0 ? void 0 : modelDirectiveConfig.timestamps) || {})) {
        if (input.hasField(timeStampFieldName)) {
            const timestampField = input.getField(timeStampFieldName);
            if (['String', 'AWSDateTime'].includes(timestampField.getTypeName())) {
                timestampField.makeNullable();
            }
        }
    }
    if (isSyncEnabled) {
        input.addField(object_definition_wrapper_1.InputFieldWrapper.create('_version', 'Int', true));
    }
    return input.serialize();
};
exports.makeUpdateInputField = makeUpdateInputField;
const makeDeleteInputField = (type, isSyncEnabled) => {
    const name = graphql_transformer_common_1.toPascalCase(['Delete', type.name.value, 'input']);
    const inputField = object_definition_wrapper_1.InputObjectDefinitionWrapper.create(name);
    const idField = object_definition_wrapper_1.InputFieldWrapper.create('id', 'ID', false, false);
    inputField.addField(idField);
    if (isSyncEnabled) {
        inputField.addField(object_definition_wrapper_1.InputFieldWrapper.create('_version', 'Int', true));
    }
    return inputField.serialize();
};
exports.makeDeleteInputField = makeDeleteInputField;
const makeCreateInputField = (obj, modelDirectiveConfig, knownModelTypes, document, isSyncEnabled) => {
    var _a;
    const objectWrapped = new object_definition_wrapper_1.ObjectDefinitionWrapper(obj);
    const typeName = objectWrapped.name;
    const name = graphql_transformer_common_1.ModelResourceIDs.ModelCreateInputObjectName(typeName);
    const hasIdField = objectWrapped.hasField('id');
    const fieldsToRemove = objectWrapped
        .fields.filter(field => {
        if (knownModelTypes.has(field.getTypeName())) {
            return true;
        }
        return false;
    })
        .map(field => {
        return field.name;
    });
    const objectTypeDefinition = {
        ...obj,
        fields: (_a = obj.fields) === null || _a === void 0 ? void 0 : _a.filter(f => !fieldsToRemove.includes(f.name.value)),
    };
    const input = object_definition_wrapper_1.InputObjectDefinitionWrapper.fromObject(name, objectTypeDefinition, document);
    if (!hasIdField) {
        input.addField(object_definition_wrapper_1.InputFieldWrapper.create('id', 'ID'));
    }
    else {
        const idField = input.fields.find(f => f.name === 'id');
        if (idField) {
            idField.makeNullable();
        }
    }
    for (let timeStampFieldName of Object.values((modelDirectiveConfig === null || modelDirectiveConfig === void 0 ? void 0 : modelDirectiveConfig.timestamps) || {})) {
        if (input.hasField(timeStampFieldName)) {
            const timestampField = input.getField(timeStampFieldName);
            if (['String', 'AWSDateTime'].includes(timestampField.getTypeName())) {
                timestampField.makeNullable();
            }
        }
    }
    if (isSyncEnabled) {
        input.addField(object_definition_wrapper_1.InputFieldWrapper.create('_version', 'Int', true));
    }
    return input.serialize();
};
exports.makeCreateInputField = makeCreateInputField;
const makeMutationConditionInput = (ctx, name, object) => {
    const input = common_1.makeConditionFilterInput(ctx, name, object);
    const idField = input.fields.find(f => f.name === 'id' && f.getTypeName() === 'ModelIDInput');
    if (idField) {
        input.removeField(idField);
    }
    return input.serialize();
};
exports.makeMutationConditionInput = makeMutationConditionInput;
//# sourceMappingURL=mutation.js.map