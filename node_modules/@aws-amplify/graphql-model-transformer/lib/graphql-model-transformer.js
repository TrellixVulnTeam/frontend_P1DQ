"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ModelTransformer = exports.directiveDefinition = exports.SubscriptionLevel = void 0;
const graphql_transformer_core_1 = require("@aws-amplify/graphql-transformer-core");
const graphql_transformer_interfaces_1 = require("@aws-amplify/graphql-transformer-interfaces");
const aws_dynamodb_1 = require("@aws-cdk/aws-dynamodb");
const iam = __importStar(require("@aws-cdk/aws-iam"));
const cdk = __importStar(require("@aws-cdk/core"));
const graphql_transformer_common_1 = require("graphql-transformer-common");
const graphql_types_1 = require("./graphql-types");
const resolvers_1 = require("./resolvers");
const query_1 = require("./resolvers/query");
const object_definition_wrapper_1 = require("./wrappers/object-definition-wrapper");
const md5_1 = __importDefault(require("md5"));
var SubscriptionLevel;
(function (SubscriptionLevel) {
    SubscriptionLevel["off"] = "off";
    SubscriptionLevel["public"] = "public";
    SubscriptionLevel["on"] = "on";
})(SubscriptionLevel = exports.SubscriptionLevel || (exports.SubscriptionLevel = {}));
exports.directiveDefinition = `
  directive @model(
    queries: ModelQueryMap
    mutations: ModelMutationMap
    subscriptions: ModelSubscriptionMap
    timestamps: TimestampConfiguration
  ) on OBJECT
  input ModelMutationMap {
    create: String
    update: String
    delete: String
  }
  input ModelQueryMap {
    get: String
    list: String
  }
  input ModelSubscriptionMap {
    onCreate: [String]
    onUpdate: [String]
    onDelete: [String]
    level: ModelSubscriptionLevel
  }
  enum ModelSubscriptionLevel {
    off
    public
    on
  }
  input TimestampConfiguration {
    createdAt: String
    updatedAt: String
  }
`;
class ModelTransformer extends graphql_transformer_core_1.TransformerModelBase {
    constructor(options = {}) {
        super('amplify-model-transformer', exports.directiveDefinition);
        this.datasourceMap = {};
        this.ddbTableMap = {};
        this.resolverMap = {};
        this.typesWithModelDirective = new Set();
        this.modelDirectiveConfig = new Map();
        this.object = (definition, directive, ctx) => {
            const isTypeNameReserved = definition.name.value === ctx.output.getQueryTypeName() ||
                definition.name.value === ctx.output.getMutationTypeName() ||
                definition.name.value === ctx.output.getSubscriptionTypeName();
            if (isTypeNameReserved) {
                throw new graphql_transformer_core_1.InvalidDirectiveError(`'${definition.name.value}' is a reserved type name and currently in use within the default schema element.`);
            }
            const typeName = definition.name.value;
            if (ctx.isProjectUsingDataStore()) {
                graphql_transformer_core_1.SyncUtils.validateResolverConfigForType(ctx, typeName);
            }
            const directiveWrapped = new object_definition_wrapper_1.DirectiveWrapper(directive);
            const options = directiveWrapped.getArguments({
                queries: {
                    get: graphql_transformer_common_1.toCamelCase(['get', typeName]),
                    list: graphql_transformer_common_1.toCamelCase(['list', graphql_transformer_common_1.plurality(typeName, true)]),
                    ...(ctx.isProjectUsingDataStore() ? { sync: graphql_transformer_common_1.toCamelCase(['sync', graphql_transformer_common_1.plurality(typeName, true)]) } : undefined),
                },
                mutations: {
                    create: graphql_transformer_common_1.toCamelCase(['create', typeName]),
                    update: graphql_transformer_common_1.toCamelCase(['update', typeName]),
                    delete: graphql_transformer_common_1.toCamelCase(['delete', typeName]),
                },
                subscriptions: {
                    level: SubscriptionLevel.public,
                    onCreate: [this.ensureValidSubscriptionName(graphql_transformer_common_1.toCamelCase(['onCreate', typeName]))],
                    onDelete: [this.ensureValidSubscriptionName(graphql_transformer_common_1.toCamelCase(['onDelete', typeName]))],
                    onUpdate: [this.ensureValidSubscriptionName(graphql_transformer_common_1.toCamelCase(['onUpdate', typeName]))],
                },
                timestamps: {
                    createdAt: 'createdAt',
                    updatedAt: 'updatedAt',
                },
            });
            this.modelDirectiveConfig.set(typeName, options);
            this.typesWithModelDirective.add(typeName);
        };
        this.validate = () => { };
        this.prepare = (context) => {
            for (const modelTypeName of this.typesWithModelDirective) {
                const type = context.output.getObject(modelTypeName);
                context.providerRegistry.registerDataSourceProvider(type, this);
            }
        };
        this.transformSchema = (ctx) => {
            graphql_types_1.addModelConditionInputs(ctx);
            this.ensureModelSortDirectionEnum(ctx);
            for (const type of this.typesWithModelDirective) {
                const def = ctx.output.getObject(type);
                this.createNonModelInputs(ctx, def);
                const queryFields = this.createQueryFields(ctx, def);
                ctx.output.addQueryFields(queryFields);
                const mutationFields = this.createMutationFields(ctx, def);
                ctx.output.addMutationFields(mutationFields);
                const subscriptionsFields = this.createSubscriptionFields(ctx, def);
                ctx.output.addSubscriptionFields(subscriptionsFields);
                this.addAutoGeneratableFields(ctx, type);
                if (ctx.isProjectUsingDataStore()) {
                    this.addModelSyncFields(ctx, type);
                }
            }
        };
        this.generateResolvers = (context) => {
            for (let type of this.typesWithModelDirective) {
                const def = context.output.getObject(type);
                const tableLogicalName = `${def.name.value}Table`;
                const stack = context.stackManager.getStackFor(tableLogicalName, def.name.value);
                this.createModelTable(stack, def, context);
                const queryFields = this.getQueryFieldNames(context, def);
                for (let query of queryFields.values()) {
                    let resolver;
                    switch (query.type) {
                        case graphql_transformer_interfaces_1.QueryFieldType.GET:
                            resolver = this.generateGetResolver(context, def, query.typeName, query.fieldName);
                            break;
                        case graphql_transformer_interfaces_1.QueryFieldType.LIST:
                            resolver = this.generateListResolver(context, def, query.typeName, query.fieldName);
                            break;
                        case graphql_transformer_interfaces_1.QueryFieldType.SYNC:
                            resolver = this.generateSyncResolver(context, def, query.typeName, query.fieldName);
                            break;
                        default:
                            throw new Error('Unknown query field type');
                    }
                    resolver.mapToStack(stack);
                    context.resolvers.addResolver(query.typeName, query.fieldName, resolver);
                }
                const mutationFields = this.getMutationFieldNames(context, def);
                for (let mutation of mutationFields.values()) {
                    let resolver;
                    switch (mutation.type) {
                        case graphql_transformer_interfaces_1.MutationFieldType.CREATE:
                            resolver = this.generateCreateResolver(context, def, mutation.typeName, mutation.fieldName);
                            break;
                        case graphql_transformer_interfaces_1.MutationFieldType.DELETE:
                            resolver = this.generateDeleteResolver(context, def, mutation.typeName, mutation.fieldName);
                            break;
                        case graphql_transformer_interfaces_1.MutationFieldType.UPDATE:
                            resolver = this.generateUpdateResolver(context, def, mutation.typeName, mutation.fieldName);
                            break;
                        default:
                            throw new Error('Unknown query field type');
                    }
                    resolver.mapToStack(stack);
                    context.resolvers.addResolver(mutation.typeName, mutation.fieldName, resolver);
                }
            }
        };
        this.generateGetResolver = (ctx, type, typeName, fieldName) => {
            const isSyncEnabled = ctx.isProjectUsingDataStore();
            const dataSource = this.datasourceMap[type.name.value];
            const resolverKey = `Get${resolvers_1.generateResolverKey(typeName, fieldName)}`;
            if (!this.resolverMap[resolverKey]) {
                this.resolverMap[resolverKey] = ctx.resolvers.generateQueryResolver(typeName, fieldName, dataSource, graphql_transformer_core_1.MappingTemplate.s3MappingTemplateFromString(query_1.generateGetRequestTemplate(), `${typeName}.${fieldName}.req.vtl`), graphql_transformer_core_1.MappingTemplate.s3MappingTemplateFromString(resolvers_1.generateDefaultResponseMappingTemplate(isSyncEnabled), `${typeName}.${fieldName}.res.vtl`));
            }
            return this.resolverMap[resolverKey];
        };
        this.generateListResolver = (ctx, type, typeName, fieldName) => {
            const isSyncEnabled = ctx.isProjectUsingDataStore();
            const dataSource = this.datasourceMap[type.name.value];
            const resolverKey = `List${resolvers_1.generateResolverKey(typeName, fieldName)}`;
            if (!this.resolverMap[resolverKey]) {
                this.resolverMap[resolverKey] = ctx.resolvers.generateQueryResolver(typeName, fieldName, dataSource, graphql_transformer_core_1.MappingTemplate.s3MappingTemplateFromString(query_1.generateListRequestTemplate(), `${typeName}.${fieldName}.req.vtl`), graphql_transformer_core_1.MappingTemplate.s3MappingTemplateFromString(resolvers_1.generateDefaultResponseMappingTemplate(isSyncEnabled), `${typeName}.${fieldName}.res.vtl`));
            }
            return this.resolverMap[resolverKey];
        };
        this.generateUpdateResolver = (ctx, type, typeName, fieldName) => {
            const isSyncEnabled = ctx.isProjectUsingDataStore();
            const dataSource = this.datasourceMap[type.name.value];
            const resolverKey = `Update${resolvers_1.generateResolverKey(typeName, fieldName)}`;
            if (!this.resolverMap[resolverKey]) {
                const resolver = ctx.resolvers.generateMutationResolver(typeName, fieldName, dataSource, graphql_transformer_core_1.MappingTemplate.s3MappingTemplateFromString(resolvers_1.generateUpdateRequestTemplate(typeName, isSyncEnabled), `${typeName}.${fieldName}.req.vtl`), graphql_transformer_core_1.MappingTemplate.s3MappingTemplateFromString(resolvers_1.generateDefaultResponseMappingTemplate(isSyncEnabled), `${typeName}.${fieldName}.res.vtl`));
                resolver.addToSlot('init', graphql_transformer_core_1.MappingTemplate.s3MappingTemplateFromString(resolvers_1.generateUpdateInitSlotTemplate(type.name.value, this.modelDirectiveConfig.get(type.name.value)), `${typeName}.${fieldName}.{slotName}.{slotIndex}.req.vtl`));
                this.resolverMap[resolverKey] = resolver;
            }
            return this.resolverMap[resolverKey];
        };
        this.generateDeleteResolver = (ctx, type, typeName, fieldName) => {
            const isSyncEnabled = ctx.isProjectUsingDataStore();
            const dataSource = this.datasourceMap[type.name.value];
            const resolverKey = `delete${resolvers_1.generateResolverKey(typeName, fieldName)}`;
            if (!this.resolverMap[resolverKey]) {
                this.resolverMap[resolverKey] = ctx.resolvers.generateMutationResolver(typeName, fieldName, dataSource, graphql_transformer_core_1.MappingTemplate.s3MappingTemplateFromString(resolvers_1.generateDeleteRequestTemplate(isSyncEnabled), `${typeName}.${fieldName}.req.vtl`), graphql_transformer_core_1.MappingTemplate.s3MappingTemplateFromString(resolvers_1.generateDefaultResponseMappingTemplate(isSyncEnabled), `${typeName}.${fieldName}.res.vtl`));
            }
            return this.resolverMap[resolverKey];
        };
        this.generateOnCreateResolver = (ctx, type, typeName, fieldName) => {
            const resolverKey = `OnCreate${resolvers_1.generateResolverKey(typeName, fieldName)}`;
            if (!this.resolverMap[resolverKey]) {
                this.resolverMap[resolverKey] = ctx.resolvers.generateSubscriptionResolver(typeName, fieldName, graphql_transformer_core_1.MappingTemplate.s3MappingTemplateFromString(resolvers_1.generateSubscriptionRequestTemplate(), `${typeName}.${fieldName}.req.vtl`), graphql_transformer_core_1.MappingTemplate.s3MappingTemplateFromString(resolvers_1.generateSubscriptionResponseTemplate(), `${typeName}.${fieldName}.res.vtl`));
            }
            return this.resolverMap[resolverKey];
        };
        this.generateOnUpdateResolver = (ctx, type, typeName, fieldName) => {
            const resolverKey = `OnUpdate${resolvers_1.generateResolverKey(typeName, fieldName)}`;
            if (!this.resolverMap[resolverKey]) {
                this.resolverMap[resolverKey] = ctx.resolvers.generateSubscriptionResolver(typeName, fieldName, graphql_transformer_core_1.MappingTemplate.s3MappingTemplateFromString(resolvers_1.generateSubscriptionRequestTemplate(), `${typeName}.${fieldName}.req.vtl`), graphql_transformer_core_1.MappingTemplate.s3MappingTemplateFromString(resolvers_1.generateSubscriptionResponseTemplate(), `${typeName}.${fieldName}.res.vtl`));
            }
            return this.resolverMap[resolverKey];
        };
        this.generateOnDeleteResolver = (ctx, type, typeName, fieldName) => {
            const resolverKey = `OnDelete${resolvers_1.generateResolverKey(typeName, fieldName)}`;
            if (!this.resolverMap[resolverKey]) {
                this.resolverMap[resolverKey] = ctx.resolvers.generateSubscriptionResolver(typeName, fieldName, graphql_transformer_core_1.MappingTemplate.s3MappingTemplateFromString(resolvers_1.generateSubscriptionRequestTemplate(), `${typeName}.${fieldName}.req.vtl`), graphql_transformer_core_1.MappingTemplate.s3MappingTemplateFromString(resolvers_1.generateSubscriptionResponseTemplate(), `${typeName}.${fieldName}.res.vtl`));
            }
            return this.resolverMap[resolverKey];
        };
        this.generateSyncResolver = (ctx, type, typeName, fieldName) => {
            const isSyncEnabled = ctx.isProjectUsingDataStore();
            const dataSource = this.datasourceMap[type.name.value];
            const resolverKey = `Sync${resolvers_1.generateResolverKey(typeName, fieldName)}`;
            if (!this.resolverMap[resolverKey]) {
                this.resolverMap[resolverKey] = ctx.resolvers.generateQueryResolver(typeName, fieldName, dataSource, graphql_transformer_core_1.MappingTemplate.s3MappingTemplateFromString(query_1.generateSyncRequestTemplate(), `${typeName}.${fieldName}.req.vtl`), graphql_transformer_core_1.MappingTemplate.s3MappingTemplateFromString(resolvers_1.generateDefaultResponseMappingTemplate(isSyncEnabled), `${typeName}.${fieldName}.res.vtl`));
            }
            return this.resolverMap[resolverKey];
        };
        this.getQueryFieldNames = (ctx, type) => {
            var _a, _b, _c;
            const typeName = type.name.value;
            const fields = new Set();
            const modelDirectiveConfig = this.modelDirectiveConfig.get(type.name.value);
            if ((_a = modelDirectiveConfig === null || modelDirectiveConfig === void 0 ? void 0 : modelDirectiveConfig.queries) === null || _a === void 0 ? void 0 : _a.get) {
                fields.add({
                    typeName: 'Query',
                    fieldName: modelDirectiveConfig.queries.get || graphql_transformer_common_1.toCamelCase(['get', typeName]),
                    type: graphql_transformer_interfaces_1.QueryFieldType.GET,
                });
            }
            if ((_b = modelDirectiveConfig === null || modelDirectiveConfig === void 0 ? void 0 : modelDirectiveConfig.queries) === null || _b === void 0 ? void 0 : _b.list) {
                fields.add({
                    typeName: 'Query',
                    fieldName: modelDirectiveConfig.queries.list || graphql_transformer_common_1.toCamelCase(['list', typeName]),
                    type: graphql_transformer_interfaces_1.QueryFieldType.LIST,
                });
            }
            if ((_c = modelDirectiveConfig === null || modelDirectiveConfig === void 0 ? void 0 : modelDirectiveConfig.queries) === null || _c === void 0 ? void 0 : _c.sync) {
                fields.add({
                    typeName: 'Query',
                    fieldName: modelDirectiveConfig.queries.sync || graphql_transformer_common_1.toCamelCase(['sync', typeName]),
                    type: graphql_transformer_interfaces_1.QueryFieldType.SYNC,
                });
            }
            return fields;
        };
        this.getMutationFieldNames = (ctx, type) => {
            const typeName = type.name.value;
            const modelDirectiveConfig = this.modelDirectiveConfig.get(typeName);
            const getMutationType = (type) => {
                switch (type) {
                    case 'create':
                        return graphql_transformer_interfaces_1.MutationFieldType.CREATE;
                    case 'update':
                        return graphql_transformer_interfaces_1.MutationFieldType.UPDATE;
                    case 'delete':
                        return graphql_transformer_interfaces_1.MutationFieldType.DELETE;
                    default:
                        throw new Error('Unknown mutation type');
                }
            };
            const fieldNames = new Set();
            for (let [mutationType, mutationName] of Object.entries((modelDirectiveConfig === null || modelDirectiveConfig === void 0 ? void 0 : modelDirectiveConfig.mutations) || {})) {
                if (mutationName) {
                    fieldNames.add({
                        typeName: 'Mutation',
                        fieldName: mutationName,
                        type: getMutationType(mutationType),
                    });
                }
            }
            return fieldNames;
        };
        this.getMutationName = (subscriptionType, mutationMap) => {
            const mutationToSubscriptionTypeMap = {
                [graphql_transformer_interfaces_1.SubscriptionFieldType.ON_CREATE]: graphql_transformer_interfaces_1.MutationFieldType.CREATE,
                [graphql_transformer_interfaces_1.SubscriptionFieldType.ON_UPDATE]: graphql_transformer_interfaces_1.MutationFieldType.UPDATE,
                [graphql_transformer_interfaces_1.SubscriptionFieldType.ON_DELETE]: graphql_transformer_interfaces_1.MutationFieldType.DELETE,
            };
            const mutation = Array.from(mutationMap).find(m => m.type == mutationToSubscriptionTypeMap[subscriptionType]);
            if (mutation) {
                return mutation.fieldName;
            }
            throw new Error('Unknown Subscription type');
        };
        this.createQueryFields = (ctx, def) => {
            const queryFields = [];
            const queryFieldNames = this.getQueryFieldNames(ctx, def);
            for (const queryField of queryFieldNames.values()) {
                const outputType = this.getOutputType(ctx, def, queryField);
                const args = this.getInputs(ctx, def, {
                    fieldName: queryField.fieldName,
                    typeName: queryField.typeName,
                    type: queryField.type,
                });
                queryFields.push(graphql_transformer_common_1.makeField(queryField.fieldName, args, graphql_transformer_common_1.makeNamedType(outputType.name.value)));
            }
            return queryFields;
        };
        this.createMutationFields = (ctx, def) => {
            const mutationFields = [];
            const mutationFieldNames = this.getMutationFieldNames(ctx, def);
            for (const mutationField of mutationFieldNames) {
                const args = this.getInputs(ctx, def, {
                    fieldName: mutationField.fieldName,
                    typeName: mutationField.typeName,
                    type: mutationField.type,
                });
                mutationFields.push(graphql_transformer_common_1.makeField(mutationField.fieldName, args, graphql_transformer_common_1.makeNamedType(def.name.value)));
            }
            return mutationFields;
        };
        this.createSubscriptionFields = (ctx, def) => {
            const subscriptionToMutationsMap = this.getSubscriptionToMutationsReverseMap(ctx, def);
            const mutationFields = this.getMutationFieldNames(ctx, def);
            const subscriptionFields = [];
            for (const subscriptionFieldName of Object.keys(subscriptionToMutationsMap)) {
                const maps = subscriptionToMutationsMap[subscriptionFieldName];
                const args = [];
                maps.map(it => args.concat(this.getInputs(ctx, def, {
                    fieldName: it.fieldName,
                    typeName: it.typeName,
                    type: it.type,
                })));
                const mutationNames = maps.map(it => this.getMutationName(it.type, mutationFields));
                const directive = graphql_transformer_common_1.makeDirective('aws_subscribe', [graphql_transformer_common_1.makeArgument('mutations', graphql_transformer_common_1.makeValueNode(mutationNames))]);
                const field = graphql_transformer_common_1.makeField(subscriptionFieldName, args, graphql_transformer_common_1.makeNamedType(def.name.value), [directive]);
                subscriptionFields.push(field);
            }
            return subscriptionFields;
        };
        this.getSubscriptionFieldNames = (ctx, type) => {
            var _a, _b, _c, _d, _e, _f, _g;
            const fields = new Set();
            const modelDirectiveConfig = this.modelDirectiveConfig.get(type.name.value);
            if (((_a = modelDirectiveConfig === null || modelDirectiveConfig === void 0 ? void 0 : modelDirectiveConfig.subscriptions) === null || _a === void 0 ? void 0 : _a.level) !== SubscriptionLevel.off) {
                if (((_b = modelDirectiveConfig === null || modelDirectiveConfig === void 0 ? void 0 : modelDirectiveConfig.subscriptions) === null || _b === void 0 ? void 0 : _b.onCreate) && ((_c = modelDirectiveConfig.mutations) === null || _c === void 0 ? void 0 : _c.create)) {
                    for (const fieldName of modelDirectiveConfig.subscriptions.onCreate) {
                        fields.add({
                            typeName: 'Subscription',
                            fieldName: fieldName,
                            type: graphql_transformer_interfaces_1.SubscriptionFieldType.ON_CREATE,
                        });
                    }
                }
                if (((_d = modelDirectiveConfig === null || modelDirectiveConfig === void 0 ? void 0 : modelDirectiveConfig.subscriptions) === null || _d === void 0 ? void 0 : _d.onUpdate) && ((_e = modelDirectiveConfig.mutations) === null || _e === void 0 ? void 0 : _e.update)) {
                    for (const fieldName of modelDirectiveConfig.subscriptions.onUpdate) {
                        fields.add({
                            typeName: 'Subscription',
                            fieldName: fieldName,
                            type: graphql_transformer_interfaces_1.SubscriptionFieldType.ON_UPDATE,
                        });
                    }
                }
                if (((_f = modelDirectiveConfig === null || modelDirectiveConfig === void 0 ? void 0 : modelDirectiveConfig.subscriptions) === null || _f === void 0 ? void 0 : _f.onDelete) && ((_g = modelDirectiveConfig.mutations) === null || _g === void 0 ? void 0 : _g.delete)) {
                    for (const fieldName of modelDirectiveConfig.subscriptions.onDelete) {
                        fields.add({
                            typeName: 'Subscription',
                            fieldName: fieldName,
                            type: graphql_transformer_interfaces_1.SubscriptionFieldType.ON_DELETE,
                        });
                    }
                }
            }
            return fields;
        };
        this.getDataSourceResource = (ctx, type) => {
            return this.ddbTableMap[type.name.value];
        };
        this.getDataSourceType = () => {
            return graphql_transformer_interfaces_1.AppSyncDataSourceType.AMAZON_DYNAMODB;
        };
        this.generateCreateResolver = (ctx, type, typeName, fieldName) => {
            const isSyncEnabled = ctx.isProjectUsingDataStore();
            const dataSource = this.datasourceMap[type.name.value];
            const resolverKey = `Create${resolvers_1.generateResolverKey(typeName, fieldName)}`;
            if (!this.resolverMap[resolverKey]) {
                const resolver = ctx.resolvers.generateMutationResolver(typeName, fieldName, dataSource, graphql_transformer_core_1.MappingTemplate.s3MappingTemplateFromString(resolvers_1.generateCreateRequestTemplate(type.name.value), `${typeName}.${fieldName}.req.vtl`), graphql_transformer_core_1.MappingTemplate.s3MappingTemplateFromString(resolvers_1.generateDefaultResponseMappingTemplate(isSyncEnabled), `${typeName}.${fieldName}.res.vtl`));
                this.resolverMap[resolverKey] = resolver;
                resolver.addToSlot('init', graphql_transformer_core_1.MappingTemplate.s3MappingTemplateFromString(resolvers_1.generateCreateInitSlotTemplate(type.name.value, this.modelDirectiveConfig.get(type.name.value)), `${typeName}.${fieldName}.{slotName}.{slotIndex}.req.vtl`));
            }
            return this.resolverMap[resolverKey];
        };
        this.getInputs = (ctx, type, operation) => {
            const isSyncEnabled = ctx.isProjectUsingDataStore();
            const knownModels = this.typesWithModelDirective;
            let conditionInput;
            if ([graphql_transformer_interfaces_1.MutationFieldType.CREATE, graphql_transformer_interfaces_1.MutationFieldType.DELETE, graphql_transformer_interfaces_1.MutationFieldType.UPDATE].includes(operation.type)) {
                const conditionTypeName = graphql_transformer_common_1.toPascalCase(['Model', type.name.value, 'ConditionInput']);
                const filterInputs = graphql_types_1.createEnumModelFilters(ctx, type);
                conditionInput = graphql_types_1.makeMutationConditionInput(ctx, conditionTypeName, type);
                filterInputs.push(conditionInput);
                for (let input of filterInputs) {
                    const conditionInputName = input.name.value;
                    if (!ctx.output.getType(conditionInputName)) {
                        ctx.output.addInput(input);
                    }
                }
            }
            switch (operation.type) {
                case graphql_transformer_interfaces_1.QueryFieldType.GET:
                    return [graphql_transformer_common_1.makeInputValueDefinition('id', graphql_transformer_common_1.makeNonNullType(graphql_transformer_common_1.makeNamedType('ID')))];
                case graphql_transformer_interfaces_1.QueryFieldType.LIST:
                    const filterInputName = graphql_transformer_common_1.toPascalCase(['Model', type.name.value, 'FilterInput']);
                    const filterInputs = graphql_types_1.createEnumModelFilters(ctx, type);
                    filterInputs.push(graphql_types_1.makeListQueryFilterInput(ctx, filterInputName, type));
                    for (let input of filterInputs) {
                        const conditionInputName = input.name.value;
                        if (!ctx.output.getType(conditionInputName)) {
                            ctx.output.addInput(input);
                        }
                    }
                    return [
                        graphql_transformer_common_1.makeInputValueDefinition('filter', graphql_transformer_common_1.makeNamedType(filterInputName)),
                        graphql_transformer_common_1.makeInputValueDefinition('limit', graphql_transformer_common_1.makeNamedType('Int')),
                        graphql_transformer_common_1.makeInputValueDefinition('nextToken', graphql_transformer_common_1.makeNamedType('String')),
                    ];
                case graphql_transformer_interfaces_1.QueryFieldType.SYNC:
                    const syncFilterInputName = graphql_transformer_common_1.toPascalCase(['Model', type.name.value, 'FilterInput']);
                    const syncFilterInputs = graphql_types_1.makeListQueryFilterInput(ctx, syncFilterInputName, type);
                    const conditionInputName = syncFilterInputs.name.value;
                    if (!ctx.output.getType(conditionInputName)) {
                        ctx.output.addInput(syncFilterInputs);
                    }
                    return [
                        graphql_transformer_common_1.makeInputValueDefinition('filter', graphql_transformer_common_1.makeNamedType(syncFilterInputName)),
                        graphql_transformer_common_1.makeInputValueDefinition('limit', graphql_transformer_common_1.makeNamedType('Int')),
                        graphql_transformer_common_1.makeInputValueDefinition('nextToken', graphql_transformer_common_1.makeNamedType('String')),
                        graphql_transformer_common_1.makeInputValueDefinition('lastSync', graphql_transformer_common_1.makeNamedType('AWSTimestamp')),
                    ];
                case graphql_transformer_interfaces_1.MutationFieldType.CREATE:
                    const createInputField = graphql_types_1.makeCreateInputField(type, this.modelDirectiveConfig.get(type.name.value), knownModels, ctx.inputDocument, isSyncEnabled);
                    const createInputTypeName = createInputField.name.value;
                    if (!ctx.output.getType(createInputField.name.value)) {
                        ctx.output.addInput(createInputField);
                    }
                    return [
                        graphql_transformer_common_1.makeInputValueDefinition('input', graphql_transformer_common_1.makeNonNullType(graphql_transformer_common_1.makeNamedType(createInputTypeName))),
                        graphql_transformer_common_1.makeInputValueDefinition('condition', graphql_transformer_common_1.makeNamedType(conditionInput.name.value)),
                    ];
                case graphql_transformer_interfaces_1.MutationFieldType.DELETE:
                    const deleteInputField = graphql_types_1.makeDeleteInputField(type, isSyncEnabled);
                    const deleteInputTypeName = deleteInputField.name.value;
                    if (!ctx.output.getType(deleteInputField.name.value)) {
                        ctx.output.addInput(deleteInputField);
                    }
                    return [
                        graphql_transformer_common_1.makeInputValueDefinition('input', graphql_transformer_common_1.makeNonNullType(graphql_transformer_common_1.makeNamedType(deleteInputTypeName))),
                        graphql_transformer_common_1.makeInputValueDefinition('condition', graphql_transformer_common_1.makeNamedType(conditionInput.name.value)),
                    ];
                case graphql_transformer_interfaces_1.MutationFieldType.UPDATE:
                    const updateInputField = graphql_types_1.makeUpdateInputField(type, this.modelDirectiveConfig.get(type.name.value), knownModels, ctx.inputDocument, isSyncEnabled);
                    const updateInputTypeName = updateInputField.name.value;
                    if (!ctx.output.getType(updateInputField.name.value)) {
                        ctx.output.addInput(updateInputField);
                    }
                    return [
                        graphql_transformer_common_1.makeInputValueDefinition('input', graphql_transformer_common_1.makeNonNullType(graphql_transformer_common_1.makeNamedType(updateInputTypeName))),
                        graphql_transformer_common_1.makeInputValueDefinition('condition', graphql_transformer_common_1.makeNamedType(conditionInput.name.value)),
                    ];
                case graphql_transformer_interfaces_1.SubscriptionFieldType.ON_CREATE:
                case graphql_transformer_interfaces_1.SubscriptionFieldType.ON_DELETE:
                case graphql_transformer_interfaces_1.SubscriptionFieldType.ON_UPDATE:
                    return [];
                    break;
                default:
                    throw new Error('Unknown operation type');
            }
            return [];
        };
        this.getOutputType = (ctx, type, operation) => {
            let outputType;
            switch (operation.type) {
                case graphql_transformer_interfaces_1.MutationFieldType.CREATE:
                case graphql_transformer_interfaces_1.MutationFieldType.UPDATE:
                case graphql_transformer_interfaces_1.MutationFieldType.DELETE:
                case graphql_transformer_interfaces_1.QueryFieldType.GET:
                case graphql_transformer_interfaces_1.SubscriptionFieldType.ON_CREATE:
                case graphql_transformer_interfaces_1.SubscriptionFieldType.ON_DELETE:
                case graphql_transformer_interfaces_1.SubscriptionFieldType.ON_UPDATE:
                    outputType = type;
                    break;
                case graphql_transformer_interfaces_1.QueryFieldType.SYNC:
                case graphql_transformer_interfaces_1.QueryFieldType.LIST:
                    const isSyncEnabled = ctx.isProjectUsingDataStore();
                    const connectionFieldName = graphql_transformer_common_1.toPascalCase(['Model', type.name.value, 'Connection']);
                    outputType = graphql_types_1.makeListQueryModel(type, connectionFieldName, isSyncEnabled);
                    break;
                default:
                    throw new Error(`${operation.type} not supported for ${type.name.value}`);
            }
            if (!ctx.output.getObject(outputType.name.value)) {
                ctx.output.addObject(outputType);
            }
            return outputType;
        };
        this.createNonModelInputs = (ctx, obj) => {
            for (let field of obj.fields || []) {
                if (!graphql_transformer_common_1.isScalar(field.type)) {
                    const def = ctx.output.getType(graphql_transformer_common_1.getBaseType(field.type));
                    if (def && def.kind == 'ObjectTypeDefinition' && !this.isModelField(def.name.value)) {
                        const name = this.getNonModelInputObjectName(def.name.value);
                        if (!ctx.output.getType(name)) {
                            const inputObj = object_definition_wrapper_1.InputObjectDefinitionWrapper.fromObject(name, def, ctx.inputDocument);
                            ctx.output.addInput(inputObj.serialize());
                            this.createNonModelInputs(ctx, def);
                        }
                    }
                }
            }
        };
        this.isModelField = (name) => {
            return this.typesWithModelDirective.has(name) ? true : false;
        };
        this.getNonModelInputObjectName = (name) => {
            return `${name}Input`;
        };
        this.addAutoGeneratableFields = (ctx, name) => {
            var _a, _b;
            const modelDirectiveConfig = this.modelDirectiveConfig.get(name);
            const typeObj = ctx.output.getObject(name);
            if (!typeObj) {
                throw new Error(`Type ${name} is missing in outputs`);
            }
            const typeWrapper = new object_definition_wrapper_1.ObjectDefinitionWrapper(typeObj);
            if (!typeWrapper.hasField('id')) {
                const idField = object_definition_wrapper_1.FieldWrapper.create('id', 'ID');
                typeWrapper.addField(idField);
            }
            const timestamps = [];
            if (modelDirectiveConfig === null || modelDirectiveConfig === void 0 ? void 0 : modelDirectiveConfig.timestamps) {
                if (modelDirectiveConfig.timestamps.createdAt !== null) {
                    timestamps.push((_a = modelDirectiveConfig.timestamps.createdAt) !== null && _a !== void 0 ? _a : 'createdAt');
                }
                if (modelDirectiveConfig.timestamps.updatedAt !== null) {
                    timestamps.push((_b = modelDirectiveConfig.timestamps.updatedAt) !== null && _b !== void 0 ? _b : 'updatedAt');
                }
            }
            for (let fieldName of timestamps) {
                if (typeWrapper.hasField(fieldName)) {
                    const field = typeWrapper.getField(fieldName);
                    if (!['String', 'AWSDateTime'].includes(field.getTypeName())) {
                        console.warn(`type ${name}.${fieldName} is not of String or AWSDateTime. Auto population is not supported`);
                    }
                }
                else {
                    const field = object_definition_wrapper_1.FieldWrapper.create(fieldName, 'AWSDateTime');
                    typeWrapper.addField(field);
                }
            }
            ctx.output.updateObject(typeWrapper.serialize());
        };
        this.addModelSyncFields = (ctx, name) => {
            const typeObj = ctx.output.getObject(name);
            if (!typeObj) {
                throw new Error(`Type ${name} is missing in outputs`);
            }
            const typeWrapper = new object_definition_wrapper_1.ObjectDefinitionWrapper(typeObj);
            typeWrapper.addField(object_definition_wrapper_1.FieldWrapper.create('_version', 'Int'));
            typeWrapper.addField(object_definition_wrapper_1.FieldWrapper.create('_deleted', 'Boolean', true));
            typeWrapper.addField(object_definition_wrapper_1.FieldWrapper.create('_lastChangedAt', 'AWSTimestamp'));
            ctx.output.updateObject(typeWrapper.serialize());
        };
        this.getSubscriptionToMutationsReverseMap = (ctx, def) => {
            const subscriptionToMutationsMap = {};
            const subscriptionFieldNames = this.getSubscriptionFieldNames(ctx, def);
            for (const subscriptionFieldName of subscriptionFieldNames) {
                if (!subscriptionToMutationsMap[subscriptionFieldName.fieldName]) {
                    subscriptionToMutationsMap[subscriptionFieldName.fieldName] = [];
                }
                subscriptionToMutationsMap[subscriptionFieldName.fieldName].push(subscriptionFieldName);
            }
            return subscriptionToMutationsMap;
        };
        this.getOptions = (options) => {
            return {
                EnableDeletionProtection: false,
                ...options,
            };
        };
        this.ensureValidSubscriptionName = (name) => {
            if (name.length <= 50)
                return name;
            return name.slice(0, 45) + md5_1.default(name).slice(0, 5);
        };
        this.options = this.getOptions(options);
    }
    createModelTable(stack, def, context) {
        const tableLogicalName = `${def.name.value}Table`;
        const tableName = context.resourceHelper.generateResourceName(def.name.value);
        const env = context.stackManager.getParameter(graphql_transformer_common_1.ResourceConstants.PARAMETERS.Env);
        const readIops = new cdk.CfnParameter(stack, graphql_transformer_common_1.ResourceConstants.PARAMETERS.DynamoDBModelTableReadIOPS, {
            description: 'The number of read IOPS the table should support.',
            type: 'Number',
            default: 5,
        }).valueAsString;
        const writeIops = new cdk.CfnParameter(stack, graphql_transformer_common_1.ResourceConstants.PARAMETERS.DynamoDBModelTableWriteIOPS, {
            description: 'The number of write IOPS the table should support.',
            type: 'Number',
            default: 5,
        }).valueAsString;
        const billingMode = new cdk.CfnParameter(stack, graphql_transformer_common_1.ResourceConstants.PARAMETERS.DynamoDBBillingMode, {
            description: 'Configure @model types to create DynamoDB tables with PAY_PER_REQUEST or PROVISIONED billing modes.',
            type: 'String',
            default: 'PAY_PER_REQUEST',
            allowedValues: ['PAY_PER_REQUEST', 'PROVISIONED'],
        }).valueAsString;
        const pointInTimeRecovery = new cdk.CfnParameter(stack, graphql_transformer_common_1.ResourceConstants.PARAMETERS.DynamoDBEnablePointInTimeRecovery, {
            description: 'Whether to enable Point in Time Recovery on the table.',
            type: 'String',
            default: 'false',
            allowedValues: ['true', 'false'],
        }).valueAsString;
        const enableSSE = new cdk.CfnParameter(stack, graphql_transformer_common_1.ResourceConstants.PARAMETERS.DynamoDBEnableServerSideEncryption, {
            description: 'Enable server side encryption powered by KMS.',
            type: 'String',
            default: 'true',
            allowedValues: ['true', 'false'],
        }).valueAsString;
        new cdk.CfnCondition(stack, graphql_transformer_common_1.ResourceConstants.CONDITIONS.HasEnvironmentParameter, {
            expression: cdk.Fn.conditionNot(cdk.Fn.conditionEquals(env, graphql_transformer_common_1.ResourceConstants.NONE)),
        });
        const useSSE = new cdk.CfnCondition(stack, graphql_transformer_common_1.ResourceConstants.CONDITIONS.ShouldUseServerSideEncryption, {
            expression: cdk.Fn.conditionEquals(enableSSE, 'true'),
        });
        const usePayPerRequestBilling = new cdk.CfnCondition(stack, graphql_transformer_common_1.ResourceConstants.CONDITIONS.ShouldUsePayPerRequestBilling, {
            expression: cdk.Fn.conditionEquals(billingMode, 'PAY_PER_REQUEST'),
        });
        const usePointInTimeRecovery = new cdk.CfnCondition(stack, graphql_transformer_common_1.ResourceConstants.CONDITIONS.ShouldUsePointInTimeRecovery, {
            expression: cdk.Fn.conditionEquals(pointInTimeRecovery, 'true'),
        });
        const removalPolicy = this.options.EnableDeletionProtection ? cdk.RemovalPolicy.RETAIN : cdk.RemovalPolicy.DESTROY;
        const table = new aws_dynamodb_1.Table(stack, tableLogicalName, {
            tableName,
            partitionKey: {
                name: 'id',
                type: aws_dynamodb_1.AttributeType.STRING,
            },
            stream: aws_dynamodb_1.StreamViewType.NEW_AND_OLD_IMAGES,
            encryption: aws_dynamodb_1.TableEncryption.DEFAULT,
            removalPolicy: removalPolicy,
            ...(context.isProjectUsingDataStore() ? { timeToLiveAttribute: '_ttl' } : undefined),
        });
        const cfnTable = table.node.defaultChild;
        cfnTable.provisionedThroughput = cdk.Fn.conditionIf(usePayPerRequestBilling.logicalId, cdk.Fn.ref('AWS::NoValue'), {
            ReadCapacityUnits: readIops,
            WriteCapacityUnits: writeIops,
        });
        cfnTable.pointInTimeRecoverySpecification = cdk.Fn.conditionIf(usePointInTimeRecovery.logicalId, { PointInTimeRecoveryEnabled: true }, cdk.Fn.ref('AWS::NoValue'));
        cfnTable.billingMode = cdk.Fn.conditionIf(usePayPerRequestBilling.logicalId, 'PAY_PER_REQUEST', cdk.Fn.ref('AWS::NoValue')).toString();
        cfnTable.sseSpecification = {
            sseEnabled: cdk.Fn.conditionIf(useSSE.logicalId, true, false),
        };
        const streamArnOutputId = `GetAtt${graphql_transformer_common_1.ModelResourceIDs.ModelTableStreamArn(def.name.value)}`;
        new cdk.CfnOutput(stack, streamArnOutputId, {
            value: cdk.Fn.getAtt(tableLogicalName, 'StreamArn').toString(),
            description: 'Your DynamoDB table StreamArn.',
            exportName: cdk.Fn.join(':', [context.api.apiId, 'GetAtt', tableLogicalName, 'StreamArn']),
        });
        const tableNameOutputId = `GetAtt${tableLogicalName}Name`;
        new cdk.CfnOutput(stack, tableNameOutputId, {
            value: cdk.Fn.ref(tableLogicalName),
            description: 'Your DynamoDB table name.',
            exportName: cdk.Fn.join(':', [context.api.apiId, 'GetAtt', tableLogicalName, 'Name']),
        });
        const role = this.createIAMRole(context, def, stack, tableName);
        this.createModelTableDataSource(def, context, table, stack, role);
    }
    createModelTableDataSource(def, context, table, stack, role) {
        const tableLogicalName = `${def.name.value}Table`;
        const datasourceRoleLogicalID = graphql_transformer_common_1.ModelResourceIDs.ModelTableDataSourceID(def.name.value);
        const dataSource = context.api.host.addDynamoDbDataSource(datasourceRoleLogicalID, table, { name: tableLogicalName, serviceRole: role }, stack);
        const cfnDataSource = dataSource.node.defaultChild;
        cfnDataSource.addDependsOn(role.node.defaultChild);
        if (context.isProjectUsingDataStore()) {
            const datasourceDynamoDb = cfnDataSource.dynamoDbConfig;
            datasourceDynamoDb.deltaSyncConfig = {
                deltaSyncTableName: context.resourceHelper.generateResourceName(graphql_transformer_common_1.SyncResourceIDs.syncTableName),
                deltaSyncTableTtl: '30',
                baseTableTtl: '43200',
            };
            datasourceDynamoDb.versioned = true;
        }
        const datasourceOutputId = `GetAtt${datasourceRoleLogicalID}Name`;
        new cdk.CfnOutput(stack, datasourceOutputId, {
            value: dataSource.ds.attrName,
            description: 'Your model DataSource name.',
            exportName: cdk.Fn.join(':', [context.api.apiId, 'GetAtt', datasourceRoleLogicalID, 'Name']),
        });
        context.dataSources.add(def, dataSource);
        this.datasourceMap[def.name.value] = dataSource;
    }
    createIAMRole(context, def, stack, tableName) {
        const roleName = context.resourceHelper.generateIAMRoleName(graphql_transformer_common_1.ModelResourceIDs.ModelTableIAMRoleID(def.name.value));
        const role = new iam.Role(stack, graphql_transformer_common_1.ModelResourceIDs.ModelTableIAMRoleID(def.name.value), {
            roleName: roleName,
            assumedBy: new iam.ServicePrincipal('appsync.amazonaws.com'),
        });
        const amplifyDataStoreTableName = context.resourceHelper.generateResourceName(graphql_transformer_common_1.SyncResourceIDs.syncTableName);
        role.attachInlinePolicy(new iam.Policy(stack, 'DynamoDBAccess', {
            statements: [
                new iam.PolicyStatement({
                    effect: iam.Effect.ALLOW,
                    actions: [
                        'dynamodb:BatchGetItem',
                        'dynamodb:BatchWriteItem',
                        'dynamodb:PutItem',
                        'dynamodb:DeleteItem',
                        'dynamodb:GetItem',
                        'dynamodb:Scan',
                        'dynamodb:Query',
                        'dynamodb:UpdateItem',
                    ],
                    resources: [
                        cdk.Fn.sub('arn:aws:dynamodb:${AWS::Region}:${AWS::AccountId}:table/${tablename}', {
                            tablename: tableName,
                        }),
                        cdk.Fn.sub('arn:aws:dynamodb:${AWS::Region}:${AWS::AccountId}:table/${tablename}/*', {
                            tablename: tableName,
                        }),
                        ...(context.isProjectUsingDataStore()
                            ? [
                                cdk.Fn.sub('arn:aws:dynamodb:${AWS::Region}:${AWS::AccountId}:table/${tablename}', {
                                    tablename: amplifyDataStoreTableName,
                                }),
                                cdk.Fn.sub('arn:aws:dynamodb:${AWS::Region}:${AWS::AccountId}:table/${tablename}/*', {
                                    tablename: amplifyDataStoreTableName,
                                }),
                            ]
                            : []),
                    ],
                }),
            ],
        }));
        const syncConfig = graphql_transformer_core_1.SyncUtils.getSyncConfig(context, def.name.value);
        if (syncConfig && graphql_transformer_core_1.SyncUtils.isLambdaSyncConfig(syncConfig)) {
            role.attachInlinePolicy(graphql_transformer_core_1.SyncUtils.createSyncLambdaIAMPolicy(stack, syncConfig.LambdaConflictHandler.name, syncConfig.LambdaConflictHandler.region));
        }
        return role;
    }
    ensureModelSortDirectionEnum(ctx) {
        if (!ctx.output.hasType('ModelSortDirection')) {
            const modelSortDirection = graphql_types_1.makeModelSortDirectionEnumObject();
            ctx.output.addEnum(modelSortDirection);
        }
    }
}
exports.ModelTransformer = ModelTransformer;
//# sourceMappingURL=graphql-model-transformer.js.map