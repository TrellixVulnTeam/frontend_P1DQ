"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.pullHooks = exports.downloadHooks = exports.uploadHooksDirectory = exports.S3_HOOKS_DIRECTORY = void 0;
const amplify_cli_core_1 = require("amplify-cli-core");
const path = __importStar(require("path"));
const ignore_1 = __importDefault(require("ignore"));
const aws_s3_1 = require("../aws-utils/aws-s3");
const aws = __importStar(require("aws-sdk"));
const fs = __importStar(require("fs-extra"));
const glob_1 = require("glob");
const constants_1 = require("../constants");
exports.S3_HOOKS_DIRECTORY = 'hooks/';
const aws_logger_1 = require("../utils/aws-logger");
const logger = aws_logger_1.fileLogger('hooks-manager');
const uploadHooksDirectory = async (context) => {
    var _a, _b;
    if (amplify_cli_core_1.skipHooks()) {
        return;
    }
    const hooksDirectoryPath = amplify_cli_core_1.pathManager.getHooksDirPath((_b = (_a = context.exeInfo) === null || _a === void 0 ? void 0 : _a.localEnvInfo) === null || _b === void 0 ? void 0 : _b.projectPath);
    await deleteHooksFromS3(context);
    if (!fs.existsSync(hooksDirectoryPath)) {
        return;
    }
    const relativeFilePathsToUpload = getNonIgnoredFileList(context);
    const s3 = await aws_s3_1.S3.getInstance(context);
    for (const relativeFilePathToUpload of relativeFilePathsToUpload) {
        const absolutefilePathToUpload = path.join(hooksDirectoryPath, relativeFilePathToUpload);
        if (fs.existsSync(absolutefilePathToUpload)) {
            const s3Params = {
                Body: fs.createReadStream(absolutefilePathToUpload),
                Key: getS3Key(relativeFilePathToUpload),
            };
            await s3.uploadFile(s3Params);
        }
    }
};
exports.uploadHooksDirectory = uploadHooksDirectory;
const downloadHooks = async (context, backendEnv, awsConfigInfo) => {
    if (amplify_cli_core_1.skipHooks()) {
        return;
    }
    if (!backendEnv) {
        return;
    }
    const projectPath = process.cwd();
    const hooksDirPath = amplify_cli_core_1.pathManager.getHooksDirPath(projectPath);
    const s3 = new aws.S3(awsConfigInfo);
    const deploymentBucketName = backendEnv.deploymentArtifacts;
    const params = {
        Prefix: exports.S3_HOOKS_DIRECTORY,
        Bucket: deploymentBucketName,
    };
    const log = logger('downloadHooks.s3.listObjects', [params]);
    let listHookObjects;
    try {
        log();
        listHookObjects = await s3.listObjects(params).promise();
    }
    catch (ex) {
        log(ex);
        throw ex;
    }
    for (const listHookObject of listHookObjects.Contents) {
        const params = {
            Key: listHookObject.Key,
            Bucket: deploymentBucketName,
        };
        const log = logger('downloadHooks.s3.getObject', [params]);
        let hooksFileObject = null;
        try {
            log();
            hooksFileObject = await s3.getObject(params).promise();
        }
        catch (ex) {
            log(ex);
            throw ex;
        }
        const hooksFilePath = getHooksFilePathFromS3Key(hooksDirPath, listHookObject.Key);
        placeFile(hooksFilePath, hooksFileObject.Body);
    }
};
exports.downloadHooks = downloadHooks;
const pullHooks = async (context) => {
    var _a, _b, _c;
    if (amplify_cli_core_1.skipHooks()) {
        return;
    }
    const projectDetails = context.amplify.getProjectDetails();
    const envName = context.amplify.getEnvInfo().envName;
    const projectBucket = (_c = (_b = (_a = projectDetails.teamProviderInfo) === null || _a === void 0 ? void 0 : _a[envName]) === null || _b === void 0 ? void 0 : _b[constants_1.ProviderName]) === null || _c === void 0 ? void 0 : _c.DeploymentBucketName;
    const hooksDirPath = amplify_cli_core_1.pathManager.getHooksDirPath();
    const s3 = await aws_s3_1.S3.getInstance(context);
    const listHookObjects = await s3.getAllObjectVersions(projectBucket, {
        Prefix: exports.S3_HOOKS_DIRECTORY,
    });
    cleanHooksDirectory(context);
    for (const listHookObject of listHookObjects) {
        let hooksFileData = null;
        hooksFileData = await s3.getFile({
            Key: listHookObject.Key,
        });
        const hooksFilePath = getHooksFilePathFromS3Key(hooksDirPath, listHookObject.Key);
        placeFile(hooksFilePath, hooksFileData);
    }
};
exports.pullHooks = pullHooks;
const deleteHooksFromS3 = async (context) => {
    var _a, _b, _c, _d, _e, _f;
    const envName = (_b = (_a = context.amplify) === null || _a === void 0 ? void 0 : _a.getEnvInfo()) === null || _b === void 0 ? void 0 : _b.envName;
    const projectDetails = (_c = context.amplify) === null || _c === void 0 ? void 0 : _c.getProjectDetails();
    const projectBucket = (_f = (_e = (_d = projectDetails.teamProviderInfo) === null || _d === void 0 ? void 0 : _d[envName]) === null || _e === void 0 ? void 0 : _e[constants_1.ProviderName]) === null || _f === void 0 ? void 0 : _f.DeploymentBucketName;
    if (!envName || !projectDetails || !projectBucket) {
        return;
    }
    const s3 = await aws_s3_1.S3.getInstance(context);
    await s3.deleteDirectory(projectBucket, exports.S3_HOOKS_DIRECTORY);
};
const getHooksFilePathList = (context) => {
    var _a, _b;
    const hooksDirectoryPath = amplify_cli_core_1.pathManager.getHooksDirPath((_b = (_a = context.exeInfo) === null || _a === void 0 ? void 0 : _a.localEnvInfo) === null || _b === void 0 ? void 0 : _b.projectPath);
    const posixHooksDirectoryPath = convertToPosixPath(hooksDirectoryPath);
    return glob_1.sync(posixHooksDirectoryPath.concat('/**/*'))
        .filter(file => fs.lstatSync(file).isFile())
        .map(file => path.relative(hooksDirectoryPath, file));
};
const getNonIgnoredFileList = (context) => {
    var _a, _b, _c;
    const ig = ignore_1.default();
    const configFile = (_c = amplify_cli_core_1.stateManager.getHooksConfigJson((_b = (_a = context.exeInfo) === null || _a === void 0 ? void 0 : _a.localEnvInfo) === null || _b === void 0 ? void 0 : _b.projectPath)) !== null && _c !== void 0 ? _c : {};
    if (configFile.ignore) {
        ig.add(configFile.ignore);
    }
    return ig.filter(getHooksFilePathList(context));
};
const getHooksFilePathFromS3Key = (hooksDirPath, s3Key) => {
    if (s3Key.substring(0, exports.S3_HOOKS_DIRECTORY.length) === exports.S3_HOOKS_DIRECTORY) {
        s3Key = s3Key.substring(exports.S3_HOOKS_DIRECTORY.length);
    }
    return path.join(hooksDirPath, ...s3Key.split('/'));
};
const cleanHooksDirectory = (context) => {
    var _a, _b;
    const relativeFilePathsList = getNonIgnoredFileList(context);
    const hooksDirectoryPath = amplify_cli_core_1.pathManager.getHooksDirPath((_b = (_a = context.exeInfo) === null || _a === void 0 ? void 0 : _a.localEnvInfo) === null || _b === void 0 ? void 0 : _b.projectPath);
    for (const relativeFilePath of relativeFilePathsList) {
        const absolutefilePathToUpload = path.join(hooksDirectoryPath, relativeFilePath);
        if (fs.lstatSync(absolutefilePathToUpload).isFile() && relativeFilePath !== amplify_cli_core_1.PathConstants.HooksConfigFileName) {
            fs.removeSync(absolutefilePathToUpload);
        }
    }
};
const placeFile = (filePath, data) => {
    fs.ensureFileSync(filePath);
    fs.writeFileSync(filePath, data);
};
const convertToPosixPath = (filePath) => {
    return filePath.split(path.sep).join(path.posix.sep);
};
const getS3Key = (relativePath) => {
    return exports.S3_HOOKS_DIRECTORY + convertToPosixPath(relativePath);
};
//# sourceMappingURL=hooks-manager.js.map