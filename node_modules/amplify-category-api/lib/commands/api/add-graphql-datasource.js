"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const fs = __importStar(require("fs-extra"));
const path = __importStar(require("path"));
const graphql = __importStar(require("graphql"));
const lodash_1 = __importDefault(require("lodash"));
const inquirer_1 = __importDefault(require("inquirer"));
const graphql_relational_schema_transformer_1 = require("graphql-relational-schema-transformer");
const merge_1 = require("@graphql-tools/merge");
const amplify_cli_core_1 = require("amplify-cli-core");
const subcommand = 'add-graphql-datasource';
const categories = 'categories';
const category = 'api';
const providerName = 'awscloudformation';
module.exports = {
    name: subcommand,
    run: async (context) => {
        try {
            const servicesMetadata = (await Promise.resolve().then(() => __importStar(require('../../provider-utils/supported-datasources')))).supportedDatasources;
            const AWS = await getAwsClient(context, 'list');
            const result = await datasourceSelectionPrompt(context, servicesMetadata);
            const providerController = await Promise.resolve().then(() => __importStar(require(`../../provider-utils/${result.providerName}/index`)));
            if (!providerController) {
                context.print.error('Provider not configured for this category');
                return;
            }
            const { datasource } = result;
            const answers = await providerController.addDatasource(context, category, datasource);
            const { resourceName, databaseName } = answers;
            const currEnv = context.amplify.getEnvInfo().envName;
            const teamProviderInfo = amplify_cli_core_1.stateManager.getTeamProviderInfo();
            lodash_1.default.set(teamProviderInfo, [currEnv, categories, category, resourceName], {
                rdsRegion: answers.region,
                rdsClusterIdentifier: answers.dbClusterArn,
                rdsSecretStoreArn: answers.secretStoreArn,
                rdsDatabaseName: answers.databaseName,
            });
            amplify_cli_core_1.stateManager.setTeamProviderInfo(undefined, teamProviderInfo);
            const backendConfig = amplify_cli_core_1.stateManager.getBackendConfig();
            backendConfig[category][resourceName]['rdsInit'] = true;
            amplify_cli_core_1.stateManager.setBackendConfig(undefined, backendConfig);
            const dbReader = new graphql_relational_schema_transformer_1.AuroraServerlessMySQLDatabaseReader(answers.region, answers.secretStoreArn, answers.dbClusterArn, answers.databaseName, AWS);
            const improvePluralizationFlag = amplify_cli_core_1.FeatureFlags.getBoolean('graphqltransformer.improvePluralization');
            const relationalSchemaTransformer = new graphql_relational_schema_transformer_1.RelationalDBSchemaTransformer(dbReader, answers.databaseName, improvePluralizationFlag);
            const graphqlSchemaContext = await relationalSchemaTransformer.introspectDatabaseSchema();
            if (graphqlSchemaContext === null) {
                context.print.warning('No importable tables were found in the selected Database.');
                context.print.info('');
                return;
            }
            const apiDirPath = path.join(amplify_cli_core_1.pathManager.getBackendDirPath(), category, resourceName);
            fs.ensureDirSync(apiDirPath);
            const graphqlSchemaFilePath = path.join(apiDirPath, 'schema.graphql');
            const rdsGraphQLSchemaDoc = graphqlSchemaContext.schemaDoc;
            const schemaDirectoryPath = path.join(apiDirPath, 'schema');
            if (fs.existsSync(graphqlSchemaFilePath)) {
                const typesToBeMerged = [rdsGraphQLSchemaDoc];
                const currGraphQLSchemaDoc = readSchema(graphqlSchemaFilePath);
                if (currGraphQLSchemaDoc) {
                    typesToBeMerged.unshift(currGraphQLSchemaDoc);
                }
                else {
                    context.print.warning(`Graphql Schema file "${graphqlSchemaFilePath}" is empty.`);
                    context.print.info('');
                }
                const concatGraphQLSchemaDoc = merge_1.mergeTypeDefs(typesToBeMerged);
                fs.writeFileSync(graphqlSchemaFilePath, graphql.print(concatGraphQLSchemaDoc), 'utf8');
            }
            else if (fs.existsSync(schemaDirectoryPath)) {
                const rdsSchemaFilePath = path.join(schemaDirectoryPath, 'rds.graphql');
                fs.writeFileSync(rdsSchemaFilePath, graphql.print(rdsGraphQLSchemaDoc), 'utf8');
            }
            else {
                throw new Error(`Could not find a schema in either ${graphqlSchemaFilePath} or schema directory at ${schemaDirectoryPath}`);
            }
            const resolversDir = path.join(apiDirPath, 'resolvers');
            const templateGenerator = new graphql_relational_schema_transformer_1.RelationalDBTemplateGenerator(graphqlSchemaContext);
            let template = templateGenerator.createTemplate(context);
            template = templateGenerator.addRelationalResolvers(template, resolversDir, improvePluralizationFlag);
            const cfn = templateGenerator.printCloudformationTemplate(template);
            const stacksDir = path.join(apiDirPath, 'stacks');
            const writeToPath = path.join(stacksDir, `${resourceName}-${databaseName}-rds.json`);
            fs.writeFileSync(writeToPath, cfn, 'utf8');
            context.amplify.executeProviderUtils(context, 'awscloudformation', 'compileSchema', { forceCompile: true });
            context.print.success(`Successfully added the ${datasource} datasource locally`);
            context.print.info('');
            context.print.success('Some next steps:');
            context.print.info('"amplify push" will build all your local backend resources and provision it in the cloud');
            context.print.info('"amplify publish" will build all your local backend and frontend resources (if you have hosting category added) and provision it in the cloud');
            context.print.info('');
        }
        catch (error) {
            context.print.info(error.stack);
            context.print.error('There was an error adding the datasource');
            await context.usageData.emitError(error);
            process.exitCode = 1;
        }
    },
    readSchema,
};
async function datasourceSelectionPrompt(context, supportedDatasources) {
    const options = [];
    Object.keys(supportedDatasources).forEach(datasource => {
        const optionName = supportedDatasources[datasource].alias ||
            `${supportedDatasources[datasource].providerName}:${supportedDatasources[datasource].service}`;
        options.push({
            name: optionName,
            value: {
                provider: supportedDatasources[datasource].provider,
                datasource,
                providerName: supportedDatasources[datasource].provider,
            },
        });
    });
    if (options.length === 0) {
        const errMessage = `No datasources defined by configured providers for category: ${category}`;
        context.print.error(errMessage);
        await context.usageData.emitError(new amplify_cli_core_1.ResourceDoesNotExistError(errMessage));
        amplify_cli_core_1.exitOnNextTick(1);
    }
    if (options.length === 1) {
        context.print.info(`Using datasource: ${options[0].value.datasource}, provided by: ${options[0].value.providerName}`);
        return new Promise(resolve => {
            resolve(options[0].value);
        });
    }
    const question = [
        {
            name: 'datasource',
            message: 'Please select from one of the below mentioned datasources',
            type: 'list',
            choices: options,
        },
    ];
    return inquirer_1.default.prompt(question).then(answer => answer.datasource);
}
async function getAwsClient(context, action) {
    const providerPlugins = context.amplify.getProviderPlugins(context);
    const provider = require(providerPlugins[providerName]);
    return await provider.getConfiguredAWSClient(context, 'aurora-serverless', action);
}
function readSchema(graphqlSchemaFilePath) {
    const graphqlSchemaRaw = fs.readFileSync(graphqlSchemaFilePath).toString();
    if (graphqlSchemaRaw.trim().length === 0) {
        return null;
    }
    let currGraphQLSchemaDoc;
    try {
        currGraphQLSchemaDoc = graphql.parse(graphqlSchemaRaw);
    }
    catch (err) {
        const relativePathToInput = path.relative(process.cwd(), graphqlSchemaRaw);
        const error = new Error(`Could not parse graphql schema \n${relativePathToInput}\n${err.message}`);
        error.stack = undefined;
        throw error;
    }
    return currGraphQLSchemaDoc;
}
//# sourceMappingURL=add-graphql-datasource.js.map