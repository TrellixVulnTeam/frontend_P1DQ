"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.serviceWalkthrough = void 0;
const inquirer_1 = __importDefault(require("inquirer"));
const chalk_1 = __importDefault(require("chalk"));
const ora_1 = __importDefault(require("ora"));
const graphql_relational_schema_transformer_1 = require("graphql-relational-schema-transformer");
const amplify_cli_core_1 = require("amplify-cli-core");
const spinner = ora_1.default('');
const category = 'api';
const providerName = 'awscloudformation';
async function serviceWalkthrough(context, defaultValuesFilename, datasourceMetadata) {
    const amplifyMeta = context.amplify.getProjectMeta();
    if (amplifyMeta == null || amplifyMeta[category] == null || Object.keys(amplifyMeta[category]).length === 0) {
        const errMessage = 'You must create an AppSync API in your project before adding a graphql datasource. Please use "amplify api add" to create the API.';
        context.print.error(errMessage);
        await context.usageData.emitError(new amplify_cli_core_1.ResourceDoesNotExistError(errMessage));
        amplify_cli_core_1.exitOnNextTick(0);
    }
    let appSyncApi;
    const apis = Object.keys(amplifyMeta[category]);
    for (let i = 0; i < apis.length; i += 1) {
        if (amplifyMeta[category][apis[i]].service === 'AppSync') {
            appSyncApi = apis[i];
            break;
        }
    }
    if (!appSyncApi) {
        const errMessage = 'You must create an AppSync API in your project before adding a graphql datasource. Please use "amplify api add" to create the API.';
        context.print.error(errMessage);
        await context.usageData.emitError(new amplify_cli_core_1.ResourceDoesNotExistError(errMessage));
        amplify_cli_core_1.exitOnNextTick(0);
    }
    const { inputs, availableRegions } = datasourceMetadata;
    const selectedRegion = await promptWalkthroughQuestion(inputs, 0, availableRegions);
    const AWS = await getAwsClient(context, 'list');
    AWS.config.update({
        region: selectedRegion,
    });
    const { selectedClusterArn, clusterResourceId } = await selectCluster(context, inputs, AWS);
    const selectedSecretArn = await getSecretStoreArn(context, inputs, clusterResourceId, AWS);
    const selectedDatabase = await selectDatabase(context, inputs, selectedClusterArn, selectedSecretArn, AWS);
    return {
        region: selectedRegion,
        dbClusterArn: selectedClusterArn,
        secretStoreArn: selectedSecretArn,
        databaseName: selectedDatabase,
        resourceName: appSyncApi,
    };
}
exports.serviceWalkthrough = serviceWalkthrough;
async function selectCluster(context, inputs, AWS) {
    const RDS = new AWS.RDS();
    const describeDBClustersResult = await RDS.describeDBClusters().promise();
    const rawClusters = describeDBClustersResult.DBClusters;
    const clusters = new Map();
    const serverlessClusters = rawClusters.filter(cluster => cluster.EngineMode === 'serverless');
    if (serverlessClusters.length === 0) {
        const errMessage = 'No properly configured Aurora Serverless clusters found.';
        context.print.error(errMessage);
        await context.usageData.emitError(new amplify_cli_core_1.ResourceDoesNotExistError(errMessage));
        amplify_cli_core_1.exitOnNextTick(0);
    }
    for (const cluster of serverlessClusters) {
        clusters.set(cluster.DBClusterIdentifier, cluster);
    }
    if (clusters.size > 1) {
        const clusterIdentifier = await promptWalkthroughQuestion(inputs, 1, Array.from(clusters.keys()));
        const selectedCluster = clusters.get(clusterIdentifier);
        return {
            selectedClusterArn: selectedCluster.DBClusterArn,
            clusterResourceId: selectedCluster.DbClusterResourceId,
        };
    }
    const firstCluster = Array.from(clusters.values())[0];
    context.print.info(`${chalk_1.default.green('✔')} Only one Cluster was found: '${firstCluster.DBClusterIdentifier}' was automatically selected.`);
    return {
        selectedClusterArn: firstCluster.DBClusterArn,
        clusterResourceId: firstCluster.DbClusterResourceId,
    };
}
async function getSecretStoreArn(context, inputs, clusterResourceId, AWS) {
    const SecretsManager = new AWS.SecretsManager();
    const NextToken = 'NextToken';
    let rawSecrets = [];
    const params = {
        MaxResults: 20,
    };
    const listSecretsResult = await SecretsManager.listSecrets(params).promise();
    rawSecrets = listSecretsResult.SecretList;
    let token = listSecretsResult.NextToken;
    while (token) {
        params[NextToken] = token;
        const tempSecretsResult = await SecretsManager.listSecrets(params).promise();
        rawSecrets = [...rawSecrets, ...tempSecretsResult.SecretList];
        token = tempSecretsResult.NextToken;
    }
    const secrets = new Map();
    const secretsForCluster = rawSecrets.filter(secret => secret.Name.startsWith(`rds-db-credentials/${clusterResourceId}`));
    if (secretsForCluster.length === 0) {
        const errMessage = 'No RDS access credentials found in the AWS Secrect Manager.';
        context.print.error(errMessage);
        await context.usageData.emitError(new amplify_cli_core_1.ResourceCredentialsNotFoundError(errMessage));
        amplify_cli_core_1.exitOnNextTick(0);
    }
    for (const secret of secretsForCluster) {
        secrets.set(secret.Name, secret.ARN);
    }
    let selectedSecretArn;
    if (secrets.size > 1) {
        const selectedSecretName = await promptWalkthroughQuestion(inputs, 2, Array.from(secrets.keys()));
        selectedSecretArn = secrets.get(selectedSecretName);
    }
    else {
        selectedSecretArn = Array.from(secrets.values())[0];
        context.print.info(`${chalk_1.default.green('✔')} Only one Secret was found for the cluster: '${selectedSecretArn}' was automatically selected.`);
    }
    return selectedSecretArn;
}
async function selectDatabase(context, inputs, clusterArn, secretArn, AWS) {
    const DataApi = new AWS.RDSDataService();
    const params = new graphql_relational_schema_transformer_1.DataApiParams();
    const databaseList = [];
    params.secretArn = secretArn;
    params.resourceArn = clusterArn;
    params.sql = 'SHOW databases';
    spinner.start('Fetching Aurora Serverless cluster...');
    try {
        const dataApiResult = await DataApi.executeStatement(params).promise();
        const excludedDatabases = ['information_schema', 'performance_schema', 'mysql', 'sys'];
        databaseList.push(...dataApiResult.records.map(record => record[0].stringValue).filter(name => !excludedDatabases.includes(name)));
        spinner.succeed('Fetched Aurora Serverless cluster.');
    }
    catch (err) {
        spinner.fail(err.message);
        if (err.code === 'BadRequestException' && /Access denied for user/.test(err.message)) {
            const msg = `Ensure that '${secretArn}' contains your database credentials. ` +
                'Please note that Aurora Serverless does not support IAM database authentication.';
            context.print.error(msg);
        }
    }
    if (databaseList.length === 0) {
        const errMessage = 'No database found in the selected cluster.';
        context.print.error(errMessage);
        await context.usageData.emitError(new amplify_cli_core_1.ResourceDoesNotExistError(errMessage));
        amplify_cli_core_1.exitOnNextTick(0);
    }
    if (databaseList.length > 1) {
        return await promptWalkthroughQuestion(inputs, 3, databaseList);
    }
    context.print.info(`${chalk_1.default.green('✔')} Only one Database was found: '${databaseList[0]}' was automatically selected.`);
    return databaseList[0];
}
async function promptWalkthroughQuestion(inputs, questionNumber, choicesList) {
    const question = [
        {
            type: inputs[questionNumber].type,
            name: inputs[questionNumber].key,
            message: inputs[questionNumber].question,
            choices: choicesList,
        },
    ];
    const answer = await inquirer_1.default.prompt(question);
    return answer[inputs[questionNumber].key];
}
async function getAwsClient(context, action) {
    const providerPlugins = context.amplify.getProviderPlugins(context);
    const provider = require(providerPlugins[providerName]);
    return await provider.getConfiguredAWSClient(context, 'aurora-serverless', action);
}
//# sourceMappingURL=appSync-rds-walkthrough.js.map